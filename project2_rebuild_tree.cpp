#include <iostream>
#include <vector>
using namespace std;


struct TreeNode;
typedef struct TreeNode *Position;
typedef struct TreeNode *SearchTree;
typedef int ElementType;

struct TreeNode
{
	ElementType Element;
	SearchTree Left;
	SearchTree Right;
	TreeNode(ElementType e, SearchTree l, SearchTree r): Element(e), Left(l), Right(r) {}
};

void MakeEmpty(SearchTree &T);
void Insert(ElementType X, SearchTree &T);
bool compare(const SearchTree T, const SearchTree S);



int main() {
	SearchTree T = NULL, S = NULL; /* */
	int N, L;
	int X;/* put in the number*/
	cin >> N; /* the total number of integers in an insertion sequence*/
	while (N != 0) /*repeat the algorithm until N=0 */
	{
		cin >> L; /*the number of sequences to be tested*/
		/*create the initial search tree*/
		for (int i = 0; i < N; i++) {
			cin >> X;
			Insert(X, S);
		}
		for (int t = 0; t < L; t++) {//create the tree to check
			MakeEmpty(T); /*make sure T is NULL before every sequence  is input*/
			for (int i = 0; i < N; i++) /*create binary search tree T generated by sequences to be tested*/
			{
				cin >> X;
				Insert(X, T);
			}
			if (compare(S, T) == true)
				cout << "Yes" << endl;
			else
				cout << "No" << endl;
			/*if the sequences tested can generate the same binary search tree, print"YES"£¬else print"NO"*/
		}
		MakeEmpty(S); /*make sure S is NULL before another initially sequence is input*/
		cin >> N;
	}
}

void MakeEmpty(SearchTree &T)/*make search tree empty*/
{
	if (T != NULL)
	{
		MakeEmpty(T->Left);/*make the left child of search tree empty*/
		MakeEmpty(T->Right);/*make the right child of search tree empty*/
		delete T;/*free the space of the search tree*/
		T = NULL;
	}
}

void Insert(ElementType X, SearchTree &T)
{
	if (T == NULL)
	{
		/*Create and return a one-node tree*/
		T = new TreeNode(X, 0, 0);
	}
	else
	{
		if (X < T->Element)
			Insert(X, T->Left);
		if (X > T->Element)
			Insert(X, T->Right);
		/*else X is in the tree already, we will do nothing*/
	}
}

bool compare(const SearchTree T, const SearchTree S)
/*to determine if the sequences tested can generate the same binary search tree*/
{
	bool isIdentical = true;/*letisIdentical = true denote T and S is same, isIdentical = false denote T and S is different.*/
	if (T != NULL && S != NULL) {
		if (T->Element == S->Element) {
			/* the elements of the nodes have to be same*/
			if (compare(T->Left, S->Left) == false)/* the left child of the nodes have to be same*/
				isIdentical = false;
			if (compare(T->Right, S->Right) == false)  /* the right child of the nodes have to be same*/
				isIdentical = false;
		}
		else isIdentical = false;
	}
	else {
		if ((T == NULL && S != NULL ) || ( T != NULL && S == NULL))
			isIdentical = false;
	}
	return isIdentical;
}
