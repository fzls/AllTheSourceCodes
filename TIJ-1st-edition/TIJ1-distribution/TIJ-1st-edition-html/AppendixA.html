<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:Tjava14.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/04/2000
Translation Time:23:26:24
Translation Platform:Win32
Number of Output files:27
This File:AppendixA.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>A: Using non-Java code</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/TIJ2/index.html">2nd Edition</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/javaCD2.html">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 1st edition</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;1998 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter17.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="AppendixB.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc407441462"></A><A NAME="_Toc408018817"></A><A NAME="Heading583"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
A: Using non-Java code</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>This appendix was
contributed by and used with the permission of Andrea Provaglio
(<I>www.AndreaProvaglio.com</I>).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java language and its standard
API are rich enough to write full-fledged applications. But in some cases you
must call <A NAME="Index3061"></A><A NAME="Index3062"></A>non-Java code; for
example, if you want to access operating-system-specific features,
<A NAME="Index3063"></A>interface with special <A NAME="Index3064"></A>hardware
devices, reuse a pre-existing, non-Java code base, or implement
<A NAME="Index3065"></A>time-critical sections of code. Interfacing with
non-Java code requires dedicated support in the compiler and in the Virtual
Machine, and additional tools to map the Java code to the non-Java code.
(There&#8217;s also a simple approach: in Chapter 15, the section titled
&#8220;a Web application&#8221; contains an example of connecting to non-Java
code using standard input and output.) Currently, different vendors offer
different solutions: Java 1.1 has the
<A NAME="Index3066"></A><A NAME="Index3067"></A>Java Native Interface (JNI),
Netscape has proposed its <A NAME="Index3068"></A>Java Runtime Interface, and
Microsoft offers <A NAME="Index3069"></A>J/Direct,
<A NAME="Index3070"></A><A NAME="Index3071"></A>Raw Native Interface (RNI), and
<A NAME="Index3072"></A><A NAME="Index3073"></A>Java/COM
integration.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This fragmentation among different
vendors implies serious drawbacks for the programmer. If a Java application must
call native methods, the programmer might need to implement different versions
of the native methods depending on the platform the application will run on. The
programmer might actually need different versions of the Java code as well as
different Java virtual machines.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another solution is
<A NAME="Index3074"></A>CORBA (Common Object Request Broker Architecture), an
integration technology developed by the OMG (Object Management Group, a
non-profit consortium of companies). CORBA is not part of any language, but is a
specification for implementing a common communication bus and services that
allow interoperability among objects implemented in different languages. This
communication bus, called an <A NAME="Index3075"></A><A NAME="Index3076"></A>ORB
(Object Request Broker), is a product implemented by third-party vendors, but it
is not part of the Java language specification.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This appendix gives an overview of
JNI, J/Direct, RNI, Java/COM integration, and CORBA. This is not an in-depth
treatment, and in some cases you&#8217;re assumed to have partial knowledge of
the related concepts and techniques. But in the end, you should be able to
compare the different approaches and choose the one that is most appropriate to
the problem you want to solve.</FONT><A NAME="_Toc408018818"></A><BR></P></DIV>
<A NAME="Heading584"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The Java Native Interface</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">JNI is a fairly rich programming
interface that allows you to call native methods from a Java application. It was
added in Java 1.1, maintaining a certain degree of compatibility with its Java
1.0 equivalent, the <A NAME="Index3077"></A><A NAME="Index3078"></A>native
method interface (NMI). NMI has design characteristics that make it unsuitable
for adoption in all virtual machines. For this reason, future versions of the
language might no longer support NMI, and it will not be covered
here.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Currently, JNI is designed to
interface with native methods written only in <A NAME="Index3079"></A>C or C++.
Using JNI, your native methods can:</FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Create, inspect, and
update Java objects (including arrays and
<B>String</B>s)</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Call
Java
methods</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Catch
and throw
exceptions</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Load
classes and obtain class
information</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Perform
runtime type
checking</FONT></UL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, virtually
everything you can do with classes and objects in ordinary Java you can also do
in native methods. </FONT><A NAME="_Toc408018819"></A><BR></P></DIV>
<A NAME="Heading585"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Calling a native method</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">We&#8217;ll start with a simple
example: a Java program that calls a native method, which in turn calls the
Win32 <B>MessageBox(&#160;)</B> API function to display a graphical text box.
This example will also be used later with J/Direct. If your platform is not
Win32, just replace the C header include: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>#include &lt;windows.h&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">with</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>#include &lt;stdio.h&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">and replace the call to
<B>MessageBox(&#160;)</B> with a call to <B>printf(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first step is to write the Java
code declaring a native method and its arguments:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> ShowMsgBox {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String [] args) {
    ShowMsgBox app = <font color=#0000ff>new</font> ShowMsgBox();
    app.ShowMessage(<font color=#004488>"Generated with JNI"</font>);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>native</font> <font color=#0000ff>void</font> ShowMessage(String msg);
  <font color=#0000ff>static</font> {
    System.loadLibrary(<font color=#004488>"MsgImpl"</font>);
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The native method declaration is
followed by a <B>static</B> block that calls <B>System.loadLibrary(&#160;)</B>
(which you could call at any time, but this style is more appropriate).
<B>System.loadLibrary(&#160;)</B> loads a DLL in memory and links to it. The DLL
must be in your system path or in the directory containing the Java class file.
The file name extension is automatically added by the JVM depending on the
platform.</FONT><BR></P></DIV>
<A NAME="Heading586"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The C header file generator: javah</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now compile your Java source file
and run <A NAME="Index3080"></A><B>javah</B> on the resulting <B>.class</B>
file. <B>Javah</B> was present in version 1.0, but since you are using Java 1.1
JNI you must specify the <B>&#8211;jni</B> switch:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>javah &#8211;jni ShowMsgBox</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Javah</B> reads the Java class
file and for each native method declaration it generates a function prototype in
a C or C++ header file. Here&#8217;s the output: the <B>ShowMsgBox.h</B> source
file (edited slightly to fit into the book):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>/* DO NOT EDIT THIS FILE 
   - it is machine generated */</font>
#include &lt;jni.h&gt;
<font color=#009900>/* Header for class ShowMsgBox */</font>

#ifndef _Included_ShowMsgBox
#define _Included_ShowMsgBox
#ifdef __cplusplus
extern <font color=#004488>"C"</font> {
#endif
<font color=#009900>/*
 * Class:     ShowMsgBox
 * Method:    ShowMessage
 * Signature: (Ljava/lang/String;)V
 */</font>
JNIEXPORT <font color=#0000ff>void</font> JNICALL 
Java_ShowMsgBox_ShowMessage
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you can see by the <B>#ifdef
__cplusplus</B> preprocessor directive, this file can be compiled either by a C
or a C++ compiler. The first <B>#include</B> directive includes <B>jni.h</B>, a
header file that, among other things, defines the types that you can see used in
the rest of the file. <A NAME="Index3081"></A><B>JNIEXPORT</B> and
<A NAME="Index3082"></A><B>JNICALL</B> are macros that expand to match
platform-specific directives; <B>JNIEnv</B>, <B>jobject</B> and <B>jstring</B>
are JNI data type definitions.</FONT><BR></P></DIV>
<A NAME="Heading587"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Name mangling and function signatures</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">JNI imposes a naming convention
(called <I>name mangling</I>) on native methods; this is important, since
it&#8217;s part of the mechanism by which the virtual machine links Java calls
to native methods. Basically, all native methods start with the word
&#8220;Java,&#8221; followed by the name of the class in which the Java native
declaration appears, followed by the name of the Java method; the underscore
character is used as a separator. If the Java native method is overloaded, then
the function signature is appended to the name as well; you can see the native
signature in the comments preceding the prototype. For more information about
name mangling and native method signatures, please refer to the JNI
documentation.</FONT><BR></P></DIV>
<A NAME="Heading588"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Implementing your DLL</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point, all you have to do
is write a C or C++ source file that includes the javah-generated header file
and implements the native method, then compile it and generate a dynamic link
library. This part is platform-dependent, and I&#8217;ll assume that you know
how to create a DLL. The code below implements the native method by calling a
Win32 API. It is then compiled and linked into a file called <B>MsgImpl.dll</B>
(for &#8220;Message Implementation&#8221;).</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>#include &lt;windows.h&gt;
#include <font color=#004488>"ShowMsgBox.h"</font>

BOOL APIENTRY DllMain(HANDLE hModule, 
  DWORD dwReason, <font color=#0000ff>void</font>** lpReserved) {
  <font color=#0000ff>return</font> TRUE;
}

JNIEXPORT <font color=#0000ff>void</font> JNICALL 
Java_ShowMsgBox_ShowMessage(JNIEnv * jEnv, 
  jobject <font color=#0000ff>this</font>, jstring jMsg) {
  <font color=#0000ff>const</font> <font color=#0000ff>char</font> * msg;
  msg = (*jEnv)-&gt;GetStringUTFChars(jEnv, jMsg,0);
  MessageBox(HWND_DESKTOP, msg, 
    <font color=#004488>"Thinking in Java: JNI"</font>,
    MB_OK | MB_ICONEXCLAMATION);
  (*jEnv)-&gt;ReleaseStringUTFChars(jEnv, jMsg,msg);
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you have no interest in Win32,
just skip the <B>MessageBox(&#160;)</B> call; the interesting part is the
surrounding code. The arguments that are passed into the native method are the
gateway back into Java. The first, of type <B>JNIEnv</B>,<B> </B>contains all
the hooks that allow you to call back into the JVM. (We&#8217;ll look at this in
the next section.) The second argument has a different meaning depending on the
type of method. For non-<B>static</B> methods like the example above (also
called <I>instance methods</I>), the second argument is the equivalent of the
&#8220;this&#8221; pointer in C++ and similar to <B>this</B> in Java: it&#8217;s
a reference to the object that called the native method. For <B>static</B>
methods, it&#8217;s a reference to the <B>Class</B> object where the method is
implemented.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The remaining arguments represent
the Java objects passed into the native method call. Primitives are also passed
in this way, but they come in by value.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the following sections
we&#8217;ll explain this code by looking at how to access and control the JVM
from inside a native method.</FONT><A NAME="_Toc408018820"></A><BR></P></DIV>
<A NAME="Heading589"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Accessing JNI functions: <BR>The JNIEnv
argument<BR><A NAME="Index3083"></A><A NAME="Index3084"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">JNI functions are those that the
programmer uses to interact with the JVM from inside a native method. As you can
see in the example above, every JNI native method receives a special argument as
its first parameter: the <B>JNIEnv</B> argument, which is a pointer to a special
JNI data structure of type <B>JNIEnv_</B>. One element of the JNI data structure
is a pointer to an array generated by the JVM; each element of this array is a
pointer to a JNI function. The JNI functions can be called from the native
method by dereferencing these pointers (it&#8217;s simpler than it sounds).
Every JVM provides its own implementation of the JNI functions, but their
addresses will always be at predefined offsets.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Through the <B>JNIEnv</B> argument,
the programmer has access to a large set of functions. These functions can be
grouped into the following categories:</FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Obtaining version
information</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Performing
class and object
operations</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Handling
global and local references to Java
objects</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Accessing
instance fields and static
fields</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Calling
instance methods and static
methods</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Performing
string and array
operations</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Generating
and handling Java
exceptions</FONT></UL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The number of
JNI functions is quite large and won&#8217;t be covered here. Instead,
I&#8217;ll show the rationale behind the use of these functions. For more
detailed information, consult your compiler&#8217;s JNI
documentation.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you take a look at the
<B>jni.h</B> header file, you&#8217;ll see that inside the <B>#ifdef
__cplusplus</B> preprocessor conditional, the <B>JNIEnv_</B> structure is
defined as a class when compiled by a C++ compiler. This class contains a number
of inline functions that let you access the JNI functions with an easy and
familiar syntax. For example, the line in the preceding example</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(*jEnv)-&gt;ReleaseStringUTFChars(jEnv, jMsg,msg);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">can be rewritten as follows in
C++:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jEnv-&gt;ReleaseStringUTFChars(jMsg,msg);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that you no
longer need the double dereferencing of the <B>jEnv</B> pointer, and that the
same pointer is no longer passed as the first parameter to the JNI function
call. In the rest of these examples, I&#8217;ll use the C++
style.</FONT><BR></P></DIV>
<A NAME="Heading590"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Accessing Java Strings</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example of accessing a JNI
function, consider the code shown above. Here, the <B>JNIEnv</B> argument
<B>jEnv</B> is used to access a Java <B>String</B>. Java <B>String</B>s are in
Unicode format, so if you receive one and want to pass it to a non-Unicode
function (<B>printf(&#160;)</B>, for example), you must first convert it into
ASCII characters with the JNI function <B>GetStringUTFChars(&#160;)</B>. This
function takes a Java <B>String</B> and converts it to UTF-8 characters. (These
are 8 bits wide to hold ASCII values or 16 bits wide to hold Unicode. If the
content of the original string was composed only of ASCII, the resulting string
will be ASCII as well.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>GetStringUTFChars</B> is the
name of one of the fields in the structure that <B>JNIEnv</B> is indirectly
pointing to, and this field in turn is a pointer to a function. To access the
JNI function, we use the traditional C syntax for calling a function though a
pointer. You use the form above to access all of the JNI
functions.</FONT><A NAME="_Toc408018821"></A><BR></P></DIV>
<A NAME="Heading591"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Passing and using Java objects</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the previous example we passed a
<B>String</B> to the native method. You can also pass Java objects of your own
creation to a native method. Inside your native method, you can access the
fields and methods of the object that was received.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To pass objects, use the ordinary
Java syntax when declaring the native method. In the example below,
<B>MyJavaClass</B> has one <B>public</B> field and one <B>public</B> method. The
class <B>UseObjects </B>declares a native method that takes an object of class
<B>MyJavaClass</B>. To see if the native method manipulates its argument, the
<B>public</B> field of the argument is set, the native method is called, and
then the value of the <B>public</B> field is printed.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> MyJavaClass {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> divByTwo() { aValue /= 2; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> aValue;
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> UseObjects {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String [] args) {
    UseObjects app = <font color=#0000ff>new</font> UseObjects();
    MyJavaClass anObj = <font color=#0000ff>new</font> MyJavaClass();
    anObj.aValue = 2;
    app.changeObject(anObj);
    System.out.println(<font color=#004488>"Java: "</font> + anObj.aValue);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>native</font> <font color=#0000ff>void</font> 
  changeObject(MyJavaClass obj);
  <font color=#0000ff>static</font> {
    System.loadLibrary(<font color=#004488>"UseObjImpl"</font>);
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After compiling the code and
handing the <B>.class </B>file to <B>javah</B>, you can implement the native
method. In the example below, once the field and method ID are obtained, they
are accessed through JNI functions.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>JNIEXPORT <font color=#0000ff>void</font> JNICALL
Java_UseObjects_changeObject(
  JNIEnv * env, jobject jThis, jobject obj) {
  jclass cls;
  jfieldID fid;
  jmethodID mid;
  <font color=#0000ff>int</font> value;
  cls = env-&gt;GetObjectClass(obj);
  fid = env-&gt;GetFieldID(cls,
        <font color=#004488>"aValue"</font>, <font color=#004488>"I"</font>);
  mid = env-&gt;GetMethodID(cls,
        <font color=#004488>"divByTwo"</font>, <font color=#004488>"()V"</font>);
  value = env-&gt;GetIntField(obj, fid);
  printf(<font color=#004488>"Native: %d\n"</font>, value);
  env-&gt;SetIntField(obj, fid, 6);
  env-&gt;CallVoidMethod(obj, mid);
  value = env-&gt;GetIntField(obj, fid);
  printf(<font color=#004488>"Native: %d\n"</font>, value);
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first argument aside, the C++
function receives a <B>jobject</B>, which is the native side of the Java object
reference we pass from the Java code. We simply read <B>aValue</B>, print it
out, change the value, call the object&#8217;s <B>divByTwo(&#160;)</B> method,
and print the value out again. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To access a field or method, you
must first obtain its identifier. Appropriate JNI functions take the class
object, the element name, and the signature. These functions return an
identifier that you use to access the element. This approach might seem
convoluted, but your native method has no knowledge of the internal layout of
the Java object. Instead, it must access fields and methods through indexes
returned by the JVM. This allows different JVMs to implement different internal
object layouts with no impact on your native methods.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you run the Java program,
you&#8217;ll see that the object that&#8217;s passed from the Java side is
manipulated by your native method. But what exactly is passed? A pointer or a
Java reference? And what is the garbage collector doing during native method
calls?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <A NAME="Index3085"></A>garbage
collector continues to operate during native method execution, but it&#8217;s
guaranteed that your objects will not be garbage collected during a native
method call. To ensure this, <I>local references</I> are created before, and
destroyed right after, the native method call. Since their lifetime wraps the
call, you know that the objects will be valid throughout the native method
call.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since these references are created
and subsequently destroyed every time the function is called, you cannot make
local copies in your native methods, in <B>static</B> variables. If you want a
reference that lasts across function invocations, you need a global reference.
Global references are not created by the JVM, but the programmer can make a
global reference out of a local one by calling specific JNI functions. When you
create a global reference, you become responsible for the lifetime of the
referenced object. The global reference (and the object it refers to) will be in
memory until the programmer explicitly frees the reference with the appropriate
JNI function. It&#8217;s similar to <B>malloc(&#160;)</B> and
<B>free(&#160;)</B> in C.</FONT><A NAME="_Toc408018822"></A><BR></P></DIV>
<A NAME="Heading592"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
JNI and Java exceptions</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With <A NAME="Index3086"></A>JNI,
Java exceptions can be thrown, caught, printed, and rethrown just as they are
inside a Java program. But it&#8217;s up to the programmer to call dedicated JNI
functions to deal with exceptions. Here are the JNI functions for exception
handling:</FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia"><B>Throw(&#160;)</B></FONT><BR><FONT FACE="Georgia">Throws
an existing exception object. Used in native methods to rethrow an
exception.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia"><B>ThrowNew(&#160;)</B></FONT><BR><FONT FACE="Georgia">Generates
a new exception object and throws
it.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia"><B>ExceptionOccurred(&#160;)</B></FONT><BR><FONT FACE="Georgia">Determines
if an exception was thrown and not yet
cleared.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia"><B>ExceptionDescribe(&#160;)</B></FONT><BR><FONT FACE="Georgia">Prints
an exception and the stack
trace.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia"><B>ExceptionClear(&#160;)</B></FONT><BR><FONT FACE="Georgia">Clears
a pending
exception.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia"><B>FatalError(&#160;)</B></FONT><BR><FONT FACE="Georgia">Raises
a fatal error. Does not
return.</FONT></UL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Among these, you
can&#8217;t ignore <B>ExceptionOccurred(&#160;)</B> and
<B>ExceptionClear(&#160;)</B>. Most JNI functions can generate exceptions, and
there is no language feature that you can use in place of a Java try block, so
you must call <B>ExceptionOccurred(&#160;) </B>after each JNI function call to
see if an exception was thrown. If you detect an exception, you may choose to
handle it (and possibly rethrow it). You must make certain, however, that the
exception is eventually cleared. This can be done in your function using
<B>ExceptionClear(&#160;)</B> or in some other function if the exception is
rethrown, but it must be done.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You must ensure that the exception
is cleared, because otherwise the results will be unpredictable if you call a
JNI function while an exception is pending. There are few JNI functions that are
safe to call during an exception; among these, of course, are all the exception
handling functions.</FONT><A NAME="_Toc408018823"></A><BR></P></DIV>
<A NAME="Heading593"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
JNI and threading</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since Java is a multithreaded
language, several threads can call a native method concurrently. (The native
method might be suspended in the middle of its operation when a second thread
calls it.) It&#8217;s entirely up to the programmer to guarantee that the native
call is thread-safe, i.e. it does not modify shared data in an unmonitored way.
Basically, you have two options: declare the native method as
<B>synchronized</B> or implement some other strategy within the native method to
ensure correct, concurrent data manipulation.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Also, you should never pass the
<B>JNIEnv</B> pointer across threads, since the internal structure it points to
is allocated on a per-thread basis and contains information that makes sense
only in that particular thread.</FONT><A NAME="_Toc408018824"></A><BR></P></DIV>
<A NAME="Heading594"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using a pre-existing code base</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The easiest way to implement JNI
native methods is to start writing native method prototypes in a Java class,
compile that class, and run the <B>.class</B> file through <B>javah</B>. But
what if you have a large, pre-existing code base that you want to call from
Java? Renaming all the functions in your DLLs to match the JNI name mangling
convention is not a viable solution. The best approach is to write a wrapper DLL
&#8220;outside&#8221; your original code base. The Java code calls functions in
this new DLL, which in turn calls your original DLL functions. This solution is
not just a work-around; in most cases you must do this anyway because you must
call JNI functions on the object references before you can use
them.</FONT><A NAME="_Toc408018825"></A><BR></P></DIV>
<A NAME="Heading595"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The Microsoft way</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At the time of this writing,
Microsoft does not support JNI, but provides proprietary support to call
non-Java code. This support is built into the compiler, the Microsoft JVM, and
external tools. The features described in this section will work only if your
program was compiled using the Microsoft Java compiler and run on the Microsoft
Java Virtual Machine. If you plan to distribute your application on the
Internet, or if your Intranet is built on different platforms, this can be a
serious issue.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Microsoft interface to Win32
code provides three ways to connect to Win32: </FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia"><B>	J/Direct</B>: A way to easily call Win32 DLL
functions, with some limitations.</FONT><LI><FONT FACE="Georgia"><B>	Raw
Native Interface (RNI)</B>: You can call Win32 DLL functions, but you must then
handle garbage collection.</FONT><LI><FONT FACE="Georgia"><B>	Java/COM
integration</B>: You can expose or call COM services directly from
Java.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I&#8217;ll cover
all three techniques in the following sections.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At the time of writing, these
features were tested on the Microsoft SDK for Java 2.0 beta 2, which was
downloaded (with a painful process they call &#8220;Active Setup&#8221;) from
the Microsoft Web site. The Java SDK is a set of command-line tools, but the
compilation engine can be easily plugged into the Developer Studio environment,
allowing you to use Visual J++ 1.1 to compile Java 1.1
code.</FONT><A NAME="_Toc408018826"></A><BR></P></DIV>
<A NAME="Heading596"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
J/Direct</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">J/Direct is the simplest way to
call functions in a Win32 DLL. It was designed primarily to interface with the
Win32 API, but you can use it to call any other APIs. The ease of use of this
feature is counterbalanced by some limitations and reduced performance (compared
to RNI). But J/Direct has distinct advantages. First, there is no need to write
additional non-Java code, except the code in the DLL you want to call. In other
words, you do not need a wrapper or proxy/stub DLL. Second, function arguments
are automatically converted to and from standard data types. (If you must pass
user-defined data types, J/Direct might not be the way to go.) Third, it&#8217;s
simple and straightforward, as the example below shows. In just a few lines,
this example calls the Win32 API function <B>MessageBox(&#160;)</B>, which pops
up a little modal window with a title, a message, an optional icon, and a few
buttons.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>class</font> ShowMsgBox {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) 
  <font color=#0000ff>throws</font> UnsatisfiedLinkError   {
    MessageBox(0,
      <font color=#004488>"Created by the MessageBox() Win32 func"</font>,
      <font color=#004488>"Thinking in Java"</font>, 0);
  }
  <font color=#009900>/** @dll.import("USER32") */</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>native</font> <font color=#0000ff>int</font> 
  MessageBox(<font color=#0000ff>int</font> hwndOwner, String text,
    String title, <font color=#0000ff>int</font> fuStyle);
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Amazingly, this code is all you
need to call a function in a Win32 DLL using J/Direct. The key is the
<B>@dll.import</B> directive before the <B>MessageBox(&#160;)</B> declaration,
at the bottom of the example code. It looks like a comment, but it&#8217;s not:
it tells the compiler that the function below the directive is implemented in
the USER32 DLL, and should be called accordingly. All you must do is supply a
prototype that matches the function implementation in the DLL and call the
function. But instead of typing in the Java version of each Win32 API function
that you need, a Microsoft Java package does this for you (I&#8217;ll describe
this shortly). For this example to work, the function must be exported <I>by
name</I> by the DLL, but the <B>@dll.import </B>directive can be used to link
<I>by ordinal</I> as well, i.e., you can specify the entry position of the
function in the DLL. I&#8217;ll cover the features of the <B>@dll.import
</B>directive later.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An important issue in the process
of linking with non-Java code is the automatic marshaling of the function
parameters. As you can see, the Java declaration of <B>MessageBox(&#160;)</B>
takes two String arguments, but the original C implementation takes two
<B>char</B> pointers. The compiler automatically converts the standard data
types for you, following the rules described in a later
section.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, you might have noticed the
<B>UnsatisfiedLinkError</B> exception in the declaration of <B>main(&#160;)</B>.
This exception occurs when the linker is unable to resolve the symbol for the
non-Java function at run-time. This happens for a number of reasons: the
<B>.dll</B> file was not found, it is not a valid DLL, or J/Direct is not
supported by your virtual machine. For the DLL to be found, it must be in the
Windows or Windows\System directory, in one of the directories listed in your
PATH environment variable, or in the directory where the <B>.class </B>file is
located. J/Direct is supported in the Microsoft Java compiler version 1.02.4213
or above, and in the Microsoft JVM version 4.79.2164 or above. To get the
compiler version number, run JVC from the command line with no parameters. To
get the JVM version number, locate the icon for <B>msjava.dll</B>, and using the
context menu look at its
properties.</FONT><A NAME="_Toc408018827"></A><BR></P></DIV>
<A NAME="Heading597"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The @dll.import directive<BR><A NAME="Index3087"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>@dll.import</B> directive,
your one and only way to J/Direct, is quite flexible. It has a number of
modifiers that you can use to customize the way you link to the non-Java code.
It can also be applied to some methods within a class or to a whole class,
meaning that all of the methods you declare in that class are implemented in the
same DLL. Let&#8217;s look at these features.</FONT><BR></P></DIV>
<A NAME="Heading598"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Aliasing and linking by ordinal</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For the <B>@dll.import</B>
directive to work as shown above, the function in the DLL must be exported by
name. However, you might want to use a different name than the original one in
the DLL (aliasing), or the function might be exported by number (i.e. by
ordinal) instead of by name. The example below declares
<B>FinestraDiMessaggio(&#160;)</B> (the Italian equivalent of
&#8220;MessageBox&#8221;) as an alias to <B>MessageBox(&#160;)</B>. As you can
see, the syntax is pretty simple.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>class</font> Aliasing {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) 
  <font color=#0000ff>throws</font> UnsatisfiedLinkError   {
    FinestraDiMessaggio(0,
      <font color=#004488>"Created by the MessageBox() Win32 func"</font>,
      <font color=#004488>"Thinking in Java"</font>, 0);
  }
  <font color=#009900>/** @dll.import("USER32", 
  entrypoint="MessageBox") */</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>native</font> <font color=#0000ff>int</font> 
  FinestraDiMessaggio(<font color=#0000ff>int</font> hwndOwner, String text,
    String title, <font color=#0000ff>int</font> fuStyle);
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next example shows how to link
to a function in a DLL that is not exported by name, but by its position inside
of the DLL. The example assumes that there is a DLL named MYMATH somewhere along
your path, and that this DLL contains at position 3 a function that takes two
integers and gives you back the sum.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>class</font> ByOrdinal {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) 
  <font color=#0000ff>throws</font> UnsatisfiedLinkError {
    <font color=#0000ff>int</font> j=3, k=9;
    System.out.println(<font color=#004488>"Result of DLL function:"</font>
      + Add(j,k));
  }
  <font color=#009900>/** @dll.import("MYMATH", entrypoint = "#3") */</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>native</font> <font color=#0000ff>int</font> Add(<font color=#0000ff>int</font> op1,<font color=#0000ff>int</font> op2);
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see the only difference is
the form of the <B>entrypoint</B> argument.</FONT><BR></P></DIV>
<A NAME="Heading599"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Applying @dll.import to the entire class</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index3088"></A><B>@dll.import</B> directive can be applied to an entire
class, meaning that all of the methods in that class are implemented in the same
DLL and with the same linkage attributes. The directive is not inherited by
subclasses; for this reason, and since functions in a DLL are by nature
<B>static</B> functions, a better design approach is to encapsulate the API
functions in a separate class, as shown here:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>/** @dll.import("USER32") */</font>
<font color=#0000ff>class</font> MyUser32Access {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>native</font> <font color=#0000ff>int</font> 
  MessageBox(<font color=#0000ff>int</font> hwndOwner, String text,
    String title, <font color=#0000ff>int</font> fuStyle);
  <font color=#0000ff>public</font> <font color=#0000ff>native</font> <font color=#0000ff>static</font> <font color=#0000ff>boolean</font> 
  MessageBeep(<font color=#0000ff>int</font> uType);
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WholeClass {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) 
  <font color=#0000ff>throws</font> UnsatisfiedLinkError {
    MyUser32Access.MessageBeep(4);
    MyUser32Access.MessageBox(0,
      <font color=#004488>"Created by the MessageBox() Win32 func"</font>,
      <font color=#004488>"Thinking in Java"</font>, 0);
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since the
<B>MessageBeep(&#160;)</B> and <B>MessageBox(&#160;)</B> functions are now
declared as static in a different class, you must call them specifying their
scope. You might think that you must use the approach above to map <I>all </I>of
the <A NAME="Index3089"></A>Win32 API (functions, constants, and data types) to
Java classes. Fortunately, you don&#8217;t have
to.</FONT><A NAME="_Toc408018828"></A><BR></P></DIV>
<A NAME="Heading600"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The com.ms.win32 package</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Win32 API is fairly big &#8211;
on the order of a thousand functions, constants, and data types. Of course, you
do not want to write the Java equivalent of every single Win32 API function.
Microsoft took care of this, distributing a Java package that maps the Win32 API
to Java classes using J/Direct. This package, named
<A NAME="Index3090"></A><B>com.ms.win32</B>, is installed in your classpath
during the installation of the Java SDK 2.0 if you select it in the setup
options. The package is made up of large number of Java classes that reproduce
the constants, data structures, and functions of the Win32 API. The three
richest classes are <B>User32.class</B>, <B>Kernel32.class</B>, and
<B>Gdi32.class</B>. These contain the core of the Win32 API. To use them, just
import them in your Java code. The <B>ShowMsgBox</B> example above can be
rewritten using <B>com.ms.win32</B> as follows (I also took care of the
<B>UnsatisfiedLinkError</B> in a more civilized way):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> com.ms.win32.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> UseWin32Package {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    <font color=#0000ff>try</font> {
      User32.MessageBeep(
        winm.MB_ICONEXCLAMATION);
      User32.MessageBox(0,
        <font color=#004488>"Created by the MessageBox() Win32 func"</font>,
        <font color=#004488>"Thinking in Java"</font>,
        winm.MB_OKCANCEL |
        winm.MB_ICONEXCLAMATION);
    } <font color=#0000ff>catch</font>(UnsatisfiedLinkError e) {
      System.out.println(<font color=#004488>"Can&#8217;t link Win32 API"</font>);
      System.out.println(e);
    }
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The package is imported in the
first line. The <B>MessageBeep(&#160;)</B> and <B>MessageBox(&#160;)</B>
functions can now be called with no other declarations. In
<B>MessageBeep(&#160;) </B>you can see that importing the package has also
declared the Win32 constants. These constants are defined in a number of Java
interfaces, all named winx (x is the first letter of the constant you want to
use). </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At the time of this writing, the
classes in the <B>com.ms.win32</B> package are still under development, but
usable nonetheless.</FONT><A NAME="_Toc408018829"></A><BR></P></DIV>
<A NAME="Heading601"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Marshaling<BR><A NAME="Index3091"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Marshaling means converting a
function argument from its native binary representation into some
language-independent format, and then converting this generic representation
into a binary format that is appropriate to the called function. In the example
above, we called the <B>MessageBox(&#160;)</B> function and passed it a couple
of <B>String</B>s. <B>MessageBox(&#160;)</B> is a C function, and the binary
layout of Java <B>String</B>s is not the same as C strings, but the arguments
are nonetheless correctly passed. That&#8217;s because J/Direct takes care of
converting a Java <B>String</B> into a C string before calling the C code. This
happens with all standard Java types. Below is a table of the implicit
conversions for simple data types:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Java</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>C</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>byte</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BYTE or CHAR</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>short</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">SHORT or WORD</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>int</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">INT, UINT, LONG, ULONG, or
DWORD</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>char</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">TCHAR</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>long</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">__int64</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>float</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Float</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>double</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Double</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>boolean</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BOOL</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>String</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">LPCTSTR (Allowed as return value
only in ole mode)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>byte[]</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BYTE *</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>short[]</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">WORD *</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>char[]</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">TCHAR *</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>int[]</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">DWORD *</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The list continues, but this gives
you the idea. In most cases, you do not need to worry about converting to and
from simple data types, but things are different when you must pass arguments of
user-defined data types. For example, you might need to pass the address of a
structured, user-defined data type, or you might need to pass a pointer to a raw
memory area. For these situations, there are special compiler directives to mark
a Java class so that it can be passed as a pointer to a structure (the
<A NAME="Index3092"></A><B>@dll.struct</B> directive). For details on the use of
these keywords, please refer to the product
documentation.</FONT><A NAME="_Toc408018830"></A><BR></P></DIV>
<A NAME="Heading602"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Writing callback functions</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some Win32 API functions require a
function pointer as one of the parameters. The Windows API function may then
call the argument function, possibly at a later time when some event occurs.
This technique is called a <A NAME="Index3093"></A><I>callback function</I>.
Examples include window procedures and the callbacks you set up during a print
operation (you give the print spooler the address of your callback function so
it can update the status and possibly interrupt printing).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another example is the
<B>EnumWindows(&#160;)</B> API function that enumerates all top-level windows
currently present in the system. <B>EnumWindows(&#160;)</B> takes a function
pointer, then traverses a list maintained internally by Windows. For every
window in the list, it calls the callback function, passing the window handle as
an argument to the callback.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To do the same thing in Java, you
must use the <B>Callback </B>class in the <B>com.ms.dll</B> package. You inherit
from <B>Callback </B>and override <B>callback(&#160;)</B>. This method will
accept only <B>int</B> parameters and will return <B>int</B> or <B>void</B>. The
method signature and implementation depends on the Windows API function
that&#8217;s using this callback.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now all we need to do is create an
instance of this <B>Callback</B>-derived class and pass it as the function
pointer argument to the API function. J/Direct will take care of the
rest.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The example below calls the
<B>EnumWindows(&#160;)</B> Win32 API; the <B>callback(&#160;)</B> method in the
EnumWindowsProc class gets the window handle for each top-level window, obtains
the caption text, and prints it to the console window.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> com.ms.dll.*;
<font color=#0000ff>import</font> com.ms.win32.*;

<font color=#0000ff>class</font> EnumWindowsProc <font color=#0000ff>extends</font> Callback {
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> callback(<font color=#0000ff>int</font> hwnd, <font color=#0000ff>int</font> lparam) {
    StringBuffer text = <font color=#0000ff>new</font> StringBuffer(50);
    User32.GetWindowText(
      hwnd, text, text.capacity()+1);
    <font color=#0000ff>if</font>(text.length() != 0)
      System.out.println(text);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;  <font color=#009900>// to continue enumeration.</font>
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ShowCallback {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[])
  <font color=#0000ff>throws</font> InterruptedException {
    <font color=#0000ff>boolean</font> ok = User32.EnumWindows(
      <font color=#0000ff>new</font> EnumWindowsProc(), 0);
    <font color=#0000ff>if</font>(!ok)
      System.err.println(<font color=#004488>"EnumWindows failed."</font>);
    Thread.currentThread().sleep(3000);
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The call to <B>sleep(&#160;)</B>
allows the windows procedure to complete before <B>main(&#160;)</B>
exits.</FONT><A NAME="_Toc408018831"></A><BR></P></DIV>
<A NAME="Heading603"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Other J/Direct features</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are two more J/Direct
features you can get using modifiers in the <B>@dll.import</B> directive. The
first is simplified access to OLE functions, and the second is the selection of
the ANSI versus Unicode version of API functions. Here is a short description of
the two.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By convention, all OLE functions
return a value of type HRESULT, which is a structured integer value defined by
COM. If you program at the COM level and you want something different returned
from an OLE function, you must pass it a pointer to a memory area that the
function will fill with data. But in Java we don&#8217;t have pointers; also,
this style is not exactly elegant. With J/Direct, you can easily call OLE
functions using the <B>ole</B> modifier in the <B>@dll.import</B> directive. A
native method marked as an <B>ole</B> function is automatically translated from
a Java-style method signature, which is where you decide the return type, into a
COM-style function.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second feature selects between
ANSI and Unicode string handling. Most Win32 API functions that handle strings
come in two versions. For example, if you look at the symbols exported by the
USER32 DLL, you will not find a <B>MessageBox(&#160;)</B> function, but instead
<B>MessageBoxA(&#160;)</B> and <B>MessageBoxW(&#160;)</B> functions, which are
the ANSI and Unicode version, respectively. If you do not specify which version
you want to call in the <B>@dll.import </B>directive, the JVM will try to figure
it out. But this operation takes some time during program execution time that
you can save with the <B>ansi</B>, <B>unicode,</B> or <B>auto</B>
modifiers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For a more detailed discussion of
these features, consult the Microsoft
documentation.</FONT><A NAME="_Toc408018832"></A><BR></P></DIV>
<A NAME="Heading604"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Raw Native Interface (RNI)</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Compared to J/Direct, RNI is a
fairly complex interface to non-Java code, but it&#8217;s much more powerful.
RNI is closer to the JVM than J/Direct, and this lets you write much more
efficient code, manipulate Java objects in your native methods, and in general
gives you a much higher degree of integration with the JVM internal
operations.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">RNI is conceptually similar to
Sun&#8217;s JNI. Because of this, and because the product is not yet completed,
I&#8217;ll just point out the major differences. For further information, please
refer to Microsoft&#8217;s documentation.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are several notable
differences between JNI and RNI. Below is the C header file generated by
<B>msjavah</B>, the Microsoft equivalent of Sun&#8217;s <B>javah</B>, applied to
the <B>ShowMsgBox</B> Java class file used previously for the JNI
example.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>/*  DO NOT EDIT - 
automatically generated by msjavah  */</font>
#include &lt;<font color=#0000ff>native</font>.h&gt;
#pragma warning(disable:4510)
#pragma warning(disable:4512)
#pragma warning(disable:4610)

struct Classjava_lang_String;
#define Hjava_lang_String Classjava_lang_String

<font color=#009900>/*  Header for class ShowMsgBox  */</font>

#ifndef _Included_ShowMsgBox
#define _Included_ShowMsgBox

#define HShowMsgBox ClassShowMsgBox
typedef struct ClassShowMsgBox {
#include &lt;pshpack4.h&gt;
  <font color=#0000ff>long</font> MSReserved;
#include &lt;poppack.h&gt;
} ClassShowMsgBox;

#ifdef __cplusplus
extern <font color=#004488>"C"</font> {
#endif
__declspec(dllexport) <font color=#0000ff>void</font> __cdecl 
ShowMsgBox_ShowMessage (struct HShowMsgBox *, 
  struct Hjava_lang_String *);
#ifdef __cplusplus
}
#endif

#endif  <font color=#009900>/* _Included_ShowMsgBox */</font>

#pragma warning(<font color=#0000ff>default</font>:4510)
#pragma warning(<font color=#0000ff>default</font>:4512)
#pragma warning(<font color=#0000ff>default</font>:4610)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Apart from being less readable,
there are more technical issues disguised in the code, which we&#8217;ll
examine.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In RNI, the native method
programmer knows the binary layout of the objects. This allows you to directly
access the information you want; you don&#8217;t need to get a field or method
identifier as in JNI. But since not all virtual machines necessarily use the
same binary layout for their objects, the native method above is guaranteed to
run only under the Microsoft JVM.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In JNI, the <B>JNIEnv</B> argument
gives access to a large number of functions to interact with the JVM. In RNI,
the functions for controlling JVM operations are directly available. Some of
them, like the one for handling exceptions, are similar to their JNI
counterparts, but most of the RNI functions have different names and purposes
from those in JNI.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the most remarkable
differences between JNI and RNI is the garbage collection model. In JNI, the GC
basically follows the same rules during native method execution that it follows
for the Java code execution. In RNI, the programmer is responsible for starting
and stopping the Garbage Collector during native method activity. By default,
the GC is disabled upon entering the native method; doing so, the programmer can
assume that the objects being used will not be garbage collected during that
time. But if the native method, let&#8217;s say, is going to take a long time,
the programmer is free to enable the GC, calling the <B>GCEnable(&#160;)</B> RNI
function.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is also something similar to
the global handles features &#8211; something the programmer can use to be sure
that specific objects will not be garbage collected when the CG is enabled. The
concept is similar but the name is different: in RNI these guys are called
<B>GCFrame</B>s.</FONT><A NAME="_Toc408018833"></A><BR></P></DIV>
<A NAME="Heading605"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
RNI Summary</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fact that RNI is tightly
integrated with the Microsoft JVM is both its strength and its weakness. RNI is
more complex than JNI, but it also gives you a high degree of control of the
internal activities of the JVM, including garbage collection. Also, it is
clearly designed for speed, adopting compromises and techniques that C
programmers are familiar with. But it&#8217;s not suitable for JVMs other than
Microsoft&#8217;s.</FONT><A NAME="_Toc408018834"></A><BR></P></DIV>
<A NAME="Heading606"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Java/COM integration</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">COM (formerly known as OLE) is the
Microsoft Component Object Model, the foundation of all ActiveX technologies.
These include ActiveX Controls, Automation, and ActiveX Documents. But COM is
much more; it&#8217;s a specification (and a partial implementation) for
developing component objects that can interoperate using dedicated features of
the operating system. In practice, all of the new software developed for Win32
systems has some relationship with COM &#8211; the operating system exposes some
of its features via COM objects. Third-party components can be COM, and you can
create and register your own COM components. In one way or another, if you want
to write Win32 code, you&#8217;ll have to deal with COM. Here, I&#8217;ll just
recap the fundamentals of COM programming, and I&#8217;ll assume that you are
familiar with the concept of a COM server (any COM object that can expose
services to COM clients) and a COM client (a COM object that uses the services
provided by a COM server). This section kept things simple; the tools are
actually much more powerful, and you can use them in a more sophisticated way.
But this requires a deep knowledge of COM, which is beyond the scope of this
appendix. If you&#8217;re interested in this powerful but platform-dependent
feature, you should investigate COM and the Microsoft documentation on Java/COM
integration. For more information, Dale Rogerson&#8217;s &#8220;Inside
COM&#8221; (Microsoft Press, 1997) is an excellent book.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since COM is the architectural
heart of all the new Win32 applications, being able to use, or to expose, COM
services from Java code can be important. The Java/COM integration is no doubt
one of the most interesting features of the Microsoft Java compiler and virtual
machine. Java and COM are so similar in their models that the integration is
conceptually straightforward and technically seamless &#8211; there&#8217;s
almost no special code to write in order to access COM. Most the details are
handled by the compiler and/or by the virtual machine. The effect is that the
COM objects are seen as ordinary Java objects by the Java programmer, and COM
clients can use COM servers implemented in Java just like any other COM server.
Again, I use the generic term COM, but by extension this means that you can
implement an ActiveX Automation server in Java, or you can use an ActiveX
Control in your Java programs.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most notable similarities
between Java and COM revolve around the relationship between COM interfaces and
the Java <B>interface </B>keyword. This is a near-perfect match
because:</FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">A COM object exposes
interfaces (and only
interfaces).</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">A
COM interface has no implementation; the COM object exposing an interface is
responsible for its implementation.
</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">A COM
interface is a description of a group of functions semantically related; no data
is exposed.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">A
COM class groups together COM interfaces. A Java class can implement an
arbitrary number of Java
interfaces</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">COM
has a reference object model; the programmer never &#8220;has&#8221; an object,
just references to one or more of its interfaces. Java has a reference object
model as well &#8211; a reference to an object can be cast to a reference to one
of its
interfaces.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">The
lifetime in memory of a COM object is determined by the number of clients using
the object; when this count goes to zero, the object deletes itself from memory.
In Java, the lifetime of an object is also determined by the number of clients.
When there are no more references to that object, the object is a candidate to
be released by the garbage
collector.</FONT></UL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This tight
mapping between Java and COM not only allows the Java programmer to easily
access COM features, but it also makes Java an interesting language for writing
COM code. COM is language-independent, but the de facto languages for COM
development are C++ and Visual Basic. Compared to Java, C++ is much more
powerful for COM development and generates much more efficient code, but
it&#8217;s hard to use. Visual Basic is much easier than Java, but it&#8217;s
too far from the underlying operating system, and its object model does not map
very well to COM. Java is an excellent compromise between the
two.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Let&#8217;s take a look at some of
the keys points of COM development that you need to know to write Java/COM
clients and servers.</FONT><A NAME="_Toc408018835"></A><BR></P></DIV>
<A NAME="Heading607"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
COM Fundamentals <BR><A NAME="Index3094"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">COM is a binary specification for
implementing interoperable objects. For example, COM describes the binary layout
an object should have to be able to call services in another COM object. Since
it&#8217;s a description of a binary layout, COM objects can be implemented in
any language that&#8217;s able to produce such a layout. Usually the programmer
is freed from these low level details, since the compiler takes care of
generating the correct layout. For example, if you program in C++, most
compilers generate a virtual function table that is COM-compliant. With
languages that do not produce executable code, such as VB and Java, the runtime
takes care of hooking into COM.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The COM Library also supplies a few
basic functions, such as the ones for creating an object or locating a COM class
registered in your system.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The main goals of a component
object model are:</FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Let objects call
services into other
objects.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Allow
new types of objects, or upgrades to existing ones, to be seamlessly plugged
into the
environment.</FONT></UL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first
point is exactly what object-oriented programming is about: you have a client
object that makes requests to a server object. In this case, the terms
&#8220;client&#8221; and &#8220;server&#8221; are used in a generic way, and not
to refer to some particular hardware configuration. With any object-oriented
language, the first goal is easy to achieve if your application is a monolithic
piece of code that implements both the server object code and the client object
code. If you make changes to the way client and the server objects interface
with each other, you simply compile and link again. When you restart your
application, it uses a new version of the components.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The situation is completely
different when your application is made up of component objects that are not
under your control &#8211; you don&#8217;t control their source code and they
can evolve separately from your application. This is exactly the case, for
example, when you use a third-party ActiveX Control in your application. The
control is installed in your system, and your application is able, at runtime,
to locate the server code, activate the object, link to it, and use it. Later,
you can install a newer version of the control, and your application should
still be able to run; in the worst case, it should gracefully report an error
condition, such as &#8220;Control not found,&#8221; without hanging
up.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In these scenarios, your components
are implemented in separate executable code files: DLLs or EXEs. If the server
object is implemented in a separate executable code file, you need a standard,
operating system supplied method to activate these objects. Of course, in your
code you do not want to use the physical name and location of the DLL or EXE,
because these might change; you want some identifier maintained by the operating
system. Also, your application needs a description of the services exposed by
the server. This is exactly what I&#8217;ll cover in the next two
sections.</FONT><BR></P></DIV>
<A NAME="Heading608"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
GUIDs and the Registry</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">COM uses structured integer
numbers, 128 bits long, to unequivocally identify COM entities registered in the
system. These numbers, called <A NAME="Index3095"></A>GUIDs (Globally Unique
IDentifiers) can be generated by specific utilities, and are guaranteed to be
unique &#8220;in space and in time,&#8221; to quote Kraig Brockschmidt. In
space, because the number is generator reads the id of your network card, and in
time because the system date and time are used as well. A GUID can be used to
identify a COM class (in which case it&#8217;s called a CLSID) or a COM
interface (IID). The names are different but the concept and the binary
structure are the same. GUIDs are also used in other situations that I will not
cover here.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">GUIDs, along with their associated
information, are stored in the
<A NAME="Index3096"></A><A NAME="Index3097"></A>Windows Registry, or
Registration Database. It&#8217;s a hierarchical database, built into the
operating system, which holds a great amount of information about the hardware
and software configuration of your system. For COM, the Registry keeps track of
the components installed in your system, such as their CLSIDs, the name and
location of the executable file that implement them, and a lot of other details.
One of these details is the ProgID of the component; a ProgID is conceptually
similar to a GUID in the sense that it identifies a COM component. The
difference is that a GUID is a binary, algorithmically-generated value, whereas
a <A NAME="Index3098"></A>ProgID is a programmer-defined string value. A ProgID
is associated with a <A NAME="Index3099"></A>CLSID.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A COM component is said to be
registered in the system when at least its CLSID and its executable file
location are present in the Registry (the ProgID is usually present as well).
Registering and using COM components is exactly what we&#8217;ll do in the
following examples.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the effects of the Registry
is as a decoupling layer between the client and server objects. The client
activates the server using some information that is stored in the Registry; one
piece of information is the physical location of the server executables. If the
location changes, the information in the Registry is updated accordingly, but
this is transparent to the client, which just uses ProgIDs or CLSIDs. In other
words, the Registry allows for location transparency of the server code. With
the introduction of DCOM (Distributed COM), a server that was running on a local
machine can even be moved to a remote machine on the network, without the client
even noticing it (well, almost...).</FONT><BR></P></DIV>
<A NAME="Heading609"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Type Libraries</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because of COM&#8217;s dynamic
linking and the independent evolution of client and server code, the client
always needs to dynamically detect the services that are exposed by the server.
These services are described in a binary, language-independent way (as
interfaces and method signatures) in the <A NAME="Index3100"></A><I>type
library</I>. This can be a separate file (usually with the .TLB extension), or a
Win32 resource linked into the executable. At runtime, the client uses the
information in the type library to call functions in the
server.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can generate a type library by
writing a Microsoft Interface Definition Language (MIDL) source file and
compiling it with the MIDL compiler to generate a .TLB file. MIDL is a language
that describes COM classes, interfaces, and methods. It resembles the OMG/CORBA
IDL in name, syntax, and purpose. The Java programmer has no need to use MIDL,
though. A different Microsoft tool, described later, reads a Java class file and
generates a type library.</FONT><BR></P></DIV>
<A NAME="Heading610"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Function return codes in COM: HRESULT</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">COM functions exposed by a server
return a value of the predefined type HRESULT. An
<A NAME="Index3101"></A>HRESULT is an integer containing three fields. This
allows for multiple failure and success codes, along with additional
information. Because a COM function returns an HRESULT, you cannot use the
return value to hand back ordinary data from the function call. If you must
return data, you pass a pointer to a memory area that the function will fill.
This is known as an <I>out parameter</I>. You don&#8217;t need to worry about
this as a Java/COM programmer since the virtual machine takes care of it for
you. This is described in the following
sections.</FONT><A NAME="_Toc408018836"></A><BR></P></DIV>
<A NAME="Heading611"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
MS Java/COM Integration</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Microsoft Java compiler,
Virtual Machine, and tools make life a lot easier for the Java/COM programmer
than it is for the C++/COM programmer. The compiler has special directives and
packages for treating Java classes as COM classes, but in most cases,
you&#8217;ll just rely on the Microsoft JVM support for COM, and on a couple of
external tools.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Microsoft Java Virtual Machine
acts as a bridge between COM and Java objects. If you create a Java object as a
COM server, your object will still be running inside the JVM. The Microsoft JVM
is implemented as a DLL, which exposes COM interfaces to the operating system.
Internally, the JVM maps function calls to these COM interfaces to method calls
in your Java objects. Of course, the JVM must know which Java class file
corresponds to the server executable; it can discover this information because
you previously registered the class file in the Windows Registry using
<B>Javareg</B>, a utility in the Microsoft Java SDK. <B>Javareg</B> reads a Java
class file, generates a corresponding type library and a GUID, and registers the
class in the system. <A NAME="Index3102"></A><B>Javareg</B> can be used to
register remote servers as well, for example, servers that run on a different
physical machine.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to write a Java/COM
client, you must go through a different process. A Java/COM client is Java code
that wants to activate and use one of the COM servers registered on your system.
Again, the virtual machine interfaces with the COM server and exposes its
services as methods in a Java class. Another Microsoft tool,
<A NAME="Index3103"></A><B>jactivex</B>, reads a type library and generates Java
source files that contain special compiler directives. The generated source
files are part of a package named after the type library you specified. The next
step is to import that package in your COM client Java source
files.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Let&#8217;s look at a couple of
examples.</FONT><A NAME="_Toc408018837"></A><BR></P></DIV>
<A NAME="Heading612"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Developing COM servers in Java</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This section shows the process you
will apply to the development of ActiveX Controls, Automation Servers, or any
other COM-compliant server. The following example implements a simple Automation
server that adds integer numbers. You set the value of the <B>addend</B> with
the <B>setAddend(&#160;)</B> method, and each time you call the
<B>sum(&#160;)</B> method the <B>addend</B> is added to the current
<B>result</B>. You retrieve the <B>result</B> with <B>getResult(&#160;)</B> and
reset the values with <B>clear(&#160;)</B>. The Java class that implements this
behavior is straightforward:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>class</font> Adder {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> addend;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> result;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setAddend(<font color=#0000ff>int</font> a) { addend = a; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getAddend() { <font color=#0000ff>return</font> addend; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getResult() { <font color=#0000ff>return</font> result; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> sum() { result += addend;  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> clear() {
    result = 0;
    addend = 0;
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To use this Java class as a COM
object, the <B>Javareg</B> tool is applied to the compiled <B>Adder.class</B>
file. This tool has a number of options; in this case we specify the Java class
file name (&#8220;Adder&#8221;), the ProgID we want to put in the Registry for
this server (&#8220;JavaAdder.Adder.1&#8221;), and the name we want for the type
library that will be generated (&#8221;JavaAdder.tlb&#8221;). Since no CLSID is
given, <B>Javareg</B> will generate one; if we call <B>Javareg</B> again on the
same server, the existing CLSID will be used.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>javareg /register
/<font color=#0000ff>class</font>:Adder /progid:JavaAdder.Adder.1
/typelib:JavaAdder.tlb</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Javareg</B> also registers the
new server in the Windows Registry. At this point, you must remember to copy
your <B>Adder.class</B> file into the Windows\Java\trustlib directory. For
security reasons, related mostly to the use of COM services by applets, your COM
server will be activated only if it is installed in the trustlib
directory.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You now have a new Automation
server installed on your system. To test it, you need an Automation controller,
and &#8220;the&#8221; Automation Controller is <A NAME="Index3104"></A>Visual
Basic (VB). Below, you can see a few lines of VB code. On the VB form, I put a
text box to input the value of the addend, a label to show the result, and two
push buttons to invoke the <B>sum(&#160;)</B> and <B>clear(&#160;)</B> methods.
At the beginning, an object variable named <B>Adder</B> is declared. In the
<B>Form_Load</B> subroutine, executed when the form is first displayed, a new
instance of the <B>Adder</B> automation server is instantiated and the text
fields on the form are initialized. When the user presses the &#8220;Sum&#8221;
or &#8220;Clear&#8221; buttons, appropriate methods in the server are
invoked.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Dim Adder As Object

Private Sub Form_Load()
    Set Adder = CreateObject(<font color=#004488>"JavaAdder.Adder.1"</font>)
    Addend.Text = Adder.getAddend
    Result.Caption = Adder.getResult
End Sub

Private Sub SumBtn_Click()
    Adder.setAddend (Addend.Text)
    Adder.Sum
    Result.Caption = Adder.getResult
End Sub

Private Sub ClearBtn_Click()
    Adder.Clear
    Addend.Text = Adder.getAddend
    Result.Caption = Adder.getResult
End Sub</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that this code has no
knowledge that the server was implemented in Java.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program and the
<B>CreateObject(&#160;)</B> function is called, the Windows Registry is searched
for the specified ProgID. Among the information related to the ProgID is the
name of the Java class file, so in response the Java Virtual Machine is started,
and the Java object instantiated inside the JVM. From then on, the JVM takes
care of the interaction between the client and server
code.</FONT><A NAME="_Toc408018838"></A><BR></P></DIV>
<A NAME="Heading613"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Developing COM clients in Java</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now let&#8217;s jump to the other
side and develop a COM client in Java. This program will call services in a COM
server that&#8217;s installed on your system. The example is a client for the
server we implemented in the previous example. While the code will look familiar
to a Java programmer, what happens behind the scenes is quite unusual. This
example uses a server that happens to be written in Java but applies to any
ActiveX Control, ActiveX Automation server, or ActiveX component installed in
your system for which you have a type library.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, the <B>Jactivex</B> tool is
applied to the server&#8217;s type library. <B>Jactivex</B> has a number of
options and switches, but in its basic form it reads a type library and
generates Java source files, which it stores in your
<B>windows/Java/trustlib</B> directory. In the example line below, it is applied
to the type library that was generated for out COM Automation
server.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jactivex /javatlb JavaAdder.tlb</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If, after <B>Jactivex</B> has
finished, you take a look at your <B>windows/Java/trustlib</B> directory,
you&#8217;ll find a new subdirectory called <B>javaadder</B> that contains the
source files for a new package. This is the Java equivalent of the type library.
These files use compiler directives specific to the Microsoft compiler: the
<B>@com</B> directives. The reason <B>jactivex</B> generated more than one file
is that COM uses more than one entity to describe a COM server (and also because
I did not fine-tune the use of MIDL files and the Java/COM
tools).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The file named <B>Adder.java</B> is
the equivalent of a <B>coclass</B> directive in a MIDL file: it&#8217;s the
declaration of a COM class. The other files are the Java equivalent of the COM
interfaces exposed by the server. These interfaces, such as
<B>Adder_DispatchDefault.java</B>, are dispatch interfaces, part of the
mechanism of interaction between an Automation controller and an Automation
server. The Java/COM integration feature also supports the implementation and
use of dual interfaces. IDispatch and dual interfaces are beyond the scope of
this appendix.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Below, you can see the client code.
The first line just imports the package generated by <B>jactivex</B>. Then an
instance of the COM Automation server is created and used, as if it was an
ordinary Java class. Notice the typecast on the line where the COM object is
instantiated. This is consistent with the COM object model. In COM, the
programmer never has a reference to the whole object; instead, the programmer
can only have references to one or more of the interfaces implemented in the
class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Instantiating a Java object of the
Adder class tells COM to activate the server and to create an instance of this
COM object. But then we must specify which interface we want to use, choosing
among the ones implemented by the server. This is exactly what the typecast
does. The interface used here is the <I>default dispatch interface</I>, the
standard interface that an Automation controller uses to communicate with an
Automation server (for details, see <I>Inside COM</I>, ibid.). Notice how simple
it is to activate the server and select a COM interface:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> javaadder.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> JavaClient {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String [] args) {
    Adder_DispatchDefault iAdder =
         (Adder_DispatchDefault) <font color=#0000ff>new</font> Adder();
    iAdder.setAddend(3);
    iAdder.sum();
    iAdder.sum();
    iAdder.sum();
    System.out.println(iAdder.getResult());
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now you can compile and run the
code.</FONT><BR></P></DIV>
<A NAME="Heading614"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The com.ms.com package</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index3105"></A><B>com.ms.com</B> package defines a number of classes
for COM development. It supports the use of GUIDs &#8211; the <B>Variant</B> and
<B>SafeArray</B> Automation types &#8211; interfacing with ActiveX Controls at a
deeper level and handling COM exceptions.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I cannot cover all of these topics
here, but I want to point out something about COM exceptions. By convention,
virtually all COM functions return an HRESULT value that tells you if the
function invocation succeeded or not and why. But if you look at the Java method
signature in our server and client code, there no HRESULT. Instead, we use the
function return value to get data back from some functions. The virtual machine
is translating Java-style function calls into COM-style function calls, even for
the return parameter. But what happens inside the virtual machine if one of the
functions you call in the server fails at the COM level? In this case, the JVM
sees that the HRESULT value indicates a failure and generates a native Java
exception of class <B>com.ms.com.ComFailException</B>. In this way, you can
handle COM errors using Java exception handling instead of checking function
return values.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To learn more about the classes in
this package, please refer to the Microsoft
documentation.</FONT><A NAME="_Toc408018839"></A><BR></P></DIV>
<A NAME="Heading615"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
ActiveX/Beans integration</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An interesting result of Java/COM
integration is the <A NAME="Index3106"></A>ActiveX/Beans integration, by which a
Java Bean can be hosted by an ActiveX container such as VB or any Microsoft
Office product, and an ActiveX Control can be hosted by a Beans container such
as Sun&#8217;s BeanBox. The Microsoft JVM takes care of the details. An ActiveX
Control is just a COM server exposing predefined, required interfaces. A Bean is
just a Java class that is compliant with a specific programming style. At the
time this was written, however, the integration was not perfect. For example,
the virtual machine is not able to map the JavaBeans event model to the COM
event model. If you want to handle events from a <A NAME="Index3107"></A>Bean
inside an ActiveX container, the Bean must intercept system events such as mouse
actions via low-level techniques, not the standard JavaBeans delegation event
model.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Apart from this, the ActiveX/Beans
integration is extremely interesting. The concept and tools are exactly the same
as discussed above, so please consult Microsoft&#8217;s documentation for more
details.</FONT><A NAME="_Toc408018840"></A><BR></P></DIV>
<A NAME="Heading616"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A note about native methods and applets</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Native methods face the security
issue. When your Java code calls a native method, you pass control outside of
the virtual machine &#8220;sandbox.&#8221; The native method has complete access
to the operating system. Of course, this is exactly what you want if you write
native methods, but it is not acceptable for applets, at least not implicitly.
You don&#8217;t want an applet, downloaded from a remote Internet server, to be
free to play with the file system and other critical areas of your machine
unless you allow it to do so. To prevent this situation with J/Direct, RNI, and
COM integration, only trusted Java code has permission to make native method
calls. Different conditions must be met depending on the feature the applet is
trying to use. For example, an applet that uses J/Direct must be digitally
signed to indicate full trust. At the time of this writing, not all of these
security mechanisms are implemented (in the Microsoft SDK for Java, beta 2), so
keep an eye on the documentation as new versions become
available.</FONT><A NAME="_Toc408018841"></A><BR></P></DIV>
<A NAME="Heading617"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
CORBA</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In large, distributed applications,
your needs might not be satisfied by the preceding approaches. For example, you
might want to interface with legacy datastores, or you might need services from
a server object regardless of its physical location. These situations require
some form of Remote Procedure Call (RPC), and possibly language independence.
This is where CORBA can help.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index3108"></A><FONT FACE="Georgia">CORBA is
not a language feature; it&#8217;s an integration technology. It&#8217;s a
specification that vendors can follow to implement CORBA-compliant integration
products. CORBA is part of the OMG&#8217;s effort to define a standard framework
for distributed, language-independent object interoperability.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">CORBA supplies the ability to make
remote procedure calls into Java objects and non-Java objects, and to interface
with legacy systems in a location-transparent way. Java adds networking support
and a nice object-oriented language for building graphical and non-graphical
applications. The Java and <A NAME="Index3109"></A>OMG object model map nicely
to each other; for example, both Java and CORBA implement the interface concept
and a reference object model.</FONT><A NAME="_Toc408018842"></A><BR></P></DIV>
<A NAME="Heading618"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
CORBA Fundamentals</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The object interoperability
specification developed by the OMG is commonly referred to as the Object
Management Architecture (OMA). The OMA defines two components: the Core Object
Model and the OMA Reference Architecture. The Core Object Model states the basic
concepts of object, interface, operation, and so on. (CORBA is a refinement of
the Core Object Model.) The OMA Reference Architecture defines an underlying
infrastructure of services and mechanisms that allow objects to interoperate.
The OMA Reference Architecture includes the Object Request Broker (ORB), Object
Services (also known as CORBAservices), and common facilities.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The ORB is the communication bus by
which objects can request services from other objects, regardless of their
physical location. This means that what looks like a method call in the client
code is actually a complex operation. First, a connection with the server object
must exist, and to create a connection the ORB must know where the server
implementation code resides. Once the connection is established, the method
arguments must be marshaled, i.e. converted in a binary stream to be sent across
a network. Other information that must be sent are the server machine name, the
server process, and the identity of the server object inside that process.
Finally, this information is sent through a low-level wire protocol, the
information is decoded on the server side, and the call is executed. The ORB
hides all of this complexity from the programmer and makes the operation almost
as simple as calling a method on local object.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is no specification for how
an ORB Core should be implemented, but to provide a basic compatibility among
different vendors&#8217; ORBs, the OMG defines a set of services that are
accessible through standard interfaces.</FONT><BR></P></DIV>
<A NAME="Heading619"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
CORBA Interface Definition Language (IDL)</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">CORBA is designed for language
transparency: a client object can call methods on a server object of different
class, regardless of the language they are implemented with. Of course, the
client object must know the names and signatures of methods that the server
object exposes. This is where IDL comes in. The CORBA IDL is a language-neutral
way to specify data types, attributes, operations, interfaces, and more. The IDL
syntax is similar to the C++ or Java syntax. The following table shows the
correspondence between some of the concepts common to three languages that can
be specified through CORBA IDL:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CORBA IDL</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Java</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>C++</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Module</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Package</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Namespace</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Interface</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Interface</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Pure abstract
class</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Method</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Method</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Member function</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The inheritance concept is
supported as well, using the colon operator as in C++. The programmer writes an
IDL description of the attributes, methods, and interfaces that will be
implemented and used by the server and clients. The IDL is then compiled by a
vendor-provided IDL/Java compiler, which reads the IDL source and generates Java
code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The IDL compiler is an extremely
useful tool: it doesn&#8217;t just generate a Java source equivalent of the IDL,
it also generates the code that will be used to marshal method arguments and to
make remote calls. This code, called the stub and skeleton code, is organized in
multiple Java source files and is usually part of the same Java package.
</FONT><BR></P></DIV>
<A NAME="Heading620"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The naming service</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The naming service is one of the
fundamental CORBA services. A CORBA object is accessed through a reference, a
piece of information that&#8217;s not meaningful for the human reader. But
references can be assigned programmer-defined, string names. This operation is
known as <I>stringifying the reference</I>, and one of the OMA components, the
Naming Service, is devoted to performing string-to-object and object-to-string
conversion and mapping. Since the Naming Service acts as a telephone directory
that both servers and clients can consult and manipulate, it runs as a separate
process. Creating an object-to-string mapping is called <I>binding an
object</I>, and removing the mapping is called <I>unbinding</I>. Getting an
object reference passing a string is called <I>resolving the
name</I>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For example, on startup, a server
application could create a server object, bind the object into the name service,
and then wait for clients to make requests. A client first obtains a server
object reference, resolving the string name, and then can make calls into the
server using the reference.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Again, the Naming Service
specification is part of CORBA, but the application that implements it is
provided by the ORB vendor. The way you get access to the Naming Service
functionality can vary from vendor to vendor.
</FONT><A NAME="_Toc408018843"></A><BR></P></DIV>
<A NAME="Heading621"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
An example</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The code shown here will not be
elaborate because different ORBs have different ways to access CORBA services,
so examples are vendor specific. (The example below uses JavaIDL, a free product
from Sun that comes with a light-weight ORB, a naming service, and a IDL-to-Java
compiler.) In addition, since Java is young and still evolving, not all CORBA
features are present in the various Java/CORBA products.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">We want to implement a server,
running on some machine, that can be queried for the exact time. We also want to
implement a client that asks for the exact time. In this case we&#8217;ll be
implementing both programs in Java, but we could also use two different
languages (which often happens in real situations).</FONT><BR></P></DIV>
<A NAME="Heading622"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Writing the IDL source</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first step is to write an IDL
description of the services provided. This is usually done by the server
programmer, who is then free to implement the server in any language in which a
CORBA IDL compiler exists. The IDL file is distributed to the client side
programmer and becomes the bridge between languages.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The example below shows the IDL
description of our exact time server:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>module RemoteTime {
   <font color=#0000ff>interface</font> ExactTime {
      string getTime();
   };
};</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is a declaration of the
<B>ExactTime</B> interface inside the <B>RemoteTime</B> namespace. The interface
is made up of one single method the gives back the current time in <B>string</B>
format.</FONT><BR></P></DIV>
<A NAME="Heading623"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Creating stubs and skeletons</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second step is to compile the
IDL to create the Java stub and skeleton code that we&#8217;ll use for
implementing the client and the server. The tool that comes with the JavaIDL
product is <A NAME="Index3110"></A><B>idltojava</B>: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>idltojava &#8211;fserver &#8211;fclient RemoteTime.idl</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The two flags tell <B>idltojava</B>
to generate code for both the stub and the skeleton. <B>Idltojava</B> generates
a Java package named after the IDL module, <B>RemoteTime</B>, and the generated
Java files are put in the <B>RemoteTime</B> subdirectory.
<B>_ExactTimeImplBase.java </B>is the skeleton that we&#8217;ll use to implement
the server object, and <B>_ExactTimeStub.java</B> will be used for the client.
There are Java representations of the IDL interface in <B>ExactTime.java</B> and
a couple of other support files used, for example, to facilitate access to the
naming service operations.</FONT><BR></P></DIV>
<A NAME="Heading624"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Implementing the server and the client</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Below you can see the code for the
server side. The server object implementation is in the <B>ExactTimeServer</B>
class. The <B>RemoteTimeServer</B> is the application that creates a server
object, registers it with the ORB, gives a name to the object reference, and
then sits quietly waiting for client requests.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> RemoteTime.*;

<font color=#0000ff>import</font> org.omg.CosNaming.*;
<font color=#0000ff>import</font> org.omg.CosNaming.NamingContextPackage.*;
<font color=#0000ff>import</font> org.omg.CORBA.*;

<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.text.*;

<font color=#009900>// Server object implementation</font>
<font color=#0000ff>class</font> ExactTimeServer <font color=#0000ff>extends</font> _ExactTimeImplBase{
  <font color=#0000ff>public</font> String getTime(){
    <font color=#0000ff>return</font> DateFormat.
        getTimeInstance(DateFormat.FULL).
          format(<font color=#0000ff>new</font> Date(
              System.currentTimeMillis()));
  }
}

<font color=#009900>// Remote application implementation</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> RemoteTimeServer {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[])  {
    <font color=#0000ff>try</font> {
      <font color=#009900>// ORB creation and initialization:</font>
      ORB orb = ORB.init(args, <font color=#0000ff>null</font>);
      <font color=#009900>// Create the server object and register it:</font>
      ExactTimeServer timeServerObjRef = 
        <font color=#0000ff>new</font> ExactTimeServer();
      orb.connect(timeServerObjRef);
      <font color=#009900>// Get the root naming context:</font>
      org.omg.CORBA.Object objRef = 
        orb.resolve_initial_references(
          <font color=#004488>"NameService"</font>);
      NamingContext ncRef = 
        NamingContextHelper.narrow(objRef);
      <font color=#009900>// Assign a string name to the </font>
      <font color=#009900>// object reference (binding):</font>
      NameComponent nc = 
        <font color=#0000ff>new</font> NameComponent(<font color=#004488>"ExactTime"</font>, <font color=#004488>""</font>);
      NameComponent path[] = {nc};
      ncRef.rebind(path, timeServerObjRef);
      <font color=#009900>// Wait for client requests:</font>
      java.lang.Object sync =
        <font color=#0000ff>new</font> java.lang.Object();
      <font color=#0000ff>synchronized</font>(sync){
        sync.wait();
      }
    }
    <font color=#0000ff>catch</font> (Exception e)  {
      System.out.println(
         <font color=#004488>"Remote Time server error: "</font> + e);
      e.printStackTrace(System.out);
    }
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you can see, implementing the
server object is simple; it&#8217;s a regular Java class that inherits from the
skeleton code generated by the IDL compiler. Things get a bit more complicated
when it comes to interacting with the ORB and other CORBA
services.</FONT><BR></P></DIV>
<A NAME="Heading625"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Some CORBA services</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is a short description of what
the JavaIDL-related code is doing (primarily ignoring the part of the CORBA code
that is vendor dependent). The first line in <B>main(&#160;)</B> starts up the
ORB, and of course, this is because our server object will need to interact with
it. Right after the ORB initialization, a server object is created. Actually,
the right term would be a <I>transient servant object</I>: an object that
receives requests from clients, and whose lifetime is the same as the process
that creates it. Once the transient servant object is created, it is registered
with the ORB, which means that the ORB knows of its existence and can now
forward requests to it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Up to this point, all we have is
<B>timeServerObjRef</B>, an object reference that is known only inside the
current server process. The next step will be to assign a stringified name to
this servant object; clients will use that name to locate the servant object. We
accomplish this operation using the Naming Service. First, we need an object
reference to the Naming Service; the call to
<B>resolve_initial_references(&#160;)</B> takes the stringified object reference
of the Naming Service that is &#8220;NameService,&#8221; in JavaIDL, and returns
an object reference. This is cast to a specific <B>NamingContext</B> reference
using the <B>narrow(&#160;)</B> method. We can use now the naming
services.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To bind the servant object with a
stringified object reference, we first create a <B>NameComponent</B> object,
initialized with &#8220;ExactTime,&#8221; the name string we want to bind to the
servant object. Then, using the <B>rebind(&#160;)</B> method, the stringified
reference is bound to the object reference. We use <B>rebind(&#160;)</B> to
assign a reference, even if it already exists, whereas <B>bind(&#160;)</B>
raises an exception if the reference already exists. A name is made up in CORBA
by a sequence of NameContexts &#8211; that&#8217;s why we use an array to bind
the name to the object reference.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The servant object is finally ready
for use by clients. At this point, the server process enters a wait state.
Again, this is because it is a transient servant, so its lifetime is confined to
the server process. JavaIDL does not currently support persistent objects
&#8211; objects that survive the execution of the process that creates
them.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now that we have an idea of what
the server code is doing, let&#8217;s look at the client code:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> RemoteTime.*;
<font color=#0000ff>import</font> org.omg.CosNaming.*;
<font color=#0000ff>import</font> org.omg.CORBA.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> RemoteTimeClient {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    <font color=#0000ff>try</font> {
      <font color=#009900>// ORB creation and initialization:</font>
      ORB orb = ORB.init(args, <font color=#0000ff>null</font>);
      <font color=#009900>// Get the root naming context:</font>
      org.omg.CORBA.Object objRef = 
        orb.resolve_initial_references(
          <font color=#004488>"NameService"</font>);
      NamingContext ncRef = 
        NamingContextHelper.narrow(objRef);
      <font color=#009900>// Get (resolve) the stringified object </font>
      <font color=#009900>// reference for the time server:</font>
      NameComponent nc = 
        <font color=#0000ff>new</font> NameComponent(<font color=#004488>"ExactTime"</font>, <font color=#004488>""</font>);
      NameComponent path[] = {nc};
      ExactTime timeObjRef = 
        ExactTimeHelper.narrow(
          ncRef.resolve(path));
      <font color=#009900>// Make requests to the server object:</font>
      String exactTime = timeObjRef.getTime();
      System.out.println(exactTime);
    } <font color=#0000ff>catch</font> (Exception e) {
      System.out.println(
         <font color=#004488>"Remote Time server error: "</font> + e);
      e.printStackTrace(System.out);
    }
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first few lines do the same as
they do in the server process: the ORB is initialized and a reference to the
naming service server is resolved. Next, we need an object reference for the
servant object, so we pass the stringified object reference to the
<B>resolve(&#160;)</B> method, and we cast the result into an <B>ExactTime</B>
interface reference using the <B>narrow(&#160;)</B> method. Finally, we call
<B>getTime(&#160;)</B>. </FONT><BR></P></DIV>
<A NAME="Heading626"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Activating the name service process</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally we have a server and a
client application ready to interoperate. You&#8217;ve seen that both need the
naming service to bind and resolve stringified object references. You must start
the naming service process before running either the server or the client. In
JavaIDL, the naming service is a Java application that comes with the product
package, but it can be different with other products. The JavaIDL naming service
runs inside an instance of the JVM and listens by default to network port
900.</FONT><BR></P></DIV>
<A NAME="Heading627"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Activating the server and the client</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now you are ready to start your
server and client application (in this order, since our server is transient). If
everything is set up correctly, what you&#8217;ll get is a single output line on
the client console window, giving you the current time. Of course, this might be
not very exciting by itself, but you should take one thing into account: even if
they are on the same physical machine, the client and the server application are
running inside different virtual machines and they can communicate via an
underlying integration layer, the ORB and the Naming Service.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is a simple example, designed
to work without a network, but an ORB is usually configured for location
transparency. When the server and the client are on different machines, the ORB
can resolve remote stringified references using a component known as the
<I>Implementation Repository</I>. Although the Implementation Repository is part
of CORBA, there is almost no specification, so it differs from vendor to
vendor.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you can see, there is much more
to CORBA than what has been covered here, but you should get the basic idea. If
you want more information about CORBA, the place to start is the OMG Web site,
at http://www.omg.org<A HREF="http://www.omg.org"></A>. There you&#8217;ll find
documentation, white papers, proceedings, and references to other CORBA sources
and products.</FONT><A NAME="_Toc408018844"></A><BR></P></DIV>
<A NAME="Heading628"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Java Applets and CORBA</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java applets can act as CORBA
clients. This way, an applet can access remote information and services exposed
as CORBA objects. But an applet can connect only with the server from which it
was downloaded, so all the CORBA objects the applet interacts with must be on
that server. This is the opposite of what CORBA tries to do: give you complete
location transparency.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is an issue of network
security. If you&#8217;re on an Intranet, one solution is to loosen the security
restrictions on the browser. Or, set up a firewall policy for connecting with
external servers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some Java ORB products offer
proprietary solutions to this problem. For example, some implement what is
called HTTP Tunneling, while others have their special firewall
features.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is too complex a topic to be
covered in an appendix, but it is definitely something you should be aware
of.</FONT><A NAME="_Toc408018845"></A><BR></P></DIV>
<A NAME="Heading629"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
CORBA vs. RMI</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You saw that one of the main CORBA
features is RPC support, which allows your local objects to call methods in
remote objects. Of course, there already is a native Java feature that does
exactly the same thing: RMI (see Chapter 15). While RMI makes RPC possible
between Java objects, CORBA makes RPC possible between objects implemented in
any language. It&#8217;s a big difference.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However,
<A NAME="Index3111"></A>RMI can be used to call services on remote, non-Java
code. All you need is some kind of wrapper Java object around the non-Java code
on the server side. The wrapper object connects externally to Java clients via
RMI, and internally connects to the non-Java code using one of the techniques
shown above, such as JNI or J/Direct.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This approach requires you to write
a kind of integration layer, which is exactly what CORBA does for you, but then
you don&#8217;t need a third-party
ORB.</FONT><A NAME="_Toc408018846"></A><BR></P></DIV>
<A NAME="Heading630"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What you&#8217;ve seen in this
appendix are the most common techniques to call non-Java code from a Java
application. Each technique has its pros and cons, but currently the major
problem is that not all of these features are available on all JVMs, so a Java
program that calls native methods on a specific platform might not work on a
different platform with a different JVM.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sun&#8217;s JNI is flexible,
reasonably simple (although it requires a lot of control over the JVM
internals), powerful, and it&#8217;s available on most JVMs, but not all.
Microsoft, at the time of this writing, does not support JNI, but offers
J/Direct, a simple way to call Win32 DLL functions, and RNI, which is designed
for high-performance code but requires a good understanding of the JVM
internals. Microsoft also offers its proprietary Java/COM integration feature,
which is powerful and makes Java an interesting language for writing COM servers
and clients. J/Direct, RNI, and Java/COM integration are supported only by the
Microsoft compiler and JVM.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, we took a look at CORBA,
which allows your Java objects to talk to other objects regardless of their
physical location and implementation language. CORBA is different from the
techniques above because it is not integrated with the Java language, but
instead uses third-party integration technology and requires that you buy a
third-party ORB. CORBA is an interesting and general solution, but it might not
be the best approach if you just want to make calls into the operating
system.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="OLE_LINK6"></A><A NAME="_Toc375545508"></A><A NAME="Appendix_B"></A><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter17.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="AppendixB.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/04/2000</P></DIV>

</BODY>

</HTML>
