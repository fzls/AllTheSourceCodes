<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:Tjava14.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/04/2000
Translation Time:23:24:54
Translation Platform:Win32
Number of Output files:27
This File:Chapter07.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>7: Polymorphism</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/TIJ2/index.html">2nd Edition</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/javaCD2.html">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 1st edition</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;1998 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter06.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter08.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_7"></A><A NAME="_Toc375545326"></A><A NAME="_Toc407441451"></A><A NAME="_Toc408018529"></A><A NAME="Heading206"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
7: Polymorphism<BR><A NAME="Index549"></A></H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>Polymorphism is the third
essential feature of an object-oriented programming language, after data
abstraction and inheritance. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It provides another dimension of
separation of interface from implementation, to decouple <I>what</I> from
<I>how</I>. Polymorphism allows improved code organization and readability as
well as the creation of <I>extensible</I> programs that can be
&#8220;grown&#8221; not only during the original creation of the project but
also when new features are desired.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Encapsulation creates new data
types by combining characteristics and behaviors. Implementation hiding
separates the interface from the implementation by making the details
<B>private</B>. This sort of mechanical organization makes ready sense to
someone with a procedural programming background. But polymorphism deals with
<A NAME="Index550"></A>decoupling in terms of <I>types</I>. In the last chapter,
you saw how <A NAME="Index551"></A>inheritance allows the treatment of an object
as its own type <I>or</I> its base type. This ability is critical because it
allows many types (derived from the same base type) to be treated as if they
were one type, and a single piece of code to work on all those different types
equally. The <A NAME="Index552"></A>polymorphic method call allows one type to
express its distinction from another, similar type, as long as they&#8217;re
both derived from the same base type. This distinction is expressed through
differences in behavior of the methods you can call through the base
class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this chapter, you&#8217;ll learn
about polymorphism (also called
<A NAME="Index553"></A><A NAME="Index554"></A><A NAME="Index555"></A><A NAME="Index556"></A><I>dynamic
binding</I> or <I>late binding</I> or <I>run-time binding</I>)<I> </I>starting
from the basics, with simple examples that strip away everything but the
polymorphic behavior of the
program.</FONT><A NAME="_Toc305593263"></A><A NAME="_Toc305628735"></A><A NAME="_Toc312374040"></A><A NAME="_Toc375545327"></A><A NAME="_Toc408018530"></A><BR></P></DIV>
<A NAME="Heading207"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Upcasting</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Chapter 6 you saw how an object
can be used as its own type or as an object of its base type. Taking an object
handle and treating it as the handle of the base type is called
<I>upcasting<A NAME="Index557"></A></I> because of the way inheritance trees are
drawn with the base class at the top.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You also saw a problem arise, which
is embodied in the following: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Music.java </font>
<font color=#009900>// Inheritance &amp; upcasting</font>
<font color=#0000ff>package</font> c07;

<font color=#0000ff>class</font> Note {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> value;
  <font color=#0000ff>private</font> Note(<font color=#0000ff>int</font> val) { value = val; }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> Note
    middleC = <font color=#0000ff>new</font> Note(0), 
    cSharp = <font color=#0000ff>new</font> Note(1),
    cFlat = <font color=#0000ff>new</font> Note(2);
} <font color=#009900>// Etc.</font>

<font color=#0000ff>class</font> Instrument {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play(Note n) {
    System.out.println(<font color=#004488>"Instrument.play()"</font>);
  }
}

<font color=#009900>// Wind objects are instruments</font>
<font color=#009900>// because they have the same interface:</font>
<font color=#0000ff>class</font> Wind <font color=#0000ff>extends</font> Instrument {
  <font color=#009900>// Redefine interface method:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play(Note n) {
    System.out.println(<font color=#004488>"Wind.play()"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Music {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> tune(Instrument i) {
    <font color=#009900>// ...</font>
    i.play(Note.middleC);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Wind flute = <font color=#0000ff>new</font> Wind();
    tune(flute); <font color=#009900>// Upcasting</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The method
<B>Music.tune(&#160;)</B> accepts an <B>Instrument </B>handle, but also anything
derived from <B>Instrument</B>. In <B>main(&#160;)</B>, you can see this
happening as a <B>Wind</B> handle is passed to <B>tune(&#160;)</B>, with no cast
necessary. This is acceptable; the interface in <B>Instrument</B> must exist in
<B>Wind</B>, because <B>Wind</B> is inherited from <B>Instrument</B>. Upcasting
from <B>Wind</B> to <B>Instrument</B> may &#8220;narrow&#8221; that interface,
but it cannot make it anything less than the full interface to
<B>Instrument</B>.</FONT><A NAME="_Toc375545328"></A><A NAME="_Toc408018531"></A><BR></P></DIV>
<A NAME="Heading208"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Why upcast?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program might seem strange to
you. Why should anyone intentionally <I>forget</I> the type of an object? This
is what happens when you upcast, and it seems like it could be much more
straightforward if <B>tune(&#160;)</B> simply takes a <B>Wind</B> handle as its
argument. This brings up an essential point: If you did that, you&#8217;d need
to write a new <B>tune(&#160;)</B> for every type of <B>Instrument</B> in your
system. Suppose we follow this reasoning and add <B>Stringed</B> and
<B>Brass</B> instruments:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Music2.java </font>
<font color=#009900>// Overloading instead of upcasting</font>

<font color=#0000ff>class</font> Note2 {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> value;
  <font color=#0000ff>private</font> Note2(<font color=#0000ff>int</font> val) { value = val; }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> Note2
    middleC = <font color=#0000ff>new</font> Note2(0), 
    cSharp = <font color=#0000ff>new</font> Note2(1),
    cFlat = <font color=#0000ff>new</font> Note2(2);
} <font color=#009900>// Etc.</font>

<font color=#0000ff>class</font> Instrument2 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play(Note2 n) {
    System.out.println(<font color=#004488>"Instrument2.play()"</font>);
  }
}

<font color=#0000ff>class</font> Wind2 <font color=#0000ff>extends</font> Instrument2 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play(Note2 n) {
    System.out.println(<font color=#004488>"Wind2.play()"</font>);
  }
}

<font color=#0000ff>class</font> Stringed2 <font color=#0000ff>extends</font> Instrument2 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play(Note2 n) {
    System.out.println(<font color=#004488>"Stringed2.play()"</font>);
  }
}

<font color=#0000ff>class</font> Brass2 <font color=#0000ff>extends</font> Instrument2 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play(Note2 n) {
    System.out.println(<font color=#004488>"Brass2.play()"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Music2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> tune(Wind2 i) {
    i.play(Note2.middleC);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> tune(Stringed2 i) {
    i.play(Note2.middleC);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> tune(Brass2 i) {
    i.play(Note2.middleC);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Wind2 flute = <font color=#0000ff>new</font> Wind2();
    Stringed2 violin = <font color=#0000ff>new</font> Stringed2();
    Brass2 frenchHorn = <font color=#0000ff>new</font> Brass2();
    tune(flute); <font color=#009900>// No upcasting</font>
    tune(violin);
    tune(frenchHorn);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This works, but there&#8217;s a
major drawback: You must write type-specific methods for each new
<B>Instrument2</B> class you add. This means more programming in the first
place, but it also means that if you want to add a new method like
<B>tune(&#160;)</B> or a new type of <B>Instrument</B>, you&#8217;ve got a lot
of work to do. Add the fact that the compiler won&#8217;t give you any error
messages if you forget to overload one of your methods and the whole process of
working with types becomes unmanageable.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Wouldn&#8217;t it be much nicer if
you could just write a single method that takes the
<A NAME="Index558"></A><A NAME="Index559"></A>base class as its argument, and
not any of the specific derived classes? That is, wouldn&#8217;t it be nice if
you could forget that there are
<A NAME="Index560"></A><A NAME="Index561"></A>derived classes, and write your
code to talk only to the base class?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That&#8217;s exactly what
polymorphism allows you to do. However, most programmers (who come from a
procedural programming background) have a bit of trouble with the way
polymorphism
works.</FONT><A NAME="_Toc305593264"></A><A NAME="_Toc305628736"></A><A NAME="_Toc312374041"></A><A NAME="_Toc375545329"></A><A NAME="_Toc408018532"></A><BR></P></DIV>
<A NAME="Heading209"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The twist</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The difficulty with
<B>Music</B>.<B>java</B> can be seen by running the program. The output is
<B>Wind.play(&#160;)</B>. This is clearly the desired output, but it
doesn&#8217;t seem to make sense that it would work that way. Look at the
<B>tune(&#160;)</B> method:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> tune(Instrument i) {
    <font color=#009900>// ...</font>
    i.play(Note.middleC);
  }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It receives an <B>Instrument</B>
handle. So how can the compiler possibly know that this <B>Instrument</B> handle
points to a <B>Wind</B> in this case and not a <B>Brass </B>or <B>Stringed</B>?
The compiler can&#8217;t. To get a deeper understanding of the issue, it&#8217;s
useful to examine the subject of
<I>binding</I>.</FONT><A NAME="_Toc312374042"></A><A NAME="_Toc375545330"></A><A NAME="_Toc408018533"></A><BR></P></DIV>
<A NAME="Heading210"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Method call binding<BR><A NAME="Index562"></A><A NAME="Index563"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Connecting a method call to a
method body is called <I>binding</I>. When binding is performed before the
program is run (by the compiler and linker, if there is one), it&#8217;s called
<I>early binding<A NAME="Index564"></A></I>. You might not have heard the term
before because it has never been an option with procedural languages. C
compilers have only one kind of method call, and that&#8217;s early
binding.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The confusing part of the above
program revolves around early binding because the compiler cannot know the
correct method to call when it has only an <B>Instrument</B>
handle.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution is called <I>late
binding<A NAME="Index565"></A><A NAME="Index566"></A></I>, which means that the
binding occurs at run-time based on the type of object. Late binding is also
called <I>dynamic binding<A NAME="Index567"></A><A NAME="Index568"></A></I> or
<I>run-time binding<A NAME="Index569"></A><A NAME="Index570"></A></I>. When a
language implements late binding, there must be some mechanism to determine the
type of the object at run-time and to call the appropriate method. That is, the
compiler still doesn&#8217;t know the object type, but the method-call mechanism
finds out and calls the correct method body. The late-binding mechanism varies
from language to language, but you can imagine that some sort of type
information must be installed in the objects.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All method binding in Java uses
late binding unless a method has been declared
<A NAME="Index571"></A><A NAME="Index572"></A><B>final</B>. This means that you
ordinarily don&#8217;t need to make any decisions about whether late binding
will occur &#8211; it happens automatically.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Why would you declare a method
<B>final</B>? As noted in the last chapter, it prevents anyone from overriding
that method. Perhaps more importantly, it effectively &#8220;turns off&#8221;
dynamic binding, or rather it tells the compiler that dynamic binding
isn&#8217;t necessary. This allows the compiler to generate more efficient code
for <B>final</B> method
calls.</FONT><A NAME="_Toc375545331"></A><A NAME="_Toc408018534"></A><BR></P></DIV>
<A NAME="Heading211"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Producing the right behavior</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you know that all method
binding in Java happens polymorphically via late binding, you can write your
code to talk to the base-class and know that all the derived-class cases will
work correctly using the same code. Or to put it another way, you &#8220;send a
message to an object and let the object figure out the right thing to
do.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The classic example in OOP is the
&#8220;<A NAME="Index573"></A>shape&#8221; example. This is commonly used
because it is easy to visualize, but unfortunately it can confuse novice
programmers into thinking that OOP is just for graphics programming, which is of
course not the case.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The shape example has a base class
called <B>Shape </B>and various derived types: <B>Circle</B>, <B>Square</B>,
<B>Triangle</B>, etc. The reason the example works so well is that it&#8217;s
easy to say &#8220;a circle is a type of shape&#8221; and be understood.<B>
</B>The inheritance diagram shows the relationships:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava107.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The upcast could occur in a
statement as simple as:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Shape s = <font color=#0000ff>new</font> Circle();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, a <B>Circle</B> object is
created and the resulting handle is immediately assigned to a <B>Shape</B>,
which would seem to be an error (assigning one type to another) and yet
it&#8217;s fine because a <B>Circle</B> <I>is</I> a <B>Shape</B> by inheritance.
So the compiler agrees with the statement and doesn&#8217;t issue an error
message.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you call one of the base class
methods (that have been overridden in the derived classes):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>s.draw();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Again, you might expect that
<B>Shape</B>&#8217;s <B>draw(&#160;)</B> is called because this is, after all, a
<B>Shape</B> handle, so how could the compiler know to do anything else? And yet
the proper <B>Circle.draw(&#160;)</B> is called because of late binding
(polymorphism).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example puts it a
slightly different way:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Shapes.java</font>
<font color=#009900>// Polymorphism in Java</font>

<font color=#0000ff>class</font> Shape { 
  <font color=#0000ff>void</font> draw() {}
  <font color=#0000ff>void</font> erase() {} 
}

<font color=#0000ff>class</font> Circle <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>void</font> draw() { 
    System.out.println(<font color=#004488>"Circle.draw()"</font>); 
  }
  <font color=#0000ff>void</font> erase() { 
    System.out.println(<font color=#004488>"Circle.erase()"</font>); 
  }
}

<font color=#0000ff>class</font> Square <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>void</font> draw() { 
    System.out.println(<font color=#004488>"Square.draw()"</font>); 
  }
  <font color=#0000ff>void</font> erase() { 
    System.out.println(<font color=#004488>"Square.erase()"</font>); 
  }
}

<font color=#0000ff>class</font> Triangle <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>void</font> draw() { 
    System.out.println(<font color=#004488>"Triangle.draw()"</font>); 
  }
  <font color=#0000ff>void</font> erase() { 
    System.out.println(<font color=#004488>"Triangle.erase()"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Shapes {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Shape randShape() {
    <font color=#0000ff>switch</font>((<font color=#0000ff>int</font>)(Math.random() * 3)) {
      <font color=#0000ff>default</font>: <font color=#009900>// To quiet the compiler</font>
      <font color=#0000ff>case</font> 0: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Circle();
      <font color=#0000ff>case</font> 1: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Square();
      <font color=#0000ff>case</font> 2: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Triangle();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Shape[] s = <font color=#0000ff>new</font> Shape[9];
    <font color=#009900>// Fill up the array with shapes:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
      s[i] = randShape();
    <font color=#009900>// Make polymorphic method calls:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
      s[i].draw();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The base class <B>Shape</B>
establishes the common interface to anything inherited from <B>Shape</B> &#8211;
that is, all shapes can be drawn and erased. The derived classes override these
definitions to provide unique behavior for each specific type of
shape.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The main class <B>Shapes</B>
contains a <B>static</B> method <B>randShape(&#160;)</B> that produces a handle
to a randomly-selected <B>Shape</B> object each time you call it. Note that the
upcasting happens in each of the <B>return</B> statements, which take a handle
to a <B>Circle</B>, <B>Square</B>, or <B>Triangle</B> and send it out of the
method as the return type, <B>Shape</B>. So whenever you call this method you
never get a chance to see what specific type it is, since you always get back a
plain <B>Shape</B> handle.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>main(&#160;)</B> contains an
array of <B>Shape</B> handles filled through calls to <B>randShape(&#160;)</B>.
At this point you know you have <B>Shape</B>s, but you don&#8217;t know anything
more specific than that (and neither does the compiler). However, when you step
through this array and call <B>draw(&#160;)</B> for each one, the correct
type-specific behavior magically occurs, as you can see from one output
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Circle.draw()
Triangle.draw()
Circle.draw()
Circle.draw()
Circle.draw()
Square.draw()
Triangle.draw()
Square.draw()
Square.draw()</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, since the shapes are all
chosen randomly each time, your runs will have different results. The point of
choosing the shapes randomly is to drive home the understanding that the
compiler can have no special knowledge that allows it to make the correct calls
at compile time. All the calls to <B>draw(&#160;)</B> are made through dynamic
binding.</FONT><A NAME="_Toc375545332"></A><A NAME="_Toc408018535"></A><BR></P></DIV>
<A NAME="Heading212"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Extensibility</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now let&#8217;s return to the
musical instrument example. Because of polymorphism, you can add as many new
types as you want to the system without changing the <B>tune(&#160;)</B> method.
In a well-designed OOP program, most or all of your methods will follow the
model of <B>tune(&#160;)</B> and communicate only with the base-class
interface<A NAME="Index574"></A><A NAME="Index575"></A>. Such a program is
<I>extensible<A NAME="Index576"></A></I> because you can add new functionality
by inheriting new data types from the common base class. The methods that
manipulate the base-class interface will not need to be changed at all to
accommodate the new classes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider what happens if you take
the instrument example and add more methods in the base class and a number of
new classes. Here&#8217;s the diagram:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava108.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All these new classes work
correctly with the old, unchanged <B>tune(&#160;)</B> method. Even if
<B>tune(&#160;)</B> is in a separate file and new methods are added to the
interface of <B>Instrument</B>, <B>tune(&#160;)</B> works correctly without
recompilation. Here is the implementation of the above diagram:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Music3.java</font>
<font color=#009900>// An extensible program</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Instrument3 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Instrument3.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() {
    <font color=#0000ff>return</font> <font color=#004488>"Instrument3"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Wind3 <font color=#0000ff>extends</font> Instrument3 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Wind3.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Wind3"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Percussion3 <font color=#0000ff>extends</font> Instrument3 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Percussion3.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Percussion3"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Stringed3 <font color=#0000ff>extends</font> Instrument3 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Stringed3.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Stringed3"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Brass3 <font color=#0000ff>extends</font> Wind3 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Brass3.play()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {
    System.out.println(<font color=#004488>"Brass3.adjust()"</font>);
  }
}

<font color=#0000ff>class</font> Woodwind3 <font color=#0000ff>extends</font> Wind3 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Woodwind3.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Woodwind3"</font>; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Music3 {
  <font color=#009900>// Doesn't care about type, so new types</font>
  <font color=#009900>// added to the system still work right:</font>
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> tune(Instrument3 i) {
    <font color=#009900>// ...</font>
    i.play();
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> tuneAll(Instrument3[] e) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; e.length; i++)
      tune(e[i]);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Instrument3[] orchestra = <font color=#0000ff>new</font> Instrument3[5];
    <font color=#0000ff>int</font> i = 0;
    <font color=#009900>// Upcasting during addition to the array:</font>
    orchestra[i++] = <font color=#0000ff>new</font> Wind3();
    orchestra[i++] = <font color=#0000ff>new</font> Percussion3();
    orchestra[i++] = <font color=#0000ff>new</font> Stringed3();
    orchestra[i++] = <font color=#0000ff>new</font> Brass3();
    orchestra[i++] = <font color=#0000ff>new</font> Woodwind3();
    tuneAll(orchestra);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The new methods are
<B>what(&#160;)</B>, which returns a <B>String</B> handle with a description of
the class, and <B>adjust(&#160;)</B>, which provides some way to adjust each
instrument.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, when you
place something inside the <B>Instrument3 </B>array you automatically upcast to
<B>Instrument3</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the
<B>tune(&#160;)</B> method is blissfully ignorant of all the code changes that
have happened around it, and yet it works correctly. This is exactly what
polymorphism is supposed to provide. Your code changes don&#8217;t cause damage
to parts of the program that should not be affected. Put another way,
polymorphism is one of the most important techniques that allow the programmer
to &#8220;separate the things that change from the things that stay the
same.&#8221;</FONT><A NAME="_Toc375545333"></A><A NAME="_Toc408018536"></A><BR></P></DIV>
<A NAME="Heading213"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Overriding vs.
overloading<BR><A NAME="Index577"></A><A NAME="Index578"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Let&#8217;s take a different look
at the first example in this chapter. In the following program, the interface of
the method <B>play(&#160;)</B> is changed in the process of overriding it, which
means that you haven&#8217;t <I>overridden</I> the method, but instead
<I>overloaded </I>it. The compiler allows you to overload methods so it gives no
complaint. But the behavior is probably not what you want. Here&#8217;s the
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: WindError.java </font>
<font color=#009900>// Accidentally changing the interface</font>

<font color=#0000ff>class</font> NoteX {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font>
    MIDDLE_C = 0, C_SHARP = 1, C_FLAT = 2;
}

<font color=#0000ff>class</font> InstrumentX {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play(<font color=#0000ff>int</font> NoteX) {
    System.out.println(<font color=#004488>"InstrumentX.play()"</font>);
  }
}

<font color=#0000ff>class</font> WindX <font color=#0000ff>extends</font> InstrumentX {
  <font color=#009900>// OOPS! Changes the method interface:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play(NoteX n) {
    System.out.println(<font color=#004488>"WindX.play(NoteX n)"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WindError {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> tune(InstrumentX i) {
    <font color=#009900>// ...</font>
    i.play(NoteX.MIDDLE_C);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    WindX flute = <font color=#0000ff>new</font> WindX();
    tune(flute); <font color=#009900>// Not the desired behavior!</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s another confusing
aspect thrown in here. In <B>InstrumentX</B>, the <B>play(&#160;)</B> method
takes an <B>int</B> that has the identifier <B>NoteX</B>. That is, even though
<B>NoteX</B> is a class name, it can also be used as an identifier without
complaint. But in <B>WindX</B>, <B>play(&#160;)</B> takes a <B>NoteX</B> handle
that has an identifier <B>n.</B> (Although you could even say <B>play(NoteX
NoteX)</B> without an error.) Thus it appears that the programmer intended to
override <B>play(&#160;)</B> but mistyped the method a bit. The compiler,
however, assumed that an overload and not an override was intended. Note that if
you follow the standard Java naming convention, the argument identifier would be
<B>noteX,</B> which would distinguish it from the class name.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>tune</B>, the
<B>InstrumentX</B> <B>i</B> is sent the <B>play(&#160;)</B> message, with one of
<B>NoteX</B>&#8217;s members (<B>MIDDLE_C</B>) as an argument. Since
<B>NoteX</B> contains <B>int</B> definitions, this means that the <B>int</B>
version of the now-overloaded <B>play(&#160;)</B> method is called, and since
that has <I>not</I> been overridden the base-class version is
used.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>InstrumentX.play()</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This certainly doesn&#8217;t appear
to be a polymorphic method call. Once you understand what&#8217;s happening, you
can fix the problem fairly easily, but imagine how difficult it might be to find
the bug if it&#8217;s buried in a program of significant
size.</FONT><A NAME="_Toc375545334"></A><A NAME="_Toc408018537"></A><BR></P></DIV>
<A NAME="Heading214"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Abstract classes <BR>and methods</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In all the instrument examples, the
methods in the base class <B>Instrument</B> were always &#8220;dummy&#8221;
methods. If these methods are ever called, you&#8217;ve done something wrong.
That&#8217;s because the intent of <B>Instrument</B> is to create a <I>common
interface</I> for all the classes derived from it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The only reason to establish this
common interface<A NAME="Index579"></A><A NAME="Index580"></A> is so it can be
expressed differently for each different subtype. It establishes a basic form,
so you can say what&#8217;s in common with all the derived classes. Another way
of saying this is to call <B>Instrument</B> an <I>abstract base class</I>
<A NAME="Index581"></A><A NAME="Index582"></A><A NAME="Index583"></A>(or simply
an <I>abstract class</I>). You create an abstract class when you want to
manipulate a set of classes through this common interface. All derived-class
methods that match the signature of the base-class declaration will be called
using the dynamic binding mechanism. (However, as seen in the last section, if
the method&#8217;s name is the same as the base class but the arguments are
different, you&#8217;ve got overloading, which probably isn&#8217;t what you
want.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you have an abstract class like
<B>Instrument</B>, objects of that class almost always have no meaning. That is,
<B>Instrument</B> is meant to express only the interface, and not a particular
implementation, so creating an <B>Instrument</B> object makes no sense, and
you&#8217;ll probably want to prevent the user from doing it. This can be
accomplished by making all the methods in <B>Instrument</B> print error
messages, but this delays the information until run-time and requires reliable
exhaustive testing on the user&#8217;s part. It&#8217;s always better to catch
problems at compile time.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java provides a mechanism for doing
this called the <I>abstract method</I>. This is a method that is incomplete; it
has only a declaration and no method body. Here is the syntax for an abstract
method declaration:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">abstract void
X();</FONT></TT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A class containing abstract methods
is called an <I>abstract class</I>. If a class contains one or more abstract
methods, the class must be qualified as <B>abstract.</B> (Otherwise, the
compiler gives you an error message.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If an abstract class is incomplete,
what is the compiler supposed to do when someone tries to make an object of that
class? It cannot safely create an object of an abstract class, so you get an
error message from the compiler. This way the compiler ensures the purity of the
abstract class, and you don&#8217;t need to worry about misusing
it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you
<A NAME="Index584"></A><A NAME="Index585"></A><A NAME="Index586"></A>inherit
from an abstract class and you want to make objects of the new type, you must
provide method definitions for all the abstract methods in the base class. If
you don&#8217;t (and you may choose not to), then the derived class is also
abstract and the compiler will force you to qualify <I>that</I> class with the
<A NAME="Index587"></A><B>abstract</B> keyword.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s possible to declare a
class as <B>abstract</B> <I>without</I> including any <B>abstract</B> methods.
This is useful when you&#8217;ve got a class in which it doesn&#8217;t make
sense to have any <B>abstract</B> methods, and yet you want to prevent any
instances of that class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Instrument</B> class can
easily be turned into an abstract class. Only some of the methods will be
abstract, since making a class abstract doesn&#8217;t force you to make all the
methods abstract.<B> </B>Here&#8217;s what it looks like:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava109.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the orchestra example
modified to use <B>abstract</B> classes and methods:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Music4.java</font>
<font color=#009900>// Abstract classes and methods</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Instrument4 {
  <font color=#0000ff>int</font> i; <font color=#009900>// storage allocated for each</font>
  <font color=#0000ff>public</font> <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> play();
  <font color=#0000ff>public</font> String what() {
    <font color=#0000ff>return</font> <font color=#004488>"Instrument4"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> adjust();
}

<font color=#0000ff>class</font> Wind4 <font color=#0000ff>extends</font> Instrument4 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Wind4.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Wind4"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Percussion4 <font color=#0000ff>extends</font> Instrument4 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Percussion4.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Percussion4"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Stringed4 <font color=#0000ff>extends</font> Instrument4 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Stringed4.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Stringed4"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Brass4 <font color=#0000ff>extends</font> Wind4 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Brass4.play()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() { 
    System.out.println(<font color=#004488>"Brass4.adjust()"</font>);
  }
}

<font color=#0000ff>class</font> Woodwind4 <font color=#0000ff>extends</font> Wind4 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Woodwind4.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Woodwind4"</font>; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Music4 {
  <font color=#009900>// Doesn't care about type, so new types</font>
  <font color=#009900>// added to the system still work right:</font>
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> tune(Instrument4 i) {
    <font color=#009900>// ...</font>
    i.play();
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> tuneAll(Instrument4[] e) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; e.length; i++)
      tune(e[i]);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Instrument4[] orchestra = <font color=#0000ff>new</font> Instrument4[5];
    <font color=#0000ff>int</font> i = 0;
    <font color=#009900>// Upcasting during addition to the array:</font>
    orchestra[i++] = <font color=#0000ff>new</font> Wind4();
    orchestra[i++] = <font color=#0000ff>new</font> Percussion4();
    orchestra[i++] = <font color=#0000ff>new</font> Stringed4();
    orchestra[i++] = <font color=#0000ff>new</font> Brass4();
    orchestra[i++] = <font color=#0000ff>new</font> Woodwind4();
    tuneAll(orchestra);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that there&#8217;s
really no change except in the base class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s helpful to create
<B>abstract </B>classes and methods because they make the abstractness of a
class explicit and tell both the user and the compiler how it was intended to be
used.</FONT><A NAME="_Toc375545335"></A><A NAME="_Toc408018538"></A><BR></P></DIV>
<A NAME="Heading215"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Interfaces</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index588"></A><B>interface</B> keyword takes the abstract<B>
</B>concept one step further. You could think of it as a &#8220;pure&#8221;
abstract<B> </B>class. It allows the creator to establish the form for a class:
method names, argument lists and return types, but no method bodies. An
<B>interface</B> can also contain data members of primitive types, but these are
implicitly <A NAME="Index589"></A><B>static</B> and
<A NAME="Index590"></A><B>final</B>. An <B>interface</B> provides only a form,
but no <A NAME="Index591"></A>implementation.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An <B>interface</B> says:
&#8220;This is what all classes that <I>implement</I> this particular interface
will look like.&#8221; Thus, any code that uses a particular <B>interface</B>
knows what methods might be called for that <B>interface</B>, and that&#8217;s
all. So the <B>interface</B> is used to establish a &#8220;protocol&#8221;
between classes. (Some object-oriented programming languages have a keyword
called <A NAME="Index592"></A><A NAME="Index593"></A><I>protocol</I> to do the
same thing.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To create an <B>interface</B>, use
the <B>interface</B> keyword instead of the <B>class</B> keyword. Like a class,
you can add the <A NAME="Index594"></A><B>public</B> keyword before the
<B>interface </B>keyword (but only if that <B>interface</B> is defined in a file
of the same name) or leave it off to give
&#8220;<A NAME="Index595"></A>friendly&#8221; status.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make a class that conforms to a
particular <B>interface</B> (or group of <B>interface</B>s) use the
<A NAME="Index596"></A><B>implements</B> keyword. You&#8217;re saying &#8220;The
<B>interface</B> is what it looks like and here&#8217;s how it
<I>works</I>.&#8221; Other than that, it bears a strong resemblance to
inheritance. The diagram for the instrument example shows this:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava110.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you&#8217;ve implemented an
<B>interface</B>, that implementation becomes an ordinary class that can be
extended in the regular way.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can choose to explicitly
declare the method declarations in an <B>interface</B> as <B>public</B>. But
they are <B>public</B> even if you don&#8217;t say it. So when you
<B>implement</B> an <B>interface</B>, the methods from the <B>interface</B> must
be defined as <B>public.</B> Otherwise they would default to
&#8220;friendly&#8221; and you&#8217;d be restricting the accessibility of a
method during inheritance, which is not allowed by the Java
compiler.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see this in the modified
version of the <B>Instrument</B> example. Note that every method in the
<B>interface</B> is strictly a declaration, which is the only thing the compiler
allows. In addition, none of the methods in <B>Instrument5</B> are declared as
<B>public</B>, but they&#8217;re automatically <B>public</B>
anyway:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Music5.java</font>
<font color=#009900>// Interfaces</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>interface</font> Instrument5 {
  <font color=#009900>// Compile-time constant:</font>
  <font color=#0000ff>int</font> i = 5; <font color=#009900>// static &amp; final</font>
  <font color=#009900>// Cannot have method definitions:</font>
  <font color=#0000ff>void</font> play(); <font color=#009900>// Automatically public</font>
  String what();
  <font color=#0000ff>void</font> adjust();
}

<font color=#0000ff>class</font> Wind5 <font color=#0000ff>implements</font> Instrument5 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Wind5.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Wind5"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Percussion5 <font color=#0000ff>implements</font> Instrument5 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Percussion5.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Percussion5"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Stringed5 <font color=#0000ff>implements</font> Instrument5 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Stringed5.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Stringed5"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() {}
}

<font color=#0000ff>class</font> Brass5 <font color=#0000ff>extends</font> Wind5 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Brass5.play()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> adjust() { 
    System.out.println(<font color=#004488>"Brass5.adjust()"</font>);
  }
}

<font color=#0000ff>class</font> Woodwind5 <font color=#0000ff>extends</font> Wind5 {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> play() {
    System.out.println(<font color=#004488>"Woodwind5.play()"</font>);
  }
  <font color=#0000ff>public</font> String what() { <font color=#0000ff>return</font> <font color=#004488>"Woodwind5"</font>; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Music5 {
  <font color=#009900>// Doesn't care about type, so new types</font>
  <font color=#009900>// added to the system still work right:</font>
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> tune(Instrument5 i) {
    <font color=#009900>// ...</font>
    i.play();
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> tuneAll(Instrument5[] e) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; e.length; i++)
      tune(e[i]);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Instrument5[] orchestra = <font color=#0000ff>new</font> Instrument5[5];
    <font color=#0000ff>int</font> i = 0;
    <font color=#009900>// Upcasting during addition to the array:</font>
    orchestra[i++] = <font color=#0000ff>new</font> Wind5();
    orchestra[i++] = <font color=#0000ff>new</font> Percussion5();
    orchestra[i++] = <font color=#0000ff>new</font> Stringed5();
    orchestra[i++] = <font color=#0000ff>new</font> Brass5();
    orchestra[i++] = <font color=#0000ff>new</font> Woodwind5();
    tuneAll(orchestra);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of the code works the
same. It doesn&#8217;t matter if you are <A NAME="Index597"></A>upcasting to a
&#8220;regular&#8221; class called <B>Instrument5</B>, an <B>abstract</B> class
called <B>Instrument5</B>, or to an <A NAME="Index598"></A><B>interface</B>
called <B>Instrument5</B>. The behavior is the same. In fact, you can see in the
<B>tune(&#160;)</B> method that there isn&#8217;t any evidence about whether
<B>Instrument5</B> is a &#8220;regular&#8221; class, an <B>abstract</B> class or
an <B>interface</B>. This is the intent: Each approach gives the programmer
different control over the way objects are created and
used.</FONT><A NAME="_Toc375545336"></A><A NAME="_Toc408018539"></A><BR></P></DIV>
<A NAME="Heading216"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
&#8220;Multiple inheritance&#8221; in Java</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>interface</B> isn&#8217;t
simply a &#8220;more pure&#8221; form of <B>abstract</B> class. It has a higher
purpose than that. Because an <B>interface</B> has no implementation at all
&#8211; that is, there is no storage associated with an <B>interface
</B>&#8211;<B> </B>there&#8217;s nothing to prevent many <B>interface</B>s from
being combined. This is valuable because there are times when you need to say
&#8220;An <B>x</B> is an <B>a</B> <I>and</I> a <B>b</B> <I>and</I> a
<B>c</B>.&#8221; In C++, this act of combining multiple class interfaces is
called <A NAME="Index599"></A><A NAME="Index600"></A><I>multiple
inheritance</I>, and it carries some rather sticky baggage because each class
can have an implementation. In Java, you can perform the same act, but only one
of the classes can have an implementation, so the problems seen in C++ do not
occur with Java when combining multiple interfaces:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava111.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In a derived class, you
aren&#8217;t forced to have a base class that is either an <B>abstract</B> or
&#8220;concrete&#8221; (one with no <B>abstract</B> methods). If you <I>do</I>
inherit from a non-<B>interface</B>,<B> </B>you can inherit from only one. All
the rest of the base elements must be <B>interface</B>s. You place all the
interface names after the <B>implements </B>keyword and separate them with
commas. You can have as many <B>interface</B>s as you want and each one becomes
an independent type that you can upcast to. The following example shows a
concrete class combined with several <B>interface</B>s to produce a new
class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Adventure.java</font>
<font color=#009900>// Multiple interfaces</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>interface</font> CanFight {
  <font color=#0000ff>void</font> fight();
}

<font color=#0000ff>interface</font> CanSwim {
  <font color=#0000ff>void</font> swim();
}

<font color=#0000ff>interface</font> CanFly {
  <font color=#0000ff>void</font> fly();
}

<font color=#0000ff>class</font> ActionCharacter {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> fight() {}
}

<font color=#0000ff>class</font> Hero <font color=#0000ff>extends</font> ActionCharacter 
    <font color=#0000ff>implements</font> CanFight, CanSwim, CanFly {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> swim() {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> fly() {}
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Adventure {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> t(CanFight x) { x.fight(); }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> u(CanSwim x) { x.swim(); }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> v(CanFly x) { x.fly(); }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> w(ActionCharacter x) { x.fight(); }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Hero i = <font color=#0000ff>new</font> Hero();
    t(i); <font color=#009900>// Treat it as a CanFight</font>
    u(i); <font color=#009900>// Treat it as a CanSwim</font>
    v(i); <font color=#009900>// Treat it as a CanFly</font>
    w(i); <font color=#009900>// Treat it as an ActionCharacter</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that <B>Hero</B>
combines the concrete class <B>ActionCharacter</B> with the interfaces
<B>CanFight</B>, <B>CanSwim</B>, and <B>CanFly</B>. When you combine a concrete
class with interfaces this way, the concrete class must come first, then the
interfaces. (The compiler gives an error otherwise.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the signature for
<B>fight(&#160;)</B> is the same in the <B>interface CanFight</B> and the class
<B>ActionCharacter</B>, and that <B>fight(&#160;)</B> is <I>not</I> provided
with a definition in <B>Hero</B>. The rule for an <B>interface</B> is that you
can inherit from it (as you will see shortly), but then you&#8217;ve got another
<B>interface</B>. If you want to create an object of the new type, it must be a
class with all definitions provided. Even though <B>Hero</B> does not explicitly
provide a definition for <B>fight(&#160;)</B>, the definition comes along with
<B>ActionCharacter</B> so it is automatically provided and it&#8217;s possible
to create objects of <B>Hero</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In class <B>Adventure</B>, you can
see that there are four methods that take as arguments the various interfaces
and the concrete class. When a <B>Hero</B> object is created, it can be passed
to any of these methods, which means it is being upcast to each <B>interface</B>
in turn. Because of the way interfaces are designed in Java, this works without
a hitch and without any particular effort on the part of the
programmer.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Keep in mind that the core reason
for interfaces is shown in the above example: to be able to upcast to more than
one base type. However, a second reason for using interfaces is the same as
using an <B>abstract </B>base class: to prevent the client programmer from
making an object of this class and to establish that it is only an interface.
This brings up a question: Should you use an
<A NAME="Index601"></A><A NAME="Index602"></A><B>interface</B> or an
<B>abstract</B> class? An <B>interface</B> gives you the benefits of an
<B>abstract</B> class <I>and</I> the benefits of an <B>interface</B>, so if
it&#8217;s possible to create your base class without any method definitions or
member variables you should always prefer <B>interface</B>s to <B>abstract</B>
classes. In fact, if you know something is going to be a base class, your first
choice should be to make it an <B>interface</B>, and only if you&#8217;re forced
to have method definitions or member variables should you change to an
<B>abstract</B>
class.</FONT><A NAME="_Toc375545337"></A><A NAME="_Toc408018540"></A><BR></P></DIV>
<A NAME="Heading217"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Extending an interface <BR>with inheritance</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can easily add new method
declarations to an
<A NAME="Index603"></A><A NAME="Index604"></A><B>interface</B> using
inheritance, and you can also combine several <B>interface</B>s into a new
<B>interface</B> with inheritance. In both cases you get a new <B>interface</B>,
as seen in this example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: HorrorShow.java</font>
<font color=#009900>// Extending an interface with inheritance</font>

<font color=#0000ff>interface</font> Monster {
  <font color=#0000ff>void</font> menace();
}

<font color=#0000ff>interface</font> DangerousMonster <font color=#0000ff>extends</font> Monster {
  <font color=#0000ff>void</font> destroy();
}

<font color=#0000ff>interface</font> Lethal {
  <font color=#0000ff>void</font> kill();
}

<font color=#0000ff>class</font> DragonZilla <font color=#0000ff>implements</font> DangerousMonster {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> menace() {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> destroy() {}
}

<font color=#0000ff>interface</font> Vampire 
    <font color=#0000ff>extends</font> DangerousMonster, Lethal {
  <font color=#0000ff>void</font> drinkBlood();
}

<font color=#0000ff>class</font> HorrorShow {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> u(Monster b) { b.menace(); }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> v(DangerousMonster d) {
    d.menace();
    d.destroy();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    DragonZilla if2 = <font color=#0000ff>new</font> DragonZilla();
    u(if2);
    v(if2);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DangerousMonster</B> is a simple
extension to <B>Monster</B> that produces a new <B>interface</B>. This is
implemented in <B>DragonZilla</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The syntax used in <B>Vampire</B>
works <I>only</I> when inheriting interfaces. Normally, you can use
<A NAME="Index605"></A><B>extends</B> with only a single class, but since an
<B>interface</B> can be made from multiple other interfaces, <B>extends</B> can
refer to multiple base interfaces when building a new <B>interface</B>. As you
can see, the <B>interface</B> names are simply separated with
commas.</FONT><A NAME="_Toc375545338"></A><A NAME="_Toc408018541"></A><BR></P></DIV>
<A NAME="Heading218"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Grouping constants</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because any fields you put into an
<B>interface</B> are automatically <B>static</B> and <B>final</B>, the
<B>interface</B> is a convenient tool for
<A NAME="Index606"></A><A NAME="Index607"></A>creating groups of constant
values, much as you would with an <B>enum</B> in C or C++. For
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Months.java</font>
<font color=#009900>// Using interfaces to create groups of constants</font>
<font color=#0000ff>package</font> c07;

<font color=#0000ff>public</font> <font color=#0000ff>interface</font> Months {
  <font color=#0000ff>int</font>
    JANUARY = 1, FEBRUARY = 2, MARCH = 3, 
    APRIL = 4, MAY = 5, JUNE = 6, JULY = 7, 
    AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,
    NOVEMBER = 11, DECEMBER = 12;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice the Java style of using all
uppercase letters (with underscores to separate multiple words in a single
identifier) for <B>static</B> <B>final</B> primitives that have constant
initializers &#8211; that is, for compile-time constants.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fields in an <B>interface
</B>are automatically <B>public</B>, so it&#8217;s unnecessary to specify
that.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now you can use the constants from
outside the package by importing <B>c07.*</B> or <B>c07.Months</B> just as you
would with any other package, and referencing the values with expressions like
<B>Months.JANUARY</B>. Of course, what you get is just an <B>int</B> so there
isn&#8217;t the extra type safety that C++&#8217;s <B>enum</B> has, but this
(commonly-used) technique is certainly an improvement over hard-coding numbers
into your programs. (This is often referred to as using &#8220;magic
numbers&#8221; and it produces very difficult-to-maintain
code.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you do want extra type safety,
you can build a class like
this:</FONT><A NAME="fnB28" HREF="#fn28">[28]</A><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Month2.java</font>
<font color=#009900>// A more robust enumeration system</font>
<font color=#0000ff>package</font> c07;

<font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>class</font> Month2 {
  <font color=#0000ff>private</font> String name;
  <font color=#0000ff>private</font> Month2(String nm) { name = nm; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> name; }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> Month2
    JAN = <font color=#0000ff>new</font> Month2(<font color=#004488>"January"</font>), 
    FEB = <font color=#0000ff>new</font> Month2(<font color=#004488>"February"</font>),
    MAR = <font color=#0000ff>new</font> Month2(<font color=#004488>"March"</font>),
    APR = <font color=#0000ff>new</font> Month2(<font color=#004488>"April"</font>),
    MAY = <font color=#0000ff>new</font> Month2(<font color=#004488>"May"</font>),
    JUN = <font color=#0000ff>new</font> Month2(<font color=#004488>"June"</font>),
    JUL = <font color=#0000ff>new</font> Month2(<font color=#004488>"July"</font>),
    AUG = <font color=#0000ff>new</font> Month2(<font color=#004488>"August"</font>),
    SEP = <font color=#0000ff>new</font> Month2(<font color=#004488>"September"</font>),
    OCT = <font color=#0000ff>new</font> Month2(<font color=#004488>"October"</font>),
    NOV = <font color=#0000ff>new</font> Month2(<font color=#004488>"November"</font>),
    DEC = <font color=#0000ff>new</font> Month2(<font color=#004488>"December"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> Month2[] month =  {
    JAN, JAN, FEB, MAR, APR, MAY, JUN,
    JUL, AUG, SEP, OCT, NOV, DEC
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Month2 m = Month2.JAN;
    System.out.println(m);
    m = Month2.month[12];
    System.out.println(m);
    System.out.println(m == Month2.DEC);
    System.out.println(m.equals(Month2.DEC));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class is called <B>Month2</B>
since there&#8217;s already a <B>Month</B> in the standard Java library.
It&#8217;s a <B>final</B> class with a <B>private</B> constructor so no one can
inherit from it or make any instances of it. The only instances are the <B>final
static</B> ones created in the class itself: <B>JAN</B>, <B>FEB</B>, <B>MAR</B>,
etc. These objects are also used in the array <B>month</B>, which lets you
choose months by number instead of by name. (Notice the extra <B>JAN</B> in the
array to provide an offset by one, so that December is month 12.) In
<B>main(&#160;)</B> you can see the <A NAME="Index608"></A>type safety: <B>m</B>
is a <B>Month2</B> object so it can be assigned only to a <B>Month2</B>. The
previous example <B>Months.java </B>provided only <B>int</B> values, so an
<B>int</B> variable intended to represent a month could actually be given any
integer value, which wasn&#8217;t too safe.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This approach also allows you to
use <B>==</B> or <B>equals(&#160;)</B> interchangeably, as shown at the end of
<B>main(&#160;)</B>.</FONT><A NAME="_Toc408018542"></A><BR></P></DIV>
<A NAME="Heading219"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Initializing fields in
interfaces<BR><A NAME="Index609"></A><A NAME="Index610"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Fields defined in interfaces are
automatically <B>static</B> and <B>final</B>. These cannot be &#8220;blank
finals,&#8221; but they can be initialized with non-constant expressions. For
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: RandVals.java</font>
<font color=#009900>// Initializing interface fields with </font>
<font color=#009900>// non-constant initializers</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>interface</font> RandVals {
  <font color=#0000ff>int</font> rint = (<font color=#0000ff>int</font>)(Math.random() * 10);
  <font color=#0000ff>long</font> rlong = (<font color=#0000ff>long</font>)(Math.random() * 10);
  <font color=#0000ff>float</font> rfloat = (<font color=#0000ff>float</font>)(Math.random() * 10);
  <font color=#0000ff>double</font> rdouble = Math.random() * 10;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since the fields are <B>static</B>,
they are initialized when the class is first loaded, upon first access of any of
the fields. Here&#8217;s a simple test:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: TestRandVals.java</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestRandVals {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(RandVals.rint);
    System.out.println(RandVals.rlong);
    System.out.println(RandVals.rfloat);
    System.out.println(RandVals.rdouble);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fields, of course, are not part
of the interface but instead are stored in the <B>static</B> storage area for
that interface.</FONT><A NAME="_Toc408018543"></A><BR></P></DIV>
<A NAME="Heading220"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Inner classes</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Java 1.1<A NAME="Index611"></A>
it&#8217;s possible to place a class definition within another class definition.
This is called an <I>inner class</I>. The
<A NAME="Index612"></A><A NAME="Index613"></A>inner class is a useful feature
because it allows you to group classes that logically belong together and to
control the visibility of one within the other. However, it&#8217;s important to
understand that inner classes are distinctly different from
composition.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Often, while you're learning about
them, the need for inner classes isn&#8217;t immediately obvious. At the end of
this section, after all of the syntax and semantics of inner classes have been
described, you&#8217;ll find an example that should make clear the benefits of
inner classes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You create an inner class just as
you&#8217;d expect: by placing the class definition inside a surrounding class:
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel1.java</font>
<font color=#009900>// Creating inner classes</font>
<font color=#0000ff>package</font> c07.parcel1;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel1 {
  <font color=#0000ff>class</font> Contents {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 11;
    <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() { <font color=#0000ff>return</font> i; }
  }
  <font color=#0000ff>class</font> Destination {
    <font color=#0000ff>private</font> String label;
    Destination(String whereTo) {
      label = whereTo;
    }
    String readLabel() { <font color=#0000ff>return</font> label; }
  }
  <font color=#009900>// Using inner classes looks just like</font>
  <font color=#009900>// using any other class, within Parcel1:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> ship(String dest) {
    Contents c = <font color=#0000ff>new</font> Contents();
    Destination d = <font color=#0000ff>new</font> Destination(dest);
  }  
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel1 p = <font color=#0000ff>new</font> Parcel1();
    p.ship(<font color=#004488>"Tanzania"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The inner classes, when used inside
<B>ship(&#160;)</B>, look just like the use of any other classes. Here, the only
practical difference is that the names are nested within <B>Parcel1</B>.
You&#8217;ll see in a while that this isn&#8217;t the only
difference.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">More typically, an outer class will
have a method that returns a handle to an inner class, like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel2.java</font>
<font color=#009900>// Returning a handle to an inner class</font>
<font color=#0000ff>package</font> c07.parcel2;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel2 {
  <font color=#0000ff>class</font> Contents {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 11;
    <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() { <font color=#0000ff>return</font> i; }
  }
  <font color=#0000ff>class</font> Destination {
    <font color=#0000ff>private</font> String label;
    Destination(String whereTo) {
      label = whereTo;
    }
    String readLabel() { <font color=#0000ff>return</font> label; }
  }
  <font color=#0000ff>public</font> Destination to(String s) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Destination(s);
  }
  <font color=#0000ff>public</font> Contents cont() { 
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Contents(); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> ship(String dest) {
    Contents c = cont();
    Destination d = to(dest);
  }  
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel2 p = <font color=#0000ff>new</font> Parcel2();
    p.ship(<font color=#004488>"Tanzania"</font>);
    Parcel2 q = <font color=#0000ff>new</font> Parcel2();
    <font color=#009900>// Defining handles to inner classes:</font>
    Parcel2.Contents c = q.cont();
    Parcel2.Destination d = q.to(<font color=#004488>"Borneo"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to make an object of
the inner class anywhere except from within a non-<B>static</B> method of the
outer class, you must specify the type of that object as
<I>OuterClassName.InnerClassName</I>, as seen in
<B>main(&#160;)</B>.</FONT><A NAME="_Toc408018544"></A><BR></P></DIV>
<A NAME="Heading221"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Inner classes and
upcasting<BR><A NAME="Index614"></A><A NAME="Index615"></A><A NAME="Index616"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So far, inner classes don&#8217;t
seem that dramatic. After all, if it&#8217;s hiding you&#8217;re after, Java
already has a perfectly good hiding mechanism &#8211; just allow the class to be
&#8220;<A NAME="Index617"></A>friendly&#8221; (visible only within a
<A NAME="Index618"></A><A NAME="Index619"></A>package) rather than creating it
as an inner class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index620"></A><FONT FACE="Georgia">However,
inner classes really come into their own when you start upcasting to a base
class, and in particular to an <B>interface.</B> (The effect of producing an
interface handle from an object that implements it is essentially the same as
upcasting to a base class.) That&#8217;s because the inner class can then be
completely unseen and unavailable to anyone, which is convenient for hiding the
implementation. All you get back is a handle to the base class or the
<B>interface,</B> and it&#8217;s possible that you can&#8217;t even find out the
exact type, as shown here:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel3.java</font>
<font color=#009900>// Returning a handle to an inner class</font>
<font color=#0000ff>package</font> c07.parcel3;

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Contents {
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>int</font> value();
}

<font color=#0000ff>interface</font> Destination {
  String readLabel();
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel3 {
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> PContents <font color=#0000ff>extends</font> Contents {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 11;
    <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() { <font color=#0000ff>return</font> i; }
  }
  <font color=#0000ff>protected</font> <font color=#0000ff>class</font> PDestination
      <font color=#0000ff>implements</font> Destination {
    <font color=#0000ff>private</font> String label;
    <font color=#0000ff>private</font> PDestination(String whereTo) {
      label = whereTo;
    }
    <font color=#0000ff>public</font> String readLabel() { <font color=#0000ff>return</font> label; }
  }
  <font color=#0000ff>public</font> Destination dest(String s) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> PDestination(s);
  }
  <font color=#0000ff>public</font> Contents cont() { 
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> PContents(); 
  }
}

<font color=#0000ff>class</font> Test {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel3 p = <font color=#0000ff>new</font> Parcel3();
    Contents c = p.cont();
    Destination d = p.dest(<font color=#004488>"Tanzania"</font>);
    <font color=#009900>// Illegal -- can't access private class:</font>
    <font color=#009900>//! Parcel3.PContents c = p.new PContents();</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now <B>Contents</B> and
<B>Destination</B> represent interfaces available to the client programmer. (The
<B>interface</B>, remember, automatically makes all of its members
<B>public.</B>) For convenience, these are placed inside a single file, but
ordinarily <B>Contents</B> and <B>Destination</B> would each be <B>public </B>in
their own files.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Parcel3</B>, something new
has been added: the inner class <B>PContents</B> is <B>private </B>so no one but
<B>Parcel3</B> can access it. <B>PDestination</B> is <B>protected</B>, so no one
but <B>Parcel3</B>, classes in the <B>Parcel3</B> package (since
<B>protected</B> also gives package access; that is, <B>protected</B> is also
&#8220;friendly&#8221;), and the inheritors of <B>Parcel3 </B>can access
<B>PDestination</B>. This means that the client programmer has restricted
knowledge and access to these members. In fact, you can&#8217;t even downcast to
a <B>private</B> inner class (or a <B>protected</B> inner class unless
you&#8217;re an inheritor), because you can&#8217;t access the name, as you can
see in <B>class Test</B>. Thus, the <B>private</B> inner class provides a way
for the class designer to completely prevent any type-coding dependencies and to
completely hide details about implementation. In addition, extension of an
<B>interface</B> is useless from the client programmer&#8217;s perspective since
the client programmer cannot access any additional methods that aren&#8217;t
part of the public <B>interface</B> class. This also provides an opportunity for
the Java compiler to generate more efficient code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Normal (non-inner) classes cannot
be made <B>private</B> or <B>protected </B>&#8211; only <B>public</B> or
&#8220;friendly.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>Contents</B>
doesn&#8217;t need to be an <B>abstract</B> class. You could use an ordinary
class here as well, but the most typical starting point for such a design is an
<B>interface</B>.</FONT><A NAME="_Toc408018545"></A><BR></P></DIV>
<A NAME="Heading222"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Inner classes in methods and
scopes<BR><A NAME="Index621"></A><A NAME="Index622"></A><A NAME="Index623"></A><A NAME="Index624"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What you&#8217;ve seen so far
encompasses the typical use for inner classes. In general, the code that
you&#8217;ll write and read involving inner classes will be &#8220;plain&#8221;
inner classes that are simple and easy to understand. However, the design for
inner classes is quite complete and there are a number of other, more obscure,
ways that you can use them if you choose: inner classes can be created within a
method or even an arbitrary scope. There are two reasons for doing
this:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	As shown previously, you&#8217;re implementing
an interface of some kind so that you can create and return a
handle.</FONT><LI><FONT FACE="Georgia">	You&#8217;re solving a complicated
problem and you want to create a class to aid in your solution, but you
don&#8217;t want it publicly
available.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the
following examples, the previous code will be modified to use:
<A NAME="Index625"></A><A NAME="Index626"></A><A NAME="Index627"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	A class defined within a method
</FONT><LI><FONT FACE="Georgia">	A class defined within a scope inside a
method</FONT><LI><FONT FACE="Georgia">	An anonymous class implementing an
<B>interface</B></FONT><LI><FONT FACE="Georgia">	An anonymous class
extending a class that has a non-default
constructor</FONT><LI><FONT FACE="Georgia">	An anonymous class that
performs field initialization</FONT><LI><FONT FACE="Georgia">	An anonymous
class that performs construction using instance initialization (anonymous inner
classes cannot have
constructors)</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This will
all take place within the package <B>innerscopes</B>. First, the common
interfaces from the previous code will be defined in their own files so they can
be used in all the examples:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Destination.java</font>
<font color=#0000ff>package</font> c07.innerscopes;

<font color=#0000ff>interface</font> Destination {
  String readLabel();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The point has been made that
<B>Contents</B> could be an <B>abstract</B> class, so here it will be in a more
natural form, as an <B>interface</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Contents.java</font>
<font color=#0000ff>package</font> c07.innerscopes;

<font color=#0000ff>interface</font> Contents {
  <font color=#0000ff>int</font> value();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although it&#8217;s an ordinary
class with an implementation, <B>Wrapping</B> is also being used as a common
&#8220;interface&#8221; to its derived classes:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Wrapping.java</font>
<font color=#0000ff>package</font> c07.innerscopes;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Wrapping {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>public</font> Wrapping(<font color=#0000ff>int</font> x) { i = x; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() { <font color=#0000ff>return</font> i; }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice above that
<B>Wrapping</B> has a constructor that requires an argument, to make things a
bit more interesting.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first example shows the
creation of an entire class within the scope of a method (instead of the scope
of another class):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel4.java</font>
<font color=#009900>// Nesting a class within a method</font>
<font color=#0000ff>package</font> c07.innerscopes;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel4 {
  <font color=#0000ff>public</font> Destination dest(String s) {
    <font color=#0000ff>class</font> PDestination
        <font color=#0000ff>implements</font> Destination {
      <font color=#0000ff>private</font> String label;
      <font color=#0000ff>private</font> PDestination(String whereTo) {
        label = whereTo;
      }
      <font color=#0000ff>public</font> String readLabel() { <font color=#0000ff>return</font> label; }
    }
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> PDestination(s);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel4 p = <font color=#0000ff>new</font> Parcel4();
    Destination d = p.dest(<font color=#004488>"Tanzania"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class <B>PDestination</B> is
part of <B>dest(&#160;)</B> rather than being part of <B>Parcel4.</B> (Also
notice that you could use the class identifier <B>PDestination </B>for an inner
class inside each class in the same subdirectory without a name clash.)
Therefore, <B>PDestination </B>cannot be accessed outside of
<B>dest(&#160;)</B>.<B> </B>Notice the upcasting that occurs in the return
statement &#8211; nothing comes out of <B>dest(&#160;)</B> except a handle to
the base class <B>Destination</B>. Of course, the fact that the name of the
class <B>PDestination</B> is placed inside <B>dest(&#160;)</B> doesn&#8217;t
mean that <B>PDestination</B> is not a valid object once <B>dest(&#160;)</B>
returns.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next example shows how you can
nest an
<A NAME="Index628"></A><A NAME="Index629"></A><A NAME="Index630"></A>inner class
within any arbitrary scope:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel5.java</font>
<font color=#009900>// Nesting a class within a scope</font>
<font color=#0000ff>package</font> c07.innerscopes;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel5 {
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> internalTracking(<font color=#0000ff>boolean</font> b) {
    <font color=#0000ff>if</font>(b) {
      <font color=#0000ff>class</font> TrackingSlip {
        <font color=#0000ff>private</font> String id;
        TrackingSlip(String s) {
          id = s;
        }
        String getSlip() { <font color=#0000ff>return</font> id; }
      }
      TrackingSlip ts = <font color=#0000ff>new</font> TrackingSlip(<font color=#004488>"slip"</font>);
      String s = ts.getSlip();
    }
    <font color=#009900>// Can't use it here! Out of scope:</font>
    <font color=#009900>//! TrackingSlip ts = new TrackingSlip("x");</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> track() { internalTracking(<font color=#0000ff>true</font>); }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel5 p = <font color=#0000ff>new</font> Parcel5();
    p.track();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class <B>TrackingSlip</B> is
nested inside the scope of an <B>if</B> statement. This does not mean that the
class is conditionally created &#8211; it gets compiled along with everything
else. However, it&#8217;s not available outside the scope in which it is
defined.<B> </B>Other than that, it looks just like an ordinary
class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next example looks a little
strange:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel6.java</font>
<font color=#009900>// A method that returns an anonymous inner class</font>
<font color=#0000ff>package</font> c07.innerscopes;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel6 {
  <font color=#0000ff>public</font> Contents cont() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Contents() {
      <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 11;
      <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() { <font color=#0000ff>return</font> i; }
    }; <font color=#009900>// Semicolon required in this case</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel6 p = <font color=#0000ff>new</font> Parcel6();
    Contents c = p.cont();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>cont(&#160;)</B> method
combines the creation of the return value with the definition of the class that
represents that return value! In addition, the class is anonymous &#8211; it has
no name. To make matters a bit worse, it looks like you&#8217;re starting out to
create a <B>Contents</B> object:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>return</font> <font color=#0000ff>new</font> Contents()</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">but then, before you get to the
semicolon, you say, &#8220;But wait, I think I&#8217;ll slip in a class
definition&#8221;:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>return</font> <font color=#0000ff>new</font> Contents() {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 11;
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() { <font color=#0000ff>return</font> i; }
};</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What this strange syntax means is
&#8220;create an object of an anonymous class that&#8217;s inherited from
<B>Contents</B>.&#8221; The handle returned by the <B>new</B> expression is
automatically upcast to a <B>Contents</B> handle. The anonymous inner class
syntax is a shorthand for:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> MyContents <font color=#0000ff>extends</font> Contents {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 11;
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() { <font color=#0000ff>return</font> i; }
}
<font color=#0000ff>return</font> <font color=#0000ff>new</font> MyContents();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the anonymous inner class,
<B>Contents</B> is created using a default constructor. The following code shows
what to do if your base class needs a constructor with an
argument:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel7.java</font>
<font color=#009900>// An anonymous inner class that calls the </font>
<font color=#009900>// base-class constructor</font>
<font color=#0000ff>package</font> c07.innerscopes;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel7 {
  <font color=#0000ff>public</font> Wrapping wrap(<font color=#0000ff>int</font> x) {
    <font color=#009900>// Base constructor call:</font>
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Wrapping(x) { 
      <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() {
        <font color=#0000ff>return</font> <font color=#0000ff>super</font>.value() * 47;
      }
    }; <font color=#009900>// Semicolon required</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel7 p = <font color=#0000ff>new</font> Parcel7();
    Wrapping w = p.wrap(10);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That is, you simply pass the
appropriate argument to the base-class constructor, seen here as the <B>x
</B>passed in <B>new Wrapping(x)</B>. An anonymous class cannot have a
constructor where you would normally call <B>super(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In both of the previous examples,
the semicolon doesn&#8217;t mark the end of the class body (as it does in C++).
Instead, it marks the end of the expression that happens to contain the
anonymous class. Thus, it&#8217;s identical to the use of the semicolon
everywhere else.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What happens if you need to perform
some kind of initialization for an object of an
<A NAME="Index631"></A><A NAME="Index632"></A><A NAME="Index633"></A>anonymous
inner class? Since it&#8217;s anonymous, there&#8217;s no name to give the
constructor so you can&#8217;t have a constructor. You can, however, perform
initialization at the point of definition of your fields:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel8.java</font>
<font color=#009900>// An anonymous inner class that performs </font>
<font color=#009900>// initialization. A briefer version</font>
<font color=#009900>// of Parcel5.java.</font>
<font color=#0000ff>package</font> c07.innerscopes;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel8 {
  <font color=#009900>// Argument must be final to use inside </font>
  <font color=#009900>// anonymous inner class:</font>
  <font color=#0000ff>public</font> Destination dest(<font color=#0000ff>final</font> String dest) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Destination() {
      <font color=#0000ff>private</font> String label = dest;
      <font color=#0000ff>public</font> String readLabel() { <font color=#0000ff>return</font> label; }
    };
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel8 p = <font color=#0000ff>new</font> Parcel8();
    Destination d = p.dest(<font color=#004488>"Tanzania"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re defining an
anonymous inner class and want to use an object that&#8217;s defined outside the
anonymous inner class, the compiler requires that the outside object be
<B>final</B>. This is why the argument to <B>dest(&#160;) </B>is
<B>final</B>.<B> </B>If you forget, you&#8217;ll get a compile-time error
message.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As long as you&#8217;re simply
assigning a field, the above approach is fine. But what if you need to perform
some constructor-like activity? With Java 1.1<A NAME="Index634"></A>
<A NAME="Index635"></A><A NAME="Index636"></A><I>instance initialization</I>,
you can, in effect, create a constructor for an anonymous inner
class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel9.java</font>
<font color=#009900>// Using "instance initialization" to perform </font>
<font color=#009900>// construction on an anonymous inner class</font>
<font color=#0000ff>package</font> c07.innerscopes;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel9 {
  <font color=#0000ff>public</font> Destination 
  dest(<font color=#0000ff>final</font> String dest, <font color=#0000ff>final</font> <font color=#0000ff>float</font> price) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Destination() {
      <font color=#0000ff>private</font> <font color=#0000ff>int</font> cost;
      <font color=#009900>// Instance initialization for each object:</font>
      {
        cost = Math.round(price);
        <font color=#0000ff>if</font>(cost &gt; 100)
          System.out.println(<font color=#004488>"Over budget!"</font>);
      }
      <font color=#0000ff>private</font> String label = dest;
      <font color=#0000ff>public</font> String readLabel() { <font color=#0000ff>return</font> label; }
    };
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel9 p = <font color=#0000ff>new</font> Parcel9();
    Destination d = p.dest(<font color=#004488>"Tanzania"</font>, 101.395F);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Inside the instance initializer you
can see code that couldn&#8217;t be executed as part of a field initializer
(that is, the <B>if</B> statement). So in effect, an instance initializer is the
constructor for an anonymous inner class. Of course, it&#8217;s limited; you
can&#8217;t overload instance initializers so you can have only one of these
constructors.</FONT><A NAME="_Toc408018546"></A><BR></P></DIV>
<A NAME="Heading223"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The link to the outer class</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So far, it appears that inner
classes are just a name-hiding and code-organization scheme, which is helpful
but not totally compelling. However, there&#8217;s another twist. When you
create an inner class, objects of that inner class have a link to the enclosing
object that made them, and so they can access the members of that enclosing
object &#8211; <I>without </I>any special qualifications. In addition,
<A NAME="Index637"></A><A NAME="Index638"></A><A NAME="Index639"></A>inner
classes have access rights to all the elements in the enclosing
class.</FONT><A NAME="fnB29" HREF="#fn29">[29]</A><FONT FACE="Georgia">
The following example demonstrates this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Sequence.java</font>
<font color=#009900>// Holds a sequence of Objects</font>

<font color=#0000ff>interface</font> Selector {
  <font color=#0000ff>boolean</font> end();
  Object current();
  <font color=#0000ff>void</font> next();
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Sequence {
  <font color=#0000ff>private</font> Object[] o;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> next = 0;
  <font color=#0000ff>public</font> Sequence(<font color=#0000ff>int</font> size) {
    o = <font color=#0000ff>new</font> Object[size];
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> add(Object x) {
    <font color=#0000ff>if</font>(next &lt; o.length) {
      o[next] = x;
      next++;
    }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> SSelector <font color=#0000ff>implements</font> Selector {
    <font color=#0000ff>int</font> i = 0;
    <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> end() {
      <font color=#0000ff>return</font> i == o.length;
    }
    <font color=#0000ff>public</font> Object current() {
      <font color=#0000ff>return</font> o[i];
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> next() {
      <font color=#0000ff>if</font>(i &lt; o.length) i++;
    }
  }
  <font color=#0000ff>public</font> Selector getSelector() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> SSelector();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Sequence s = <font color=#0000ff>new</font> Sequence(10);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      s.add(Integer.toString(i));
    Selector sl = s.getSelector();    
    <font color=#0000ff>while</font>(!sl.end()) {
      System.out.println((String)sl.current());
      sl.next();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Sequence</B> is simply a
fixed-sized array of <B>Object</B> with a class wrapped around it. You call
<B>add(&#160;)</B> to add a new <B>Object</B> to the end of the sequence (if
there&#8217;s room left). To fetch each of the objects in a <B>Sequence</B>,
there&#8217;s an interface called <B>Selector</B>, which allows you to see if
you&#8217;re at the <B>end(&#160;)</B>, to look at the <B>current(&#160;)</B>
<B>Object</B>, and to move to the <B>next(&#160;)</B> <B>Object</B> in the
<B>Sequence</B>. Because <B>Selector</B> is an <B>interface</B>, many other
classes can implement the <B>interface</B> in their own ways, and many methods
can take the <B>interface</B> as an argument, in order to create generic
code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, the <B>SSelector</B> is a
private class that provides <B>Selector</B> functionality. In
<B>main(&#160;)</B>, you can see the creation of a <B>Sequence</B>, followed by
the addition of a number of <B>String</B> objects. Then, a <B>Selector</B> is
produced with a call to <B>getSelector(&#160;)</B> and this is used to move
through the <B>Sequence</B> and select each item.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At first, the creation of
<B>SSelector</B> looks like just another inner class. But examine it closely.
Note that each of the methods <B>end(&#160;)</B>, <B>current(&#160;),</B> and
<B>next(&#160;)</B> refer to <B>o</B>, which is a handle that isn&#8217;t part
of <B>SSelector</B>, but is instead a <B>private </B>field in the enclosing
class. However, the inner class can access methods and fields from the enclosing
class as if they owned them. This turns out to be very convenient, as you can
see in the above example.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So an inner class has access to the
members of the enclosing class. How can this happen? The
<A NAME="Index640"></A>inner class must keep a reference to the particular
object of the enclosing class that was responsible for creating it. Then when
you refer to a member of the enclosing class, that (hidden) reference is used to
select that member. Fortunately, the compiler takes care of all these details
for you, but you can also understand now that an object of an inner class can be
created only in association with an object of the enclosing class. The process
of construction requires the initialization of the handle to the object of the
enclosing class, and the compiler will complain if it cannot access the handle.
Most of the time this occurs without any intervention on the part of the
programmer.</FONT><A NAME="_Toc408018547"></A><BR></P></DIV>
<A NAME="Heading224"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
static inner classes</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To understand the meaning of
<A NAME="Index641"></A><A NAME="Index642"></A><B>static</B> when applied to
inner classes, you must remember that the object of the inner class implicitly
keeps a handle to the object of the enclosing class that created it. This is not
true, however, when you say an inner class is <B>static</B>. A <B>static
</B>inner class means:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	You don&#8217;t need an outer-class object in
order to create an object of a <B>static</B> inner
class.</FONT><LI><FONT FACE="Georgia">	You can&#8217;t access an
outer-class object from an object of a <B>static</B> inner
class.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are some
restrictions: <B>static</B> members can be at only the outer level of a class,
so inner classes cannot have <B>static</B> data or <B>static</B> inner
classes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index643"></A><A NAME="Index644"></A><A NAME="Index645"></A><FONT FACE="Georgia">If
you don&#8217;t need to create an object of the outer class in order to create
an object of the inner class, you can make everything <B>static</B>. For this to
work, you must also make the inner classes <B>static</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel10.java</font>
<font color=#009900>// Static inner classes</font>
<font color=#0000ff>package</font> c07.parcel10;

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Contents {
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>int</font> value();
}

<font color=#0000ff>interface</font> Destination {
  String readLabel();
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel10 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> PContents 
  <font color=#0000ff>extends</font> Contents {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 11;
    <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() { <font color=#0000ff>return</font> i; }
  }
  <font color=#0000ff>protected</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> PDestination
      <font color=#0000ff>implements</font> Destination {
    <font color=#0000ff>private</font> String label;
    <font color=#0000ff>private</font> PDestination(String whereTo) {
      label = whereTo;
    }
    <font color=#0000ff>public</font> String readLabel() { <font color=#0000ff>return</font> label; }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Destination dest(String s) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> PDestination(s);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Contents cont() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> PContents();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Contents c = cont();
    Destination d = dest(<font color=#004488>"Tanzania"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, no object
of <B>Parcel10</B> is necessary; instead you use the normal syntax for selecting
a <B>static</B> member to call the methods that return handles to
<B>Contents</B> and <B>Destination</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Normally you can't put any code
inside an <B>interface</B>, but a <B>static</B> inner class can be part of an
<B>interface</B>. Since the class is <B>static </B>it doesn't violate the rules
for interfaces &#8211; the <B>static </B>inner class is only placed inside the
namespace of the interface:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: IInterface.java</font>
<font color=#009900>// Static inner classes inside interfaces</font>

<font color=#0000ff>interface</font> IInterface {
  <font color=#0000ff>static</font> <font color=#0000ff>class</font> Inner {
    <font color=#0000ff>int</font> i, j, k;
    <font color=#0000ff>public</font> Inner() {}
    <font color=#0000ff>void</font> f() {}
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Earlier in the book I suggested
putting a <B>main(&#160;) </B>in every class to act as a
test<A NAME="Index646"></A> bed for that class. One drawback to this is the
amount of extra code you must carry around. If this is a problem, you can use a
<B>static</B> inner class to hold your test code:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: TestBed.java</font>
<font color=#009900>// Putting test code in a static inner class</font>

<font color=#0000ff>class</font> TestBed {
  TestBed() {}
  <font color=#0000ff>void</font> f() { System.out.println(<font color=#004488>"f()"</font>); }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
      TestBed t = <font color=#0000ff>new</font> TestBed();
      t.f();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This generates a separate class
called <B>TestBed$Tester</B> (to run the program you say <B>java
TestBed$Tester</B>). You can use this class for testing, but you don't need to
include it in your shipping
product.</FONT><A NAME="_Toc408018548"></A><BR></P></DIV>
<A NAME="Heading225"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Referring to the outer class
object<BR><A NAME="Index647"></A><A NAME="Index648"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you need to produce the handle
to the outer class object, you name the outer class followed by a dot and
<B>this</B>. For example, in the class <B>Sequence.SSelector</B>, any of its
methods can produce the stored handle to the outer class <B>Sequence</B> by
saying <B>Sequence.this</B>. The resulting handle is automatically the correct
type. (This is known and checked at compile time, so there is no run-time
overhead.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sometimes you want to tell some
other object to create an object of one of its inner classes. To do this you
must provide a handle to the other outer class object in the <B>new</B>
expression, like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Parcel11.java</font>
<font color=#009900>// Creating inner classes</font>
<font color=#0000ff>package</font> c07.parcel11;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Parcel11 {
  <font color=#0000ff>class</font> Contents {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 11;
    <font color=#0000ff>public</font> <font color=#0000ff>int</font> value() { <font color=#0000ff>return</font> i; }
  }
  <font color=#0000ff>class</font> Destination {
    <font color=#0000ff>private</font> String label;
    Destination(String whereTo) {
      label = whereTo;
    }
    String readLabel() { <font color=#0000ff>return</font> label; }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Parcel11 p = <font color=#0000ff>new</font> Parcel11();
    <font color=#009900>// Must use instance of outer class</font>
    <font color=#009900>// to create an instances of the inner class:</font>
    Parcel11.Contents c = p.<font color=#0000ff>new</font> Contents();
    Parcel11.Destination d =
      p.<font color=#0000ff>new</font> Destination(<font color=#004488>"Tanzania"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To create an object of the inner
class directly, you don&#8217;t follow the same form and refer to the outer
class name <B>Parcel11</B> as you might expect, but instead you must use an
<I>object</I> of the outer class to make an object of the inner
class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Parcel11.Contents c = p.<font color=#0000ff>new</font> Contents();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, it&#8217;s not possible to
create an object of the inner class unless you already have an object of the
outer class. This is because the object of the inner class is quietly connected
to the object of the outer class that it was made from. However, if you make a
<B>static</B> inner class, then it doesn&#8217;t need a handle to the outer
class object.</FONT><A NAME="_Toc408018549"></A><BR></P></DIV>
<A NAME="Heading226"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Inheriting from inner
classes<BR><A NAME="Index649"></A><A NAME="Index650"></A><A NAME="Index651"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because the inner class constructor
must attach to a handle of the enclosing class object, things are slightly
complicated when you inherit from an inner class. The problem is that the
&#8220;secret&#8221; handle to the enclosing class object <I>must</I> be
initialized, and yet in the derived class there&#8217;s no longer a default
object to attach to. The answer is to use a syntax provided to make the
association explicit:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: InheritInner.java</font>
<font color=#009900>// Inheriting an inner class</font>

<font color=#0000ff>class</font> WithInner {
  <font color=#0000ff>class</font> Inner {}
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> InheritInner 
    <font color=#0000ff>extends</font> WithInner.Inner {
  <font color=#009900>//! InheritInner() {} // Won't compile</font>
  InheritInner(WithInner wi) {
    wi.<font color=#0000ff>super</font>();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    WithInner wi = <font color=#0000ff>new</font> WithInner();
    InheritInner ii = <font color=#0000ff>new</font> InheritInner(wi);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that
<B>InheritInner</B> is extending only the inner class, not the outer one. But
when it comes time to create a constructor, the default one is no good and you
can&#8217;t just pass a handle to an enclosing object. In addition, you must use
the syntax</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>enclosingClassHandle.<font color=#0000ff>super</font>();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><A NAME="Index652"></A><A NAME="Index653"></A><A NAME="Index654"></A><FONT FACE="Georgia">inside
the constructor. This provides the necessary handle and the program will then
compile.</FONT><A NAME="_Toc408018550"></A><BR></P></DIV>
<A NAME="Heading227"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Can inner classes be overridden?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What happens when you create an
inner class, then inherit from the enclosing class and redefine the inner class?
That is, is it possible to override an inner class? This seems like it would be
a powerful concept, but
<A NAME="Index655"></A><A NAME="Index656"></A><A NAME="Index657"></A>&#8220;overriding&#8221;
an inner class as if it were another method of the outer class doesn&#8217;t
really do anything:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: BigEgg.java</font>
<font color=#009900>// An inner class cannot be overriden </font>
<font color=#009900>// like a method</font>

<font color=#0000ff>class</font> Egg {
  <font color=#0000ff>protected</font> <font color=#0000ff>class</font> Yolk {
    <font color=#0000ff>public</font> Yolk() {
      System.out.println(<font color=#004488>"Egg.Yolk()"</font>);
    }
  }
  <font color=#0000ff>private</font> Yolk y;
  <font color=#0000ff>public</font> Egg() {
    System.out.println(<font color=#004488>"New Egg()"</font>);
    y = <font color=#0000ff>new</font> Yolk();
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> BigEgg <font color=#0000ff>extends</font> Egg {
  <font color=#0000ff>public</font> <font color=#0000ff>class</font> Yolk {
    <font color=#0000ff>public</font> Yolk() {
      System.out.println(<font color=#004488>"BigEgg.Yolk()"</font>);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>new</font> BigEgg();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The default constructor is
synthesized automatically by the compiler, and this calls the base-class default
constructor. You might think that since a <B>BigEgg</B> is being created, the
&#8220;overridden&#8221; version of <B>Yolk</B> would be used, but this is not
the case. The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>New Egg()
Egg.Yolk()</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example simply shows that
there isn&#8217;t any extra inner class magic going on when you inherit from the
outer class. However, it&#8217;s still possible to explicitly inherit from the
inner class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: BigEgg2.java</font>
<font color=#009900>// Proper inheritance of an inner class</font>

<font color=#0000ff>class</font> Egg2 {
  <font color=#0000ff>protected</font> <font color=#0000ff>class</font> Yolk {
    <font color=#0000ff>public</font> Yolk() {
      System.out.println(<font color=#004488>"Egg2.Yolk()"</font>);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() {
      System.out.println(<font color=#004488>"Egg2.Yolk.f()"</font>);
    }
  }
  <font color=#0000ff>private</font> Yolk y = <font color=#0000ff>new</font> Yolk();
  <font color=#0000ff>public</font> Egg2() {
    System.out.println(<font color=#004488>"New Egg2()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> insertYolk(Yolk yy) { y = yy; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> g() { y.f(); }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> BigEgg2 <font color=#0000ff>extends</font> Egg2 {
  <font color=#0000ff>public</font> <font color=#0000ff>class</font> Yolk <font color=#0000ff>extends</font> Egg2.Yolk {
    <font color=#0000ff>public</font> Yolk() {
      System.out.println(<font color=#004488>"BigEgg2.Yolk()"</font>);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() {
      System.out.println(<font color=#004488>"BigEgg2.Yolk.f()"</font>);
    }
  }
  <font color=#0000ff>public</font> BigEgg2() { insertYolk(<font color=#0000ff>new</font> Yolk()); }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Egg2 e2 = <font color=#0000ff>new</font> BigEgg2();
    e2.g();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now <B>BiggEgg2.Yolk</B> explicitly
<B>extends</B> <B>Egg2.Yolk</B> and overrides its methods. The method
<B>insertYolk(&#160;) </B>allows <B>BigEgg2 </B>to upcast one of its own <B>Yolk
</B>objects into the <B>y</B> handle in <B>Egg2</B>, so when <B>g(&#160;)</B>
calls <B>y.f(&#160;)</B> the overridden version of <B>f(&#160;)</B> is used. The
output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Egg2.Yolk()
New Egg2()
Egg2.Yolk()
BigEgg2.Yolk()
BigEgg2.Yolk.f()</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second call to
<B>Egg2.Yolk(&#160;)</B> is the base-class constructor call of the
<B>BigEgg2.Yolk</B> constructor. You can see that the overridden version of
<B>f(&#160;)</B> is used when <B>g(&#160;)</B> is
called.</FONT><A NAME="_Toc408018551"></A><BR></P></DIV>
<A NAME="Heading228"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Inner class identifiers</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since every class produces a
<B>.class </B>file that holds all the information about how to create objects of
this type (this information produces a meta-class called the <B>Class
</B>object), you might guess that
<A NAME="Index658"></A><A NAME="Index659"></A>inner classes must also produce
<B>.class</B> files to contain the information for <I>their</I> <B>Class</B>
objects. The names of these files/classes have a strict formula: the name of the
enclosing class, followed by a &#8216;<B>$</B>&#8217;, followed by the name of
the inner class. For example, the <B>.class</B> files created by
<B>InheritInner.java</B> include:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>InheritInner.<font color=#0000ff>class</font>
WithInner$Inner.<font color=#0000ff>class</font>
WithInner.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If inner classes are anonymous, the
compiler simply starts generating numbers as inner class identifiers. If inner
classes are nested within inner classes, their names are simply appended after a
&#8216;<B>$</B>&#8217; and the outer class identifier(s).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although this scheme of generating
internal names is simple and straightforward, it&#8217;s also robust and handles
most
situations.</FONT><A NAME="fnB30" HREF="#fn30">[30]</A><FONT FACE="Georgia">
Since it is the standard naming scheme for Java, the generated files are
automatically platform-independent. (Note that the Java compiler is changing
your inner classes in all sorts of other ways in order to make them
work.)</FONT><A NAME="_Toc408018552"></A><BR></P></DIV>
<A NAME="Heading229"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Why inner classes: control frameworks</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point you&#8217;ve seen a
lot of syntax and semantics describing the way inner classes work, but this
doesn&#8217;t answer the question of why they exist. Why did Sun go to so much
trouble to add such a fundamental language feature in Java
1.1<A NAME="Index660"></A>? The answer is something that I will refer to here as
a
<A NAME="Index661"></A><A NAME="Index662"></A><A NAME="Index663"></A><I>control
framework</I>. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An
<A NAME="Index664"></A><I>application framework</I> is a class or a set of
classes that&#8217;s designed to solve a particular type of problem. To apply an
application framework, you inherit from one or more classes and override some of
the methods. The code you write in the overridden methods customizes the general
solution provided by that application framework to solve your specific problem.
The control framework is a particular type of application<I> </I>framework
dominated by the need to respond to events; a system that primarily responds to
events is called an <A NAME="Index665"></A><I>event-driven</I> <I>system</I>.
One of the most important problems in application programming is the
<A NAME="Index666"></A><A NAME="Index667"></A><A NAME="Index668"></A>graphical
user interface (GUI), which is almost entirely event-driven. As you will see in
Chapter 13, the Java 1.1 AWT is a control framework that elegantly solves the
GUI problem using inner classes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To see how inner classes allow the
simple creation and use of control frameworks, consider a control framework
whose job is to execute events whenever those events are &#8220;ready.&#8221;
Although &#8220;ready&#8221; could mean anything, in this case the default will
be based on clock time. What follows is a control framework that contains no
specific information about what it&#8217;s controlling. First, here is the
interface that describes any control event. It&#8217;s an <B>abstract</B> class
instead of an actual <B>interface</B> because the default behavior is control
based on time, so some of the implementation can be included
here:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Event.java</font>
<font color=#009900>// The common methods for any control event</font>
<font color=#0000ff>package</font> c07.controller;

<font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>class</font> Event {
  <font color=#0000ff>private</font> <font color=#0000ff>long</font> evtTime;
  <font color=#0000ff>public</font> Event(<font color=#0000ff>long</font> eventTime) {
    evtTime = eventTime;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> ready() {
    <font color=#0000ff>return</font> System.currentTimeMillis() &gt;= evtTime;
  }
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>void</font> action();
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> String description();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor simply captures the
time when you want the <B>Event</B> to run, while <B>ready(&#160;)</B> tells you
when it&#8217;s time to run it. Of course, <B>ready(&#160;)</B> could be
overridden in a derived class to base the <B>Event</B> on something other than
time.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>action(&#160;)</B> is the method
that&#8217;s called when the <B>Event</B> is <B>ready(&#160;)</B>, and
<B>description(&#160;)</B> gives textual information about the
<B>Event</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next file contains the actual
control framework that manages and fires events. The first class is really just
a &#8220;helper&#8221; class whose job is to hold <B>Event</B> objects. You
could replace it with any appropriate collection, and in Chapter 8 you&#8217;ll
discover other collections that will do the trick without requiring you to write
this extra code:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Controller.java</font>
<font color=#009900>// Along with Event, the generic</font>
<font color=#009900>// framework for all control systems:</font>
<font color=#0000ff>package</font> c07.controller;

<font color=#009900>// This is just a way to hold Event objects.</font>
<font color=#0000ff>class</font> EventSet {
  <font color=#0000ff>private</font> Event[] events = <font color=#0000ff>new</font> Event[100];
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> index = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> next = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> add(Event e) {
    <font color=#0000ff>if</font>(index &gt;= events.length)
      <font color=#0000ff>return</font>; <font color=#009900>// (In real life, throw exception)</font>
    events[index++] = e;
  }
  <font color=#0000ff>public</font> Event getNext() {
    <font color=#0000ff>boolean</font> looped = <font color=#0000ff>false</font>;
    <font color=#0000ff>int</font> start = next;
    <font color=#0000ff>do</font> {
      next = (next + 1) % events.length;
      <font color=#009900>// See if it has looped to the beginning:</font>
      <font color=#0000ff>if</font>(start == next) looped = <font color=#0000ff>true</font>;
      <font color=#009900>// If it loops past start, the list </font>
      <font color=#009900>// is empty:</font>
      <font color=#0000ff>if</font>((next == (start + 1) % events.length)
         &amp;&amp; looped)
        <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
    } <font color=#0000ff>while</font>(events[next] == <font color=#0000ff>null</font>);
    <font color=#0000ff>return</font> events[next];
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> removeCurrent() {
    events[next] = <font color=#0000ff>null</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Controller {
  <font color=#0000ff>private</font> EventSet es = <font color=#0000ff>new</font> EventSet();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> addEvent(Event c) { es.add(c); }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    Event e;
    <font color=#0000ff>while</font>((e = es.getNext()) != <font color=#0000ff>null</font>) {
      <font color=#0000ff>if</font>(e.ready()) {
        e.action();
        System.out.println(e.description());
        es.removeCurrent();
      }
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>EventSet</B> arbitrarily holds
100 <B>Event</B>s. (If a &#8220;real&#8221; collection from Chapter 8 is used
here you don&#8217;t need to worry about its maximum size, since it will resize
itself). The <B>index</B> is used to keep track of the next available space, and
<B>next</B> is used when you&#8217;re looking for the next <B>Event</B> in the
list, to see whether you&#8217;ve looped around. This is important during a call
to <B>getNext(&#160;)</B>, because <B>Event</B> objects are removed from the
list (using <B>removeCurrent(&#160;)</B>)<B> </B>once they&#8217;re run, so
<B>getNext(&#160;)</B> will encounter holes in the list as it moves through
it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that
<B>removeCurrent(&#160;)</B> doesn&#8217;t just set some flag indicating that
the object is no longer in use. Instead, it sets the handle to <B>null</B>. This
is important because if the <A NAME="Index669"></A>garbage collector sees a
handle that&#8217;s still in use then it can&#8217;t clean up the object. If you
think your handles might hang around (as they would here), then it&#8217;s a
good idea to set them to <B>null</B> to give the garbage collector permission to
clean them up.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Controller</B> is where the
actual work goes on. It uses an <B>EventSet</B> to hold its <B>Event</B>
objects, and <B>addEvent(&#160;)</B> allows you to add new events to this list.
But the important method is <B>run(&#160;)</B>. This method loops through the
<B>EventSet</B>, hunting for an <B>Event</B> object that&#8217;s
<B>ready(&#160;)</B> to run. For each one it finds <B>ready(&#160;)</B>,<B>
</B>it calls the <B>action(&#160;)</B> method, prints out the
<B>description(&#160;),</B> and then removes the <B>Event</B> from the list.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that so far in this design you
know nothing about exactly <I>what</I> an <B>Event</B> does. And this is the
crux of the design; how it &#8220;separates the things that change from the
things that stay the same.&#8221; Or, to use my term, the
&#8220;<A NAME="Index670"></A><A NAME="Index671"></A>vector of change&#8221; is
the different actions of the various kinds of <B>Event</B> objects, and you
express different actions by creating different <B>Event</B>
subclasses.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is where inner classes come
into play. They allow two things:
<A NAME="Index672"></A><A NAME="Index673"></A><A NAME="Index674"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	To express the entire implementation of a
control-framework application in a single class, thereby encapsulating
everything that&#8217;s unique about that implementation. Inner classes are used
to express the many different kinds of <B>action(&#160;)</B> necessary to solve
the problem. In addition, the following example uses <B>private</B> inner
classes so the implementation is completely hidden and can be changed with
impunity.</FONT><LI><FONT FACE="Georgia">	Inner classes keep this
implementation from becoming awkward, since you&#8217;re able to easily access
any of the members in the outer class. Without this ability the code might
become unpleasant enough that you&#8217;d end up seeking an
alternative.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider a
particular implementation of the control framework designed to control
greenhouse
functions.</FONT><A NAME="fnB31" HREF="#fn31">[31]</A><FONT FACE="Georgia">
Each action is entirely different: turning lights, water, and thermostats on and
off, ringing bells, and restarting the system. But the control framework is
designed to easily isolate this different code. For each type of action you
inherit a new <B>Event</B> inner class, and write the control code inside of
<B>action(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As is typical with an application
framework, the class <B>GreenhouseControls</B> is inherited from
<B>Controller</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: GreenhouseControls.java</font>
<font color=#009900>// This produces a specific application of the</font>
<font color=#009900>// control system, all in a single class. Inner</font>
<font color=#009900>// classes allow you to encapsulate different</font>
<font color=#009900>// functionality for each type of event.</font>
<font color=#0000ff>package</font> c07.controller;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GreenhouseControls 
    <font color=#0000ff>extends</font> Controller {
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> light = <font color=#0000ff>false</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> water = <font color=#0000ff>false</font>;
  <font color=#0000ff>private</font> String thermostat = <font color=#004488>"Day"</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> LightOn <font color=#0000ff>extends</font> Event {
    <font color=#0000ff>public</font> LightOn(<font color=#0000ff>long</font> eventTime) {
      <font color=#0000ff>super</font>(eventTime);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> action() {
      <font color=#009900>// Put hardware control code here to </font>
      <font color=#009900>// physically turn on the light.</font>
      light = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>public</font> String description() {
      <font color=#0000ff>return</font> <font color=#004488>"Light is on"</font>;
    }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> LightOff <font color=#0000ff>extends</font> Event {
    <font color=#0000ff>public</font> LightOff(<font color=#0000ff>long</font> eventTime) {
      <font color=#0000ff>super</font>(eventTime);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> action() {
      <font color=#009900>// Put hardware control code here to </font>
      <font color=#009900>// physically turn off the light.</font>
      light = <font color=#0000ff>false</font>;
    }
    <font color=#0000ff>public</font> String description() {
      <font color=#0000ff>return</font> <font color=#004488>"Light is off"</font>;
    }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> WaterOn <font color=#0000ff>extends</font> Event {
    <font color=#0000ff>public</font> WaterOn(<font color=#0000ff>long</font> eventTime) {
      <font color=#0000ff>super</font>(eventTime);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> action() {
      <font color=#009900>// Put hardware control code here</font>
      water = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>public</font> String description() {
      <font color=#0000ff>return</font> <font color=#004488>"Greenhouse water is on"</font>;
    }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> WaterOff <font color=#0000ff>extends</font> Event {
    <font color=#0000ff>public</font> WaterOff(<font color=#0000ff>long</font> eventTime) {
      <font color=#0000ff>super</font>(eventTime);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> action() {
      <font color=#009900>// Put hardware control code here</font>
      water = <font color=#0000ff>false</font>;
    }
    <font color=#0000ff>public</font> String description() {
      <font color=#0000ff>return</font> <font color=#004488>"Greenhouse water is off"</font>;
    }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> ThermostatNight <font color=#0000ff>extends</font> Event {
    <font color=#0000ff>public</font> ThermostatNight(<font color=#0000ff>long</font> eventTime) {
      <font color=#0000ff>super</font>(eventTime);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> action() {
      <font color=#009900>// Put hardware control code here</font>
      thermostat = <font color=#004488>"Night"</font>;
    }
    <font color=#0000ff>public</font> String description() {
      <font color=#0000ff>return</font> <font color=#004488>"Thermostat on night setting"</font>;
    }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> ThermostatDay <font color=#0000ff>extends</font> Event {
    <font color=#0000ff>public</font> ThermostatDay(<font color=#0000ff>long</font> eventTime) {
      <font color=#0000ff>super</font>(eventTime);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> action() {
      <font color=#009900>// Put hardware control code here</font>
      thermostat = <font color=#004488>"Day"</font>;
    }
    <font color=#0000ff>public</font> String description() {
      <font color=#0000ff>return</font> <font color=#004488>"Thermostat on day setting"</font>;
    }
  }
  <font color=#009900>// An example of an action() that inserts a </font>
  <font color=#009900>// new one of itself into the event list:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> rings;
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> Bell <font color=#0000ff>extends</font> Event {
    <font color=#0000ff>public</font> Bell(<font color=#0000ff>long</font> eventTime) {
      <font color=#0000ff>super</font>(eventTime);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> action() {
      <font color=#009900>// Ring bell every 2 seconds, rings times:</font>
      System.out.println(<font color=#004488>"Bing!"</font>);
      <font color=#0000ff>if</font>(--rings &gt; 0)
        addEvent(<font color=#0000ff>new</font> Bell(
          System.currentTimeMillis() + 2000));
    }
    <font color=#0000ff>public</font> String description() {
      <font color=#0000ff>return</font> <font color=#004488>"Ring bell"</font>;
    }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> Restart <font color=#0000ff>extends</font> Event {
    <font color=#0000ff>public</font> Restart(<font color=#0000ff>long</font> eventTime) {
      <font color=#0000ff>super</font>(eventTime);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> action() {
      <font color=#0000ff>long</font> tm = System.currentTimeMillis();
      <font color=#009900>// Instead of hard-wiring, you could parse</font>
      <font color=#009900>// configuration information from a text</font>
      <font color=#009900>// file here:</font>
      rings = 5;
      addEvent(<font color=#0000ff>new</font> ThermostatNight(tm));
      addEvent(<font color=#0000ff>new</font> LightOn(tm + 1000));
      addEvent(<font color=#0000ff>new</font> LightOff(tm + 2000));
      addEvent(<font color=#0000ff>new</font> WaterOn(tm + 3000));
      addEvent(<font color=#0000ff>new</font> WaterOff(tm + 8000));
      addEvent(<font color=#0000ff>new</font> Bell(tm + 9000));
      addEvent(<font color=#0000ff>new</font> ThermostatDay(tm + 10000));
      <font color=#009900>// Can even add a Restart object!</font>
      addEvent(<font color=#0000ff>new</font> Restart(tm + 20000));
    }
    <font color=#0000ff>public</font> String description() {
      <font color=#0000ff>return</font> <font color=#004488>"Restarting system"</font>;
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    GreenhouseControls gc = 
      <font color=#0000ff>new</font> GreenhouseControls();
    <font color=#0000ff>long</font> tm = System.currentTimeMillis();
    gc.addEvent(gc.<font color=#0000ff>new</font> Restart(tm));
    gc.run();
  } 
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>light</B>,
<B>water</B>, <B>thermostat,</B> and <B>rings</B> all belong to the outer class
<B>GreenhouseControls</B>, and yet the inner classes have no problem accessing
those fields. Also, most of the <B>action(&#160;)</B> methods also involve some
sort of hardware control, which would most likely involve calls to non-Java
code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most of the <B>Event</B> classes
look similar, but <B>Bell</B> and <B>Restart</B> are special. <B>Bell</B> rings,
and if it hasn&#8217;t yet rung enough times it adds a new <B>Bell</B> object to
the event list, so it will ring again later. Notice how inner classes
<I>almost</I> look like multiple inheritance: <B>Bell</B> has all the methods of
<B>Event</B> and it also appears to have all the methods of the outer class
<B>GreenhouseControls</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Restart</B> is responsible for
initializing the system, so it adds all the appropriate events. Of course, a
more flexible way to accomplish this is to avoid hard-coding the events and
instead read them from a file. (An exercise in Chapter 10 asks you to modify
this example to do just that.) Since <B>Restart(&#160;)</B> is just another
<B>Event</B> object, you can also add a <B>Restart</B> object within
<B>Restart.action(&#160;)</B> so that the system regularly restarts itself. And
all you need to do in <B>main(&#160;)</B> is create a <B>GreenhouseControls</B>
object and add a <B>Restart</B> object to get it going.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example should move you a long
way toward appreciating the value of inner classes, especially when used within
a control framework. However, in the latter half of Chapter 13 you&#8217;ll see
how elegantly inner classes are used to describe the actions of a graphical user
interface. By the time you finish that section you should be fully
convinced.</FONT><A NAME="_Toc408018553"></A><BR></P></DIV>
<A NAME="Heading230"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Constructors and polymorphism</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As usual,
<A NAME="Index675"></A><A NAME="Index676"></A>constructors are different from
other kinds of methods. This is also true when polymorphism is involved. Even
though constructors are not polymorphic (although you can have a kind of
&#8220;virtual constructor,&#8221; as you will see in Chapter 11), it&#8217;s
important to understand the way constructors work in complex hierarchies and
with polymorphism. This understanding will help you avoid unpleasant
entanglements.</FONT><A NAME="_Toc375545339"></A><A NAME="_Toc408018554"></A><BR></P></DIV>
<A NAME="Heading231"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Order of constructor
calls<BR><A NAME="Index677"></A><A NAME="Index678"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The order of constructor calls was
briefly discussed in Chapter 4, but that was before inheritance and polymorphism
were introduced. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A constructor for the base class is
always called in the constructor for a derived class, chaining upward so that a
constructor for every base class is called. This makes sense because the
constructor has a special job: to see that the object is built properly. A
derived class has access to its own members only, and not to those of the base
class (whose members are typically <B>private</B>). Only the base-class
constructor has the proper knowledge and access to initialize its own elements.
Therefore, it&#8217;s essential that all constructors get called, otherwise the
entire object wouldn&#8217;t be constructed properly. That&#8217;s why the
compiler enforces a constructor call for every portion of a derived class. It
will silently call the default constructor if you don&#8217;t explicitly call a
base-class constructor in the derived-class constructor body. If there is no
default constructor, the compiler will complain. (In the case where a class has
no constructors, the compiler will automatically synthesize a default
constructor.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Let&#8217;s take a look at an
example that shows the effects of composition, inheritance, and polymorphism on
the order of construction:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Sandwich.java</font>
<font color=#009900>// Order of constructor calls</font>

<font color=#0000ff>class</font> Meal {
  Meal() { System.out.println(<font color=#004488>"Meal()"</font>); }
}

<font color=#0000ff>class</font> Bread {
  Bread() { System.out.println(<font color=#004488>"Bread()"</font>); }
}

<font color=#0000ff>class</font> Cheese {
  Cheese() { System.out.println(<font color=#004488>"Cheese()"</font>); }
}

<font color=#0000ff>class</font> Lettuce {
  Lettuce() { System.out.println(<font color=#004488>"Lettuce()"</font>); }
}

<font color=#0000ff>class</font> Lunch <font color=#0000ff>extends</font> Meal {
  Lunch() { System.out.println(<font color=#004488>"Lunch()"</font>);}
}

<font color=#0000ff>class</font> PortableLunch <font color=#0000ff>extends</font> Lunch {
  PortableLunch() {
    System.out.println(<font color=#004488>"PortableLunch()"</font>);
  }
}

<font color=#0000ff>class</font> Sandwich <font color=#0000ff>extends</font> PortableLunch {
  Bread b = <font color=#0000ff>new</font> Bread();
  Cheese c = <font color=#0000ff>new</font> Cheese();
  Lettuce l = <font color=#0000ff>new</font> Lettuce();
  Sandwich() { 
    System.out.println(<font color=#004488>"Sandwich()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>new</font> Sandwich();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example creates a complex
class out of other classes, and each class has a constructor that announces
itself. The important class is <B>Sandwich</B>, which reflects three levels of
inheritance (four, if you count the implicit inheritance from <B>Object</B>) and
three member objects. When a <B>Sandwich</B> object is created in
<B>main(&#160;)</B>, the output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Meal()
Lunch()
PortableLunch()
Bread()
Cheese()
Lettuce()
Sandwich()</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This means that the order of
constructor calls for a complex object is as follows:
<A NAME="Index679"></A><A NAME="Index680"></A><A NAME="Index681"></A><A NAME="Index682"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	The base-class constructor is called. This step
is repeated recursively such that the root of the hierarchy is constructed
first, followed by the next-derived class, etc., until the most-derived class is
reached.</FONT><LI><FONT FACE="Georgia">	Member initializers are called in
the order of declaration.</FONT><LI><FONT FACE="Georgia">	The body of the
derived-class constructor is
called.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The order of the
constructor calls is important. When you inherit, you know all about the base
class and can access any <B>public</B> and <B>protected</B> members of the base
class. This means that you must be able to assume that all the members of the
base class are valid when you&#8217;re in the derived class. In a normal method,
construction has already taken place, so all the members of all parts of the
object have been built. Inside the constructor, however, you must be able to
assume that all members that you use have been built. The only way to guarantee
this is for the base-class constructor to be called first. Then when
you&#8217;re in the derived-class constructor, all the members you can access in
the base class have been initialized. &#8220;Knowing that all members are
valid&#8221; inside the constructor is also the reason that, whenever possible,
you should initialize all member objects (that is, objects placed in the class
using composition) at their point of definition in the class (e.g.: <B>b</B>,
<B>c,</B> and <B>l</B> in the example above). If you follow this practice, you
will help ensure that all base class members <I>and</I> member objects of the
current object have been initialized. Unfortunately, this doesn&#8217;t handle
every case, as you will see in the next
section.</FONT><A NAME="_Toc408018555"></A><BR></P></DIV>
<A NAME="Heading232"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Inheritance and finalize(&#160;)</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you use composition to create
a new class, you never worry about finalizing the member objects of that class.
Each member is an independent object and thus is <A NAME="Index683"></A>garbage
collected and finalized regardless of whether it happens to be a member of your
class. With inheritance, however, you must override
<A NAME="Index684"></A><A NAME="Index685"></A><B>finalize(&#160;)</B> in the
derived class if you have any special cleanup that must happen as part of
garbage collection. When you override <B>finalize(&#160;)</B> in an inherited
class, it&#8217;s important to remember to call the base-class version of
<B>finalize(&#160;)</B>, since otherwise the base-class finalization will not
happen. The following example proves this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Frog.java</font>
<font color=#009900>// Testing finalize with inheritance</font>

<font color=#0000ff>class</font> DoBaseFinalization {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>boolean</font> flag = <font color=#0000ff>false</font>;
}

<font color=#0000ff>class</font> Characteristic {
  String s;
  Characteristic(String c) {
    s = c;
    System.out.println(
      <font color=#004488>"Creating Characteristic "</font> + s);
  }
  <font color=#0000ff>protected</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(
      <font color=#004488>"finalizing Characteristic "</font> + s);
  }
}

<font color=#0000ff>class</font> LivingCreature {
  Characteristic p = 
    <font color=#0000ff>new</font> Characteristic(<font color=#004488>"is alive"</font>);
  LivingCreature() {
    System.out.println(<font color=#004488>"LivingCreature()"</font>);
  }
  <font color=#0000ff>protected</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(
      <font color=#004488>"LivingCreature finalize"</font>);
    <font color=#009900>// Call base-class version LAST!</font>
    <font color=#0000ff>if</font>(DoBaseFinalization.flag)
      <font color=#0000ff>try</font> {
        <font color=#0000ff>super</font>.finalize();
      } <font color=#0000ff>catch</font>(Throwable t) {}
  }
}

<font color=#0000ff>class</font> Animal <font color=#0000ff>extends</font> LivingCreature {
  Characteristic p = 
    <font color=#0000ff>new</font> Characteristic(<font color=#004488>"has heart"</font>);
  Animal() {
    System.out.println(<font color=#004488>"Animal()"</font>);
  }
  <font color=#0000ff>protected</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Animal finalize"</font>);
    <font color=#0000ff>if</font>(DoBaseFinalization.flag)
      <font color=#0000ff>try</font> {
        <font color=#0000ff>super</font>.finalize();
      } <font color=#0000ff>catch</font>(Throwable t) {}
  }
}

<font color=#0000ff>class</font> Amphibian <font color=#0000ff>extends</font> Animal {
  Characteristic p = 
    <font color=#0000ff>new</font> Characteristic(<font color=#004488>"can live in water"</font>);
  Amphibian() {
    System.out.println(<font color=#004488>"Amphibian()"</font>);
  }
  <font color=#0000ff>protected</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Amphibian finalize"</font>);
    <font color=#0000ff>if</font>(DoBaseFinalization.flag)
      <font color=#0000ff>try</font> {
        <font color=#0000ff>super</font>.finalize();
      } <font color=#0000ff>catch</font>(Throwable t) {}
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Frog <font color=#0000ff>extends</font> Amphibian {
  Frog() {
    System.out.println(<font color=#004488>"Frog()"</font>);
  }
  <font color=#0000ff>protected</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Frog finalize"</font>);
    <font color=#0000ff>if</font>(DoBaseFinalization.flag)
      <font color=#0000ff>try</font> {
        <font color=#0000ff>super</font>.finalize();
      } <font color=#0000ff>catch</font>(Throwable t) {}
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length != 0 &amp;&amp; 
       args[0].equals(<font color=#004488>"finalize"</font>))
       DoBaseFinalization.flag = <font color=#0000ff>true</font>;
    <font color=#0000ff>else</font>
      System.out.println(<font color=#004488>"not finalizing bases"</font>);
    <font color=#0000ff>new</font> Frog(); <font color=#009900>// Instantly becomes garbage</font>
    System.out.println(<font color=#004488>"bye!"</font>);
    <font color=#009900>// Must do this to guarantee that all </font>
    <font color=#009900>// finalizers will be called:</font>
    System.runFinalizersOnExit(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class <B>DoBaseFinalization</B>
simply holds a flag that indicates to each class in the hierarchy whether to
call
<A NAME="Index686"></A><A NAME="Index687"></A><B>super.finalize(&#160;)</B>.
This flag is set based on a command-line argument, so you can view the behavior
with and without base-class finalization.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each class in the hierarchy also
contains a member object of class <B>Characteristic</B>. You will see that
regardless of whether the base class finalizers are called, the
<B>Characteristic</B> member objects are always finalized.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each overridden <B>finalize(&#160;)
</B>must have access to at least <B>protected </B>members since the
<B>finalize(&#160;) </B>method in class <B>Object </B>is <B>protected</B> and
the compiler will not allow you to reduce the access during inheritance.
(&#8220;Friendly&#8221; is less accessible than <B>protected</B>.)<B>
</B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Frog.main(&#160;)</B>,<B>
</B>the <B>DoBaseFinalization </B>flag is configured and a single <B>Frog
</B>object is created. Remember that garbage collection and in particular
finalization might not happen for any particular object so to enforce this,
<B>System.<A NAME="Index688"></A>runFinalizersOnExit(true)</B> adds the extra
overhead to guarantee that finalization takes place. Without base-class
finalization, the output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>not finalizing bases
Creating Characteristic is alive
LivingCreature()
Creating Characteristic has heart
Animal()
Creating Characteristic can live in water
Amphibian()
Frog()
bye!
Frog finalize
finalizing Characteristic is alive
finalizing Characteristic has heart
finalizing Characteristic can live in water</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that, indeed, no
finalizers are called for the base classes of <B>Frog</B>. But if you add the
&#8220;finalize&#8221; argument on the command line, you get:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Creating Characteristic is alive
LivingCreature()
Creating Characteristic has heart
Animal()
Creating Characteristic can live in water
Amphibian()
Frog()
bye!
Frog finalize
Amphibian finalize
Animal finalize
LivingCreature finalize
finalizing Characteristic is alive
finalizing Characteristic has heart
finalizing Characteristic can live in water</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although the order the member
objects are finalized is the same order that they are created, technically the
<A NAME="Index689"></A><A NAME="Index690"></A><A NAME="Index691"></A>order of
finalization of objects is unspecified. With base classes, however, you have
control over the order of finalization. The best order to use is the one
that&#8217;s shown here, which is the reverse of the order of initialization.
Following the form that&#8217;s used in C++ for destructors, you should perform
the derived-class finalization first, then the base-class finalization.
That&#8217;s because the derived-class finalization could call some methods in
the base class that require that the base-class components are still alive, so
you must not destroy them
prematurely.</FONT><A NAME="_Toc312374057"></A><A NAME="_Toc375545340"></A><A NAME="_Toc408018556"></A><BR></P></DIV>
<A NAME="Heading233"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Behavior of polymorphic methods <BR>inside
constructors<BR><A NAME="Index692"></A><A NAME="Index693"></A><A NAME="Index694"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The hierarchy of constructor calls
brings up an interesting dilemma. What happens if you&#8217;re inside a
constructor and you call a dynamically-bound method of the object being
constructed? Inside an ordinary method you can imagine what will happen &#8211;
the dynamically-bound call is resolved at run-time because the object cannot
know whether it belongs to the class the method is in or some class derived from
it. For consistency, you might think this is what should happen inside
constructors.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is not exactly the case. If
you call a dynamically-bound method inside a constructor, the overridden
definition for that method is used. However, the <I>effect</I> can be rather
unexpected, and can conceal some difficult-to-find bugs.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Conceptually, the
constructor&#8217;s job is to bring the object into existence (which is hardly
an ordinary feat). Inside any constructor, the entire object might be only
partially formed &#8211; you can know only that the base-class objects have been
initialized, but you cannot know which classes are inherited from you. A
dynamically-bound method call, however, reaches &#8220;forward&#8221; or
&#8220;outward&#8221; into the inheritance hierarchy. It calls a method in a
derived class. If you do this inside a constructor, you call a method that might
manipulate members that haven&#8217;t been initialized yet &#8211; a sure recipe
for disaster.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see the problem in the
following example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PolyConstructors.java</font>
<font color=#009900>// Constructors and polymorphism</font>
<font color=#009900>// don't produce what you might expect.</font>

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Glyph {
  <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> draw();
  Glyph() {
    System.out.println(<font color=#004488>"Glyph() before draw()"</font>);
    draw(); 
    System.out.println(<font color=#004488>"Glyph() after draw()"</font>);
  }
}

<font color=#0000ff>class</font> RoundGlyph <font color=#0000ff>extends</font> Glyph {
  <font color=#0000ff>int</font> radius = 1;
  RoundGlyph(<font color=#0000ff>int</font> r) {
    radius = r;
    System.out.println(
      <font color=#004488>"RoundGlyph.RoundGlyph(), radius = "</font>
      + radius);
  }
  <font color=#0000ff>void</font> draw() { 
    System.out.println(
      <font color=#004488>"RoundGlyph.draw(), radius = "</font> + radius);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PolyConstructors {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>new</font> RoundGlyph(5);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Glyph</B>, the
<B>draw(&#160;)</B> method is <B>abstract</B>, so it is designed to be
overridden. Indeed, you are forced to override it in <B>RoundGlyph</B>. But the
<B>Glyph</B> constructor calls this method, and the call ends up in
<B>RoundGlyph.draw(&#160;)</B>, which would seem to be the intent. But look at
the output:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Glyph() before draw()
RoundGlyph.draw(), radius = 0
Glyph() after draw()
RoundGlyph.RoundGlyph(), radius = 5</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When <B>Glyph</B>&#8217;s
constructor calls <B>draw(&#160;)</B>, the value of <B>radius</B> isn&#8217;t
even the default initial value 1. It&#8217;s zero. This would probably result in
either a dot or nothing at all being drawn on the screen, and you&#8217;d be
staring, trying to figure out why the program won&#8217;t work.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index695"></A><A NAME="Index696"></A>order of initialization described
in the previous section isn&#8217;t quite complete, and that&#8217;s the key to
solving the mystery. The actual process of initialization is:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	The storage allocated for the object is
initialized to binary zero before anything else
happens.</FONT><LI><FONT FACE="Georgia">	The base-class constructors are
called as described previously. At this point, the overridden
<B>draw(&#160;)</B> method is called, (yes, <I>before </I>the <B>RoundGlyph
</B>constructor is called), which discovers a <B>radius</B> value of zero, due
to step 1.</FONT><LI><FONT FACE="Georgia">	Member initializers are called
in the order of declaration.</FONT><LI><FONT FACE="Georgia">	The body of
the derived-class constructor is
called.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s an
upside to this, which is that everything is at least initialized to zero (or
whatever zero means for that particular data type) and not just left as garbage.
This includes object handles that are embedded inside a class via composition.
So if you forget to initialize that handle you&#8217;ll get an exception at run
time. Everything else gets zero, which is usually a telltale value when looking
at output.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">On the other hand, you should be
pretty horrified at the outcome of this program. You&#8217;ve done a perfectly
logical thing and yet the behavior is mysteriously wrong, with no complaints
from the compiler. (C++ produces more rational behavior in this situation.) Bugs
like this could easily be buried and take a long time to
discover.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a result, a good guideline for
constructors is, &#8220;Do as little as possible to set the object into a good
state, and if you can possibly avoid it, don&#8217;t call any methods.&#8221;
The only safe methods to call inside a constructor are those that are
<B>final</B> in the base class. (This also applies to <B>private</B> methods,
which are automatically <B>final</B>.) These cannot be overridden and thus
cannot produce this kind of
surprise.</FONT><A NAME="_Toc375545341"></A><A NAME="_Toc408018557"></A><BR></P></DIV>
<A NAME="Heading234"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Designing with
inheritance<BR><A NAME="Index697"></A><A NAME="Index698"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you learn about polymorphism,
it can seem that everything ought to be inherited because polymorphism is such a
clever tool. This can burden your designs; in fact if you choose inheritance
first when you&#8217;re using an existing class to make a new class things can
become needlessly complicated.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A better approach is to choose
<A NAME="Index699"></A><A NAME="Index700"></A>composition first, when it&#8217;s
not obvious which one you should use. Composition does not force a design into
an inheritance hierarchy. But composition is also more flexible since it&#8217;s
possible to dynamically choose a type (and thus behavior) when using
composition, whereas inheritance requires an exact type to be known at compile
time. The following example illustrates this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Transmogrify.java</font>
<font color=#009900>// Dynamically changing the behavior of</font>
<font color=#009900>// an object via composition.</font>

<font color=#0000ff>interface</font> Actor {
  <font color=#0000ff>void</font> act();
}

<font color=#0000ff>class</font> HappyActor <font color=#0000ff>implements</font> Actor {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> act() { 
    System.out.println(<font color=#004488>"HappyActor"</font>); 
  }
}

<font color=#0000ff>class</font> SadActor <font color=#0000ff>implements</font> Actor {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> act() { 
    System.out.println(<font color=#004488>"SadActor"</font>);
  }
}

<font color=#0000ff>class</font> Stage {
  Actor a = <font color=#0000ff>new</font> HappyActor();
  <font color=#0000ff>void</font> change() { a = <font color=#0000ff>new</font> SadActor(); }
  <font color=#0000ff>void</font> go() { a.act(); }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Transmogrify {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Stage s = <font color=#0000ff>new</font> Stage();
    s.go(); <font color=#009900>// Prints "HappyActor"</font>
    s.change();
    s.go(); <font color=#009900>// Prints "SadActor"</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>Stage</B> object contains a
handle to an <B>Actor</B>, which is initialized to a <B>HappyActor</B> object.
This means <B>go(&#160;)</B> produces a particular behavior. But since a handle
can be re-bound to a different object at run time, a handle for a
<B>SadActor</B> object can be substituted in <B>a</B> and then the behavior
produced by <B>go(&#160;)</B> changes. Thus you gain dynamic flexibility at run
time. In contrast, you can&#8217;t decide to inherit differently at run time;
that must be completely determined at compile time.
<A NAME="Index701"></A><A NAME="Index702"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A general guideline is &#8220;Use
inheritance to express differences in behavior, and member variables to express
variations in state.&#8221; In the above example, both are used: two different
classes are inherited to express the difference in the <B>act(&#160;)</B>
method, and <B>Stage</B> uses composition to allow its state to be changed. In
this case, that change in state happens to produce a change in
behavior.</FONT><A NAME="_Toc375545342"></A><A NAME="_Toc408018558"></A><BR></P></DIV>
<A NAME="Heading235"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Pure inheritance vs.
extension<BR><A NAME="Index703"></A><A NAME="Index704"></A><A NAME="Index705"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When studying inheritance, it would
seem that the cleanest way to create an inheritance hierarchy is to take the
&#8220;pure&#8221; approach. That is, only methods that have been established in
the base class or <B>interface</B> are to be overridden in the derived class, as
seen in this diagram:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava112.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This can be termed a pure
&#8220;<A NAME="Index706"></A>is-a&#8221; relationship because the interface of
a class establishes what it is. Inheritance guarantees that any derived class
will have the interface of the base class and nothing less. If you follow the
above diagram, derived classes will also have <I>no more</I> than the base class
interface.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This can be thought of as
<A NAME="Index707"></A><I>pure substitution</I>, because derived class objects
can be perfectly substituted for the base class, and you never need to know any
extra information about the subclasses when you&#8217;re using
them:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava113.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That is, the base class can receive
any message you can send to the derived class because the two have exactly the
same interface. All you need to do is upcast from the derived class and never
look back to see what exact type of object you&#8217;re dealing with. Everything
is handled through polymorphism.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you see it this way, it seems
like a pure &#8220;is-a&#8221; relationship is the only sensible way to do
things, and any other <A NAME="Index708"></A>design indicates muddled thinking
and is by definition broken. This too is a trap. As soon as you start thinking
this way, you&#8217;ll turn around and discover that extending the interface
(which, unfortunately, the keyword <A NAME="Index709"></A><B>extends</B> seems
to promote) is the perfect solution to a particular problem. This could be
termed an <A NAME="Index710"></A>&#8220;is-like-a&#8221; relationship because
the derived class is <I>like</I> the base class &#8211; it has the same
fundamental interface &#8211; but it has other features that require additional
methods to implement:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava114.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While this is also a useful and
sensible approach (depending on the situation) it has a drawback. The extended
part of the interface in the derived class is not available from the base class,
so once you upcast you can&#8217;t call the new methods:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava115.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re not upcasting in
this case, it won&#8217;t bother you, but often you&#8217;ll get into a
situation in which you need to rediscover the exact type of the object so you
can access the extended methods of that type. The following sections show how
this is
done.</FONT><A NAME="_Toc375545343"></A><A NAME="_Toc408018559"></A><BR></P></DIV>
<A NAME="Heading236"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Downcasting and run-time <BR>type identification</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since you lose the specific type
information via an <I>upcast</I> (moving up the inheritance hierarchy), it makes
sense that to retrieve the type information &#8211; that is, to move back down
the inheritance hierarchy &#8211; you use a
<A NAME="Index711"></A><I>downcast</I>. However, you know an upcast is always
safe; the base class cannot have a bigger interface than the derived class,
therefore every message you send through the base class interface is guaranteed
to be accepted. But with a downcast, you don&#8217;t really know that a shape
(for example) is actually a circle. It could instead be a triangle or square or
some other type.</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava116.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To solve this problem there must be
some way to guarantee that a downcast is correct, so you won&#8217;t
accidentally cast to the wrong type and then send a message that the object
can&#8217;t accept. This would be quite unsafe.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In some languages (like C++) you
must perform a special operation in order to get a type-safe downcast, but in
Java <I>every cast</I> is checked! So even though it looks like you&#8217;re
just performing an ordinary parenthesized cast, at run time this cast is checked
to ensure that it is in fact the type you think it is. If it isn&#8217;t, you
get a <B>ClassCastException</B>. This act of checking types at run time is
called <A NAME="Index712"></A><A NAME="Index713"></A><I>run-time type
identification </I>(RTTI). The following example demonstrates the behavior of
RTTI:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: RTTI.java</font>
<font color=#009900>// Downcasting &amp; Run-Time Type</font>
<font color=#009900>// Identification (RTTI)</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Useful {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> g() {}
}

<font color=#0000ff>class</font> MoreUseful <font color=#0000ff>extends</font> Useful {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> g() {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> u() {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> v() {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> w() {}
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> RTTI {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Useful[] x = {
      <font color=#0000ff>new</font> Useful(),
      <font color=#0000ff>new</font> MoreUseful()
    };
    x[0].f();
    x[1].g();
    <font color=#009900>// Compile-time: method not found in Useful:</font>
    <font color=#009900>//! x[1].u();</font>
    ((MoreUseful)x[1]).u(); <font color=#009900>// Downcast/RTTI</font>
    ((MoreUseful)x[0]).u(); <font color=#009900>// Exception thrown</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As in the diagram,
<B>MoreUseful</B> extends the interface of <B>Useful</B>. But since it&#8217;s
inherited, it can also be upcast to a <B>Useful</B>. You can see this happening
in the initialization of the array <B>x</B> in <B>main(&#160;)</B>. Since both
objects in the array are of class <B>Useful</B>, you can send the
<B>f(&#160;)</B> and <B>g(&#160;)</B> methods to both, and if you try to call
<B>u(&#160;)</B> (which exists only in <B>MoreUseful</B>) you&#8217;ll get a
compile-time error message.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to access the extended
interface of a <B>MoreUseful</B> object, you can try to downcast. If it&#8217;s
the correct type, it will be successful. Otherwise, you&#8217;ll get a
<A NAME="Index714"></A><B>ClassCastException</B>. You don&#8217;t need to write
any special code for this exception, since it indicates a programmer error that
could happen anywhere in a program.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s more to RTTI than a
simple cast. For example, there&#8217;s a way to see what type you&#8217;re
dealing with <I>before</I> you try to downcast it. All of Chapter 11 is devoted
to the study of different aspects of Java run-time type
identification.</FONT><A NAME="_Toc375545344"></A><A NAME="_Toc408018560"></A><BR></P></DIV>
<A NAME="Heading237"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Polymorphism
<A NAME="Index715"></A>means &#8220;different forms.&#8221; In object-oriented
programming, you have the same face (the common interface in the base class) and
different forms using that face: the different versions of the dynamically-bound
methods.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ve seen in this chapter
that it&#8217;s impossible to understand, or even create, an example of
polymorphism without using data abstraction and inheritance. Polymorphism is a
feature that cannot be viewed in isolation (like a <B>switch</B> statement, for
example), but instead works only in concert, as part of a &#8220;big
picture&#8221; of class relationships. People are often confused by other,
non-object-oriented features of Java, like method overloading, which are
sometimes presented as object-oriented. Don&#8217;t be fooled: If it isn&#8217;t
late binding, it isn&#8217;t polymorphism.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To use polymorphism, and thus
object-oriented techniques, effectively in your programs you must expand your
view of programming to include not just members and messages of an individual
class, but also the commonality among classes and their relationships with each
other. Although this requires significant effort, it&#8217;s a worthy struggle,
because the results are faster program development, better code organization,
extensible programs, and easier code
maintenance.</FONT><A NAME="_Toc375545345"></A><A NAME="_Toc408018561"></A><BR></P></DIV>
<A NAME="Heading238"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
an inheritance hierarchy of <B>Rodent</B>: <B>Mouse</B>, <B>Gerbil</B>,
<B>Hamster</B>, etc. In the base class, provide methods that are common to all
<B>Rodent</B>s, and override these in the derived classes to perform different
behaviors depending on the specific type of <B>Rodent</B>. Create an array of
<B>Rodent</B>, fill it with different specific types of <B>Rodent</B>s, and call
your base-class methods to see what
happens.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Change
Exercise 1 so that <B>Rodent</B> is an
<B>interface</B>.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Repair
the problem in
<B>WindError.java</B>.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">In
<B>GreenhouseControls.java</B>, add <B>Event</B> inner classes that turn fans on
and
off.</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn28" HREF="#fnB28">[28]</A><FONT FACE="Georgia" SIZE=2>
This approach was inspired by an e-mail from Rich Hoffarth.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn29" HREF="#fnB29">[29]</A><FONT FACE="Georgia" SIZE=2>
This is very different from the design of <I>nested classes</I> in C++, which is
simply a name-hiding mechanism. There is no link to an enclosing object and no
implied permissions in C++.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn30" HREF="#fnB30">[30]</A><FONT FACE="Georgia" SIZE=2>
On the other hand, &#8216;$&#8217; is a meta-character to the Unix shell and so
you&#8217;ll sometimes have trouble when listing the <B>.class</B> files. This
is a bit strange coming from Sun, a Unix-based company. My guess is that they
weren&#8217;t considering this issue, but instead thought you&#8217;d naturally
focus on the source-code files.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn31" HREF="#fnB31">[31]</A><FONT FACE="Georgia" SIZE=2>
For some reason this has always been a pleasing problem for me to solve; it came
from <I>C++ Inside &amp; Out</I>, but Java allows a much more elegant
solution.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter06.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter08.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/04/2000</P></DIV>

</BODY>

</HTML>
