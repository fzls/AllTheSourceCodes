<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:Tjava14.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/04/2000
Translation Time:23:25:26
Translation Platform:Win32
Number of Output files:27
This File:Chapter11.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>11: Run-time type identification</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/TIJ2/index.html">2nd Edition</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/javaCD2.html">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 1st edition</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;1998 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter10.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter12.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_12"></A><A NAME="_Toc375545404"></A><A NAME="_Toc407441455"></A><A NAME="_Toc408018644"></A><A NAME="Heading351"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
11: Run-time type identification</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>The idea of run-time type
identification (RTTI) seems fairly simple at first: it lets you find the exact
type of an object when you have a handle to only the base type.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, the <I>need</I> for RTTI
uncovers a whole plethora of interesting (and often perplexing) OO design issues
and raises fundamental questions of how you should structure your programs.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter looks at the ways that
Java allows you to discover information about objects and classes at run-time.
This takes two forms: &#8220;traditional&#8221; RTTI, which assumes that you
have all the types available at compile-time and run-time, and the
&#8220;reflection&#8221; mechanism in Java 1.1,<A NAME="Index1352"></A> which
allows you to discover class information solely at run-time. The
&#8220;traditional&#8221; RTTI will be covered first, followed by a discussion
of
reflection.</FONT><A NAME="_Toc375545405"></A><A NAME="_Toc408018645"></A><BR></P></DIV>
<A NAME="Heading352"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The need for RTTI</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider the now familiar example
of a class hierarchy that uses polymorphism. The generic type is the base class
<B>Shape<A NAME="Index1353"></A><A NAME="Index1354"></A></B>, and the specific
derived types are <B>Circle</B>, <B>Square</B>, and
<B>Triangle</B>:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava118.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is a typical class hierarchy
diagram, with the base class at the top and the derived classes growing
downward. The normal goal in object-oriented
programming<A NAME="Index1355"></A><A NAME="Index1356"></A> is for the bulk of
your code to manipulate handles to the base type (<B>Shape</B>, in this case),
so if you decide to extend the program by adding a new class (<B>Rhomboid</B>,
derived from <B>Shape</B>, for example), the bulk of the code is not affected.
In this example, the dynamically bound method in the <B>Shape</B> interface is
<B>draw(&#160;)</B>, so the intent is for the client programmer to call
<B>draw(&#160;)</B> through a generic <B>Shape</B> handle. <B>draw(&#160;)</B>
is overridden in all of the derived classes, and because it is a dynamically
bound method, the proper behavior will occur even though it is called through a
generic <B>Shape</B> handle. That&#8217;s
<A NAME="Index1357"></A>polymorphism.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, you generally create a
specific object (<B>Circle</B>, <B>Square</B>, or <B>Triangle</B>), upcast it to
a <B>Shape</B> (forgetting the specific type of the object), and use that
anonymous <B>Shape </B>handle in the rest of the program.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a brief review of polymorphism
and <A NAME="Index1358"></A>upcasting, you might code the above example as
follows: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Shapes.java</font>
<font color=#0000ff>package</font> c11;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>interface</font> Shape {
  <font color=#0000ff>void</font> draw();
}

<font color=#0000ff>class</font> Circle <font color=#0000ff>implements</font> Shape {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> draw() {
    System.out.println(<font color=#004488>"Circle.draw()"</font>);
  }
}

<font color=#0000ff>class</font> Square <font color=#0000ff>implements</font> Shape {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> draw() {
    System.out.println(<font color=#004488>"Square.draw()"</font>);
  }
}

<font color=#0000ff>class</font> Triangle <font color=#0000ff>implements</font> Shape {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> draw() {
    System.out.println(<font color=#004488>"Triangle.draw()"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Shapes {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector s = <font color=#0000ff>new</font> Vector();
    s.addElement(<font color=#0000ff>new</font> Circle());
    s.addElement(<font color=#0000ff>new</font> Square());
    s.addElement(<font color=#0000ff>new</font> Triangle());
    Enumeration e = s.elements();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      ((Shape)e.nextElement()).draw();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The base class could be coded as an
<B>interface</B>, an <B>abstract</B> class, or an ordinary class. Since <B>Shape
</B>has no concrete members (that is, members with definitions), and it&#8217;s
not intended that you ever create a plain <B>Shape</B> object, the most
appropriate and flexible representation is an <B>interface</B>. It&#8217;s also
cleaner because you don&#8217;t have all those <B>abstract</B> keywords lying
about.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each of the derived classes
overrides the base-class <B>draw</B> method so it behaves differently. In
<B>main(&#160;)</B>, specific types of <B>Shape</B> are created and then added
to a <B>Vector</B>. This is the point at which the upcast occurs because the
<B>Vector</B> holds only <B>Object</B>s. Since everything in Java (with the
exception of primitives) is an <B>Object</B>, a <B>Vector</B> can also hold
<B>Shape</B> objects. But during an upcast to <B>Object</B>,<B> </B>it also
loses any specific information, including the fact that the objects are
<B>shape</B>s. To the <B>Vector</B>, they are just
<B>Object</B>s.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At the point you fetch an element
out of the <B>Vector</B> with <B>nextElement(&#160;)</B>, things get a little
busy. Since <B>Vector</B> holds only <B>Object</B>s, <B>nextElement(&#160;)</B>
naturally produces an <B>Object</B> handle. But we know it&#8217;s really a
<B>Shape</B> handle, and we want to send <B>Shape</B> messages to that object.
So a <A NAME="Index1359"></A><A NAME="Index1360"></A>cast to <B>Shape </B>is
necessary using the traditional &#8220;<B>(Shape)</B>&#8221; cast. This is the
most basic form of RTTI, since in Java all casts are checked at run-time for
correctness. That&#8217;s exactly what RTTI means: at run-time, the type of an
object is identified.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this case, the RTTI cast is only
partial: the <B>Object</B> is cast to a <B>Shape</B>, and not all the way to a
<B>Circle</B>, <B>Square</B>, or <B>Triangle</B>. That&#8217;s because the only
thing we <I>know</I> at this point is that the <B>Vector</B> is full of
<B>Shape</B>s. At compile-time, this is enforced only by your own self-imposed
rules, but at run-time the cast ensures it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now polymorphism takes over and the
exact method that&#8217;s called for the <B>Shape</B> is determined by whether
the handle is for a <B>Circle</B>, <B>Square</B>, or <B>Triangle</B>. And in
general, this is how it should be; you want the bulk of your code to know as
little as possible about <I>specific</I> types of objects, and to just deal with
the general representation of a family of objects (in this case, <B>Shape</B>).
As a result, your code will be easier to write, read, and maintain, and your
designs will be easier to implement, understand, and change. So polymorphism is
the general goal in object-oriented programming.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But what if you have a special
programming problem that&#8217;s easiest to solve if you know the exact type of
a generic handle<A NAME="Index1361"></A><A NAME="Index1362"></A>? For example,
suppose you want to allow your users to highlight all the shapes of any
particular type by turning them purple. This way, they can find all the
triangles on the screen by highlighting them. This is what RTTI accomplishes:
you can ask a handle to a <B>Shape</B> exactly what type it&#8217;s referring
to.</FONT><A NAME="_Toc312374135"></A><A NAME="_Toc375545406"></A><A NAME="_Toc408018646"></A><BR></P></DIV>
<A NAME="Heading353"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The Class object</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To understand how RTTI works in
Java, you must first know how type information is represented at run time. This
is accomplished through a special kind of object called the
<A NAME="Index1363"></A><A NAME="Index1364"></A><A NAME="Index1365"></A><I>Class
object,</I> which contains information about the class. (This is sometimes
called a <A NAME="Index1366"></A><A NAME="Index1367"></A><I>meta-class.</I>) In
fact, the <B>Class</B> object is used to create all of the &#8220;regular&#8221;
objects of your class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a <B>Class</B> object
for each class that is part of your program. That is, each time you write a new
class, a single <B>Class</B> object is also created (and stored, appropriately
enough, in an identically named <B>.class </B>file). At run time, when you want
to make an object of that class, the
<A NAME="Index1368"></A><A NAME="Index1369"></A>Java Virtual Machine (JVM)
that&#8217;s executing your program first checks to see if the <B>Class</B>
object for that type is loaded. If not, the JVM loads it by finding the
<B>.class </B>file with that name. Thus, a Java program isn&#8217;t completely
loaded before it begins, which is different from many traditional
languages.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the <B>Class</B> object for
that type is in memory, it is used to create all objects of that
type.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If this seems shadowy or if you
don&#8217;t really believe it, here&#8217;s a demonstration program to prove
it:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SweetShop.java</font>
<font color=#009900>// Examination of the way the class loader works</font>

<font color=#0000ff>class</font> Candy {
  <font color=#0000ff>static</font> {
    System.out.println(<font color=#004488>"Loading Candy"</font>);
  }
}

<font color=#0000ff>class</font> Gum {
  <font color=#0000ff>static</font> {
    System.out.println(<font color=#004488>"Loading Gum"</font>);
  }
}

<font color=#0000ff>class</font> Cookie {
  <font color=#0000ff>static</font> {
    System.out.println(<font color=#004488>"Loading Cookie"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SweetShop {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"inside main"</font>);
    <font color=#0000ff>new</font> Candy();
    System.out.println(<font color=#004488>"After creating Candy"</font>);
    <font color=#0000ff>try</font> {
      Class.forName(<font color=#004488>"Gum"</font>);
    } <font color=#0000ff>catch</font>(ClassNotFoundException e) {
      e.printStackTrace();
    }
    System.out.println(
      <font color=#004488>"After Class.forName(\"</font>Gum\<font color=#004488>")"</font>);
    <font color=#0000ff>new</font> Cookie();
    System.out.println(<font color=#004488>"After creating Cookie"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each of the classes <B>Candy</B>,
<B>Gum</B>, and <B>Cookie</B> has a <A NAME="Index1370"></A><B>static</B> clause
that is executed as the class is loaded for the first time. Information will be
printed out to tell you when loading occurs for that class. In
<B>main(&#160;)</B>, the object creations are spread out between print
statements to help detect the time of loading.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A particularly interesting line
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Class.forName(<font color=#004488>"Gum"</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This method is a <B>static</B>
member of <B>Class</B> (to which all <B>Class</B> objects belong). A
<B>Class</B> object is like any other object and so you can get and manipulate a
handle to it. (That&#8217;s what the loader does.) One of the ways to get a
handle to the <B>Class</B> object is
<A NAME="Index1371"></A><A NAME="Index1372"></A><B>forName(&#160;)</B>, which
takes a <B>String</B> containing the textual name (watch the spelling and
capitalization!) of the particular class you want a handle for. It returns a
<B>Class</B> handle.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output of this program for one
JVM is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>inside main
Loading Candy
After creating Candy
Loading Gum
After Class.forName(<font color=#004488>"Gum"</font>)
Loading Cookie
After creating Cookie</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that each <B>Class</B>
object is loaded only when it&#8217;s needed, and the <B>static</B>
initialization is performed upon class loading.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Interestingly enough, a different
JVM yielded:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Loading Candy
Loading Cookie
inside main
After creating Candy
Loading Gum
After Class.forName(<font color=#004488>"Gum"</font>)
After creating Cookie</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It appears that this JVM
anticipated the need for <B>Candy</B> and <B>Cookie</B> by examining the code in
<B>main(&#160;)</B>, but could not see <B>Gum</B> because it was created by a
call to <B>forName(&#160;)</B> and not through a more typical call to
<B>new</B>. While this JVM produces the desired effect because it does get the
classes loaded before they&#8217;re needed, it&#8217;s uncertain whether the
behavior shown is precisely correct.</FONT><BR></P></DIV>
<A NAME="Heading354"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Class literals</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Java 1.1<A NAME="Index1373"></A>
you have a second way to produce the handle to the <B>Class</B> object: use the
<A NAME="Index1374"></A><A NAME="Index1375"></A><I>class literal</I>. In the
above program this would look like:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Gum.<font color=#0000ff>class</font>;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">which is not only simpler, but also
safer since it&#8217;s checked at compile time. Because it eliminates the method
call, it&#8217;s also more efficient.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Class literals work with regular
classes as well as interfaces, arrays, and primitive types. In addition,
there&#8217;s a standard field called <A NAME="Index1376"></A><B>TYPE</B> that
exists for each of the primitive wrapper classes. The <B>TYPE</B> field produces
a handle to the <B>Class</B> object for the associated primitive type, such
that:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=185 COLSPAN=2 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="CENTER"><FONT FACE="Georgia">... is equivalent to
...</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">boolean.class</FONT></TT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Boolean.TYPE</FONT></TT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">char.class</FONT></TT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Character.TYPE</FONT></TT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">byte.class</FONT></TT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Byte.TYPE</FONT></TT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">short.class</FONT></TT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Short.TYPE</FONT></TT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">int.class</FONT></TT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Integer.TYPE</FONT></TT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">long.class</FONT></TT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Long.TYPE</FONT></TT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">float.class</FONT></TT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Float.TYPE</FONT></TT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">double.class</FONT></TT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Double.TYPE</FONT></TT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">void.class</FONT></TT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Void.TYPE</FONT></TT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545408"></A><A NAME="_Toc408018647"></A></TABLE></P></DIV>
<A NAME="Heading355"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Checking before a cast</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So far, you&#8217;ve seen RTTI
forms including:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	The classic cast, e.g.
&#8220;<B>(Shape),</B>&#8221; which uses RTTI to make sure the cast is correct
and throws a <B>ClassCastException</B> if you&#8217;ve performed a bad
cast.</FONT><LI><FONT FACE="Georgia">	The <B>Class</B> object representing
the type of your object. The <B>Class</B> object can be queried for useful
runtime information.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In
C++, the classic cast &#8220;<B>(Shape)</B>&#8221; does <I>not </I>perform RTTI.
It simply tells the compiler to treat the object as the new type. In Java, which
does perform the type check, this cast is often called a &#8220;type safe
downcast<A NAME="Index1377"></A><A NAME="Index1378"></A><A NAME="Index1379"></A>.&#8221;
The reason for the term &#8220;downcast&#8221; is the historical arrangement of
the class hierarchy diagram. If casting a <B>Circle</B> to a <B>Shape</B> is an
upcast, then casting a <B>Shape</B> to a <B>Circle</B> is a downcast. However,
you know a <B>Circle</B> is also a <B>Shape</B>, and the compiler freely allows
an upcast assignment, but you <I>don&#8217;t</I> know that a <B>Shape</B> is
necessarily a <B>Circle</B>, so the compiler doesn&#8217;t allow you to perform
a <A NAME="Index1380"></A><A NAME="Index1381"></A>downcast assignment without
using an explicit cast. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a third form of RTTI
in Java. This is the <A NAME="Index1382"></A><A NAME="Index1383"></A>keyword
<B>instanceof</B> that tells you if an object is an instance of a particular
type. It returns a <B>boolean </B>so you use it in the form of a question, like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(x <font color=#0000ff>instanceof</font> Dog)
  ((Dog)x).bark();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The above <B>if</B> statement
checks to see if the object <B>x</B> belongs to the class <B>Dog</B>
<I>before</I> casting <B>x</B> to a <B>Dog</B>. It&#8217;s important to use
<B>instanceof</B> before a downcast when you don&#8217;t have other information
that tells you the type of the object; otherwise you&#8217;ll end up with a
<A NAME="Index1384"></A><A NAME="Index1385"></A><B>ClassCastException</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Ordinarily, you might be hunting
for one type (triangles to turn purple, for example), but the following program
shows how to tally <I>all</I> of the objects using
<B>instanceof</B>.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PetCount.java</font>
<font color=#009900>// Using instanceof</font>
<font color=#0000ff>package</font> c11.petcount;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Pet {}
<font color=#0000ff>class</font> Dog <font color=#0000ff>extends</font> Pet {}
<font color=#0000ff>class</font> Pug <font color=#0000ff>extends</font> Dog {}
<font color=#0000ff>class</font> Cat <font color=#0000ff>extends</font> Pet {}
<font color=#0000ff>class</font> Rodent <font color=#0000ff>extends</font> Pet {}
<font color=#0000ff>class</font> Gerbil <font color=#0000ff>extends</font> Rodent {}
<font color=#0000ff>class</font> Hamster <font color=#0000ff>extends</font> Rodent {}

<font color=#0000ff>class</font> Counter { <font color=#0000ff>int</font> i; }

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PetCount {
  <font color=#0000ff>static</font> String[] typenames = {
    <font color=#004488>"Pet"</font>, <font color=#004488>"Dog"</font>, <font color=#004488>"Pug"</font>, <font color=#004488>"Cat"</font>,
    <font color=#004488>"Rodent"</font>, <font color=#004488>"Gerbil"</font>, <font color=#004488>"Hamster"</font>,
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector pets = <font color=#0000ff>new</font> Vector();
    <font color=#0000ff>try</font> {
      Class[] petTypes = {
        Class.forName(<font color=#004488>"c11.petcount.Dog"</font>),
        Class.forName(<font color=#004488>"c11.petcount.Pug"</font>),
        Class.forName(<font color=#004488>"c11.petcount.Cat"</font>),
        Class.forName(<font color=#004488>"c11.petcount.Rodent"</font>),
        Class.forName(<font color=#004488>"c11.petcount.Gerbil"</font>),
        Class.forName(<font color=#004488>"c11.petcount.Hamster"</font>),
      };
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 15; i++)
        pets.addElement(
          petTypes[
            (<font color=#0000ff>int</font>)(Math.random()*petTypes.length)]
            .newInstance());
    } <font color=#0000ff>catch</font>(InstantiationException e) {}
      <font color=#0000ff>catch</font>(IllegalAccessException e) {}
      <font color=#0000ff>catch</font>(ClassNotFoundException e) {}
    Hashtable h = <font color=#0000ff>new</font> Hashtable();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; typenames.length; i++)
      h.put(typenames[i], <font color=#0000ff>new</font> Counter());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; pets.size(); i++) {
      Object o = pets.elementAt(i);
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Pet)
        ((Counter)h.get(<font color=#004488>"Pet"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Dog)
        ((Counter)h.get(<font color=#004488>"Dog"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Pug)
        ((Counter)h.get(<font color=#004488>"Pug"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Cat)
        ((Counter)h.get(<font color=#004488>"Cat"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Rodent)
        ((Counter)h.get(<font color=#004488>"Rodent"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Gerbil)
        ((Counter)h.get(<font color=#004488>"Gerbil"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Hamster)
        ((Counter)h.get(<font color=#004488>"Hamster"</font>)).i++;
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; pets.size(); i++)
      System.out.println(
        pets.elementAt(i).getClass().toString());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; typenames.length; i++)
      System.out.println(
        typenames[i] + <font color=#004488>" quantity: "</font> +
        ((Counter)h.get(typenames[i])).i);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><A NAME="_Toc305593310"></A><A NAME="_Toc305628782"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a rather narrow
restriction on <B>instanceof </B>in Java 1.0<A NAME="Index1386"></A>: You can
compare it to a named type only, and not to a <B>Class</B> object. In the
example above you might feel that it&#8217;s tedious to write out all of those
<B>instanceof</B> expressions, and you&#8217;re right. But in Java 1.0 there is
no way to cleverly automate it by creating a <B>Vector</B> of <B>Class</B>
objects and comparing it to those instead. This isn&#8217;t as great a
restriction as you might think, because you&#8217;ll eventually understand that
your design is probably flawed if you end up writing a lot of <B>instanceof</B>
expressions.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course this example is contrived
&#8211; you&#8217;d probably put a <B>static</B> data member in each type and
increment it in the constructor to keep track of the counts. You would do
something like that <I>if</I> you had control of the source code for the class
and could change it. Since this is not always the case, RTTI can come in
handy.</FONT><BR></P></DIV>
<A NAME="Heading356"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Using class literals</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s interesting to see how
the <B>PetCount.java</B> example can be rewritten using Java
1.1<A NAME="Index1387"></A> class
literals<A NAME="Index1388"></A><A NAME="Index1389"></A>. The result is cleaner
in many ways:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PetCount2.java</font>
<font color=#009900>// Using Java 1.1 class literals</font>
<font color=#0000ff>package</font> c11.petcount2;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Pet {}
<font color=#0000ff>class</font> Dog <font color=#0000ff>extends</font> Pet {}
<font color=#0000ff>class</font> Pug <font color=#0000ff>extends</font> Dog {}
<font color=#0000ff>class</font> Cat <font color=#0000ff>extends</font> Pet {}
<font color=#0000ff>class</font> Rodent <font color=#0000ff>extends</font> Pet {}
<font color=#0000ff>class</font> Gerbil <font color=#0000ff>extends</font> Rodent {}
<font color=#0000ff>class</font> Hamster <font color=#0000ff>extends</font> Rodent {}

<font color=#0000ff>class</font> Counter { <font color=#0000ff>int</font> i; }

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PetCount2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector pets = <font color=#0000ff>new</font> Vector();
    Class[] petTypes = {
      <font color=#009900>// Class literals work in Java 1.1+ only:</font>
      Pet.<font color=#0000ff>class</font>,
      Dog.<font color=#0000ff>class</font>,
      Pug.<font color=#0000ff>class</font>,
      Cat.<font color=#0000ff>class</font>,
      Rodent.<font color=#0000ff>class</font>,
      Gerbil.<font color=#0000ff>class</font>,
      Hamster.<font color=#0000ff>class</font>,
    };
    <font color=#0000ff>try</font> {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 15; i++) {
        <font color=#009900>// Offset by one to eliminate Pet.class:</font>
        <font color=#0000ff>int</font> rnd = 1 + (<font color=#0000ff>int</font>)(
          Math.random() * (petTypes.length - 1));
        pets.addElement(
          petTypes[rnd].newInstance());
      }
    } <font color=#0000ff>catch</font>(InstantiationException e) {}
      <font color=#0000ff>catch</font>(IllegalAccessException e) {}
    Hashtable h = <font color=#0000ff>new</font> Hashtable();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; petTypes.length; i++)
      h.put(petTypes[i].toString(),
        <font color=#0000ff>new</font> Counter());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; pets.size(); i++) {
      Object o = pets.elementAt(i);
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Pet)
        ((Counter)h.get(
          <font color=#004488>"class c11.petcount2.Pet"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Dog)
        ((Counter)h.get(
          <font color=#004488>"class c11.petcount2.Dog"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Pug)
        ((Counter)h.get(
          <font color=#004488>"class c11.petcount2.Pug"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Cat)
        ((Counter)h.get(
          <font color=#004488>"class c11.petcount2.Cat"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Rodent)
        ((Counter)h.get(
          <font color=#004488>"class c11.petcount2.Rodent"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Gerbil)
        ((Counter)h.get(
          <font color=#004488>"class c11.petcount2.Gerbil"</font>)).i++;
      <font color=#0000ff>if</font>(o <font color=#0000ff>instanceof</font> Hamster)
        ((Counter)h.get(
          <font color=#004488>"class c11.petcount2.Hamster"</font>)).i++;
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; pets.size(); i++)
      System.out.println(
        pets.elementAt(i).getClass().toString());
    Enumeration keys = h.keys();
    <font color=#0000ff>while</font>(keys.hasMoreElements()) {
      String nm = (String)keys.nextElement();
      Counter cnt = (Counter)h.get(nm);
      System.out.println(
        nm.substring(nm.lastIndexOf('.') + 1) + 
        <font color=#004488>" quantity: "</font> + cnt.i);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, the <B>typenames</B> array
has been removed in favor of getting the type name strings from the <B>Class</B>
object. Notice the extra work for this: the class name is not, for example,
<B>Gerbil,</B> but instead <B>c11.petcount2.Gerbil</B> since the package name is
included. Notice also that the system can distinguish between classes and
interfaces.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also see that the creation
of <B>petTypes</B> does not need to be surrounded by a <B>try</B> block since
it&#8217;s evaluated at compile time and thus won&#8217;t throw any exceptions,
unlike <B>Class.forName(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the <B>Pet</B> objects are
dynamically created, you can see that the random number is restricted so it is
between 1 and <B>petTypes.length</B> and does not include zero. That&#8217;s
because zero refers to <B>Pet.class</B>, and presumably a generic <B>Pet</B>
object is not interesting. However, since <B>Pet.class</B> is part of
<B>petTypes</B> the result is that all of the pets get counted.</FONT><BR></P></DIV>
<A NAME="Heading357"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
A dynamic instanceof<BR><A NAME="Index1390"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1<A NAME="Index1391"></A>
has added the
<A NAME="Index1392"></A><A NAME="Index1393"></A><A NAME="Index1394"></A><B>isInstance</B>
method to the class <B>Class</B>. This allows you to dynamically call the
<B>instanceof</B> operator, which you could do only statically in Java
1.0<A NAME="Index1395"></A> (as previously shown). Thus, all those tedious
<B>instanceof</B> statements can be removed in the <B>PetCount</B>
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PetCount3.java</font>
<font color=#009900>// Using Java 1.1 isInstance()</font>
<font color=#0000ff>package</font> c11.petcount3;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Pet {}
<font color=#0000ff>class</font> Dog <font color=#0000ff>extends</font> Pet {}
<font color=#0000ff>class</font> Pug <font color=#0000ff>extends</font> Dog {}
<font color=#0000ff>class</font> Cat <font color=#0000ff>extends</font> Pet {}
<font color=#0000ff>class</font> Rodent <font color=#0000ff>extends</font> Pet {}
<font color=#0000ff>class</font> Gerbil <font color=#0000ff>extends</font> Rodent {}
<font color=#0000ff>class</font> Hamster <font color=#0000ff>extends</font> Rodent {}

<font color=#0000ff>class</font> Counter { <font color=#0000ff>int</font> i; }

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PetCount3 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector pets = <font color=#0000ff>new</font> Vector();
    Class[] petTypes = {
      Pet.<font color=#0000ff>class</font>,
      Dog.<font color=#0000ff>class</font>,
      Pug.<font color=#0000ff>class</font>,
      Cat.<font color=#0000ff>class</font>,
      Rodent.<font color=#0000ff>class</font>,
      Gerbil.<font color=#0000ff>class</font>,
      Hamster.<font color=#0000ff>class</font>,
    };
    <font color=#0000ff>try</font> {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 15; i++) {
        <font color=#009900>// Offset by one to eliminate Pet.class:</font>
        <font color=#0000ff>int</font> rnd = 1 + (<font color=#0000ff>int</font>)(
          Math.random() * (petTypes.length - 1));
        pets.addElement(
          petTypes[rnd].newInstance());
      }
    } <font color=#0000ff>catch</font>(InstantiationException e) {}
      <font color=#0000ff>catch</font>(IllegalAccessException e) {}
    Hashtable h = <font color=#0000ff>new</font> Hashtable();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; petTypes.length; i++)
      h.put(petTypes[i].toString(),
        <font color=#0000ff>new</font> Counter());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; pets.size(); i++) {
      Object o = pets.elementAt(i);
      <font color=#009900>// Using isInstance to eliminate individual</font>
      <font color=#009900>// instanceof expressions:</font>
      <font color=#0000ff>for</font> (<font color=#0000ff>int</font> j = 0; j &lt; petTypes.length; ++j)
        <font color=#0000ff>if</font> (petTypes[j].isInstance(o)) {
          String key = petTypes[j].toString();
          ((Counter)h.get(key)).i++;
        }
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; pets.size(); i++)
      System.out.println(
        pets.elementAt(i).getClass().toString());
    Enumeration keys = h.keys();
    <font color=#0000ff>while</font>(keys.hasMoreElements()) {
      String nm = (String)keys.nextElement();
      Counter cnt = (Counter)h.get(nm);
      System.out.println(
        nm.substring(nm.lastIndexOf('.') + 1) + 
        <font color=#004488>" quantity: "</font> + cnt.i);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the Java
1.1<A NAME="Index1396"></A> <B>isInstance(&#160;)</B> method has eliminated the
need for the <B>instanceof</B> expressions. In addition, this means that you can
add new types of pets simply by changing the <B>petTypes</B> array; the rest of
the program does not need modification (as it did when using the
<B>instanceof</B>
expressions).</FONT><A NAME="_Toc305593313"></A><A NAME="_Toc305628785"></A><A NAME="_Toc312374146"></A><A NAME="_Toc375545409"></A><A NAME="_Toc375545407"></A><A NAME="_Toc408018648"></A><BR></P></DIV>
<A NAME="Heading358"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
RTTI syntax</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java performs its
<A NAME="Index1397"></A><A NAME="Index1398"></A>RTTI using the <B>Class</B>
object, even if you&#8217;re doing something like a cast. The class <B>Class</B>
also has a number of other ways you can use RTTI.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, you must get a handle to the
appropriate <B>Class</B> object. One way to do this, as shown in the previous
example, is to use a string and the <B>Class.forName(&#160;)</B> method. This is
convenient because you don&#8217;t need an object of that type in order to get
the <B>Class</B> handle. However, if you do already have an object of the type
you&#8217;re interested in, you can fetch the <B>Class</B> handle by calling a
method that&#8217;s part of the <B>Object</B> root class:<B>
<A NAME="Index1399"></A><A NAME="Index1400"></A>getClass(&#160;)</B>. This
returns the <B>Class</B> handle representing the actual type of the object.
<B>Class</B> has several interesting and sometimes useful methods, demonstrated
in the following example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ToyTest.java</font>
<font color=#009900>// Testing class Class</font>

<font color=#0000ff>interface</font> HasBatteries {}
<font color=#0000ff>interface</font> Waterproof {}
<font color=#0000ff>interface</font> ShootsThings {}
<font color=#0000ff>class</font> Toy {
  <font color=#009900>// Comment out the following default</font>
  <font color=#009900>// constructor to see </font>
  <font color=#009900>// NoSuchMethodError from (*1*)</font>
  Toy() {} 
  Toy(<font color=#0000ff>int</font> i) {} 
}

<font color=#0000ff>class</font> FancyToy <font color=#0000ff>extends</font> Toy 
    <font color=#0000ff>implements</font> HasBatteries, 
      Waterproof, ShootsThings {
  FancyToy() { <font color=#0000ff>super</font>(1); }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ToyTest {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Class c = <font color=#0000ff>null</font>;
    <font color=#0000ff>try</font> {
      c = Class.forName(<font color=#004488>"FancyToy"</font>);
    } <font color=#0000ff>catch</font>(ClassNotFoundException e) {}
    printInfo(c);
    Class[] faces = c.getInterfaces();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; faces.length; i++)
      printInfo(faces[i]);
    Class cy = c.getSuperclass();
    Object o = <font color=#0000ff>null</font>;
    <font color=#0000ff>try</font> {
      <font color=#009900>// Requires default constructor:</font>
      o = cy.newInstance(); <font color=#009900>// (*1*)</font>
    } <font color=#0000ff>catch</font>(InstantiationException e) {}
      <font color=#0000ff>catch</font>(IllegalAccessException e) {}
    printInfo(o.getClass());
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printInfo(Class cc) {
    System.out.println(
      <font color=#004488>"Class name: "</font> + cc.getName() +
      <font color=#004488>" is interface? ["</font> +
      cc.isInterface() + <font color=#004488>"]"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that <B>class
FancyToy</B> is quite complicated, since it inherits from <B>Toy</B> and
<B>implements</B> the <B>interface</B>s of <B>HasBatteries</B>,
<B>Waterproof</B>, and <B>ShootsThings</B>. In <B>main(&#160;)</B>, a
<B>Class</B> handle is created and initialized to the <B>FancyToy</B>
<B>Class</B> using <B>forName(&#160;)</B> inside an appropriate <B>try</B>
block.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<B>Class.getInterfaces(&#160;)</B>
<A NAME="Index1401"></A><A NAME="Index1402"></A>method returns an array of
<B>Class</B> objects representing the interfaces that are contained in the
<B>Class</B> object of interest.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you have a <B>Class</B> object
you can also ask it for its direct base class using
<A NAME="Index1403"></A><A NAME="Index1404"></A><B>getSuperclass(&#160;)</B>.
This, of course, returns a <B>Class</B> handle that you can further query. This
means that, at run time, you can discover an object&#8217;s entire class
hierarchy.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1405"></A><A NAME="Index1406"></A><B>newInstance(&#160;)</B>
method of <B>Class</B> can, at first, seem like just another way to
<B>clone(&#160;)</B> an object. However, you can create a new object with
<B>newInstance(&#160;)</B> <I>without</I> an existing object, as seen here,
because there is no <B>Toy</B> object, only <B>cy</B>, which is a handle to
<B>y</B>&#8217;s <B>Class</B> object. This is a way to implement a
&#8220;virtual constructor,&#8221; which allows you to say &#8220;I don&#8217;t
know exactly what type you are, but create yourself properly anyway.&#8221; In
the example above, <B>cy</B> is just a <B>Class</B> handle with no further type
information known at compile time. And when you create a new instance, you get
back an <B>Object</B> handle. But that handle is pointing to a <B>Toy</B>
object. Of course, before you can send any messages other than those accepted by
<B>Object</B>, you have to investigate it a bit and do some casting. In
addition, the class that&#8217;s being created with <B>newInstance(&#160;)</B>
must have a default constructor. There&#8217;s no way to use
<B>newInstance(&#160;) </B>to create objects that have non-default constructors,
so this can be a bit limiting in Java 1. However, the <I>reflection</I> API in
Java 1.1<A NAME="Index1407"></A> (discussed in the next section) allows you to
dynamically use any constructor in a class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The final method in the listing is
<A NAME="Index1408"></A><A NAME="Index1409"></A><B>printInfo(&#160;),</B> which
takes a <B>Class</B> handle and gets its name with
<A NAME="Index1410"></A><A NAME="Index1411"></A><B>getName(&#160;),</B> and
finds out whether it&#8217;s an interface with
<A NAME="Index1412"></A><A NAME="Index1413"></A><B>isInterface(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output from this program
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Class name: FancyToy is <font color=#0000ff>interface</font>? [<font color=#0000ff>false</font>]
Class name: HasBatteries is <font color=#0000ff>interface</font>? [<font color=#0000ff>true</font>]
Class name: Waterproof is <font color=#0000ff>interface</font>? [<font color=#0000ff>true</font>]
Class name: ShootsThings is <font color=#0000ff>interface</font>? [<font color=#0000ff>true</font>]
Class name: Toy is <font color=#0000ff>interface</font>? [<font color=#0000ff>false</font>]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, with the <B>Class</B> object
you can find out just about everything you want to know about an
object.</FONT><A NAME="_Toc312374147"></A><A NAME="_Toc375545410"></A><A NAME="_Toc408018649"></A><BR></P></DIV>
<A NAME="Heading359"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Reflection: run-time <BR>class
information<BR><A NAME="Index1414"></A><A NAME="Index1415"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you don&#8217;t know the precise
type of an object, RTTI will tell you. However, there&#8217;s a limitation: the
type must be known at compile time in order for you to be able to detect it
using RTTI and do something useful with the information. Put another way, the
compiler must know about all the classes you&#8217;re working with for
RTTI.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This doesn&#8217;t seem like that
much of a limitation at first, but suppose you&#8217;re given a handle to an
object that&#8217;s not in your program space. In fact, the class of the object
isn&#8217;t even available to your program at compile time. For example, suppose
you get a bunch of bytes from a disk file or from a network connection and
you&#8217;re told that those bytes represent a class. Since the compiler
can&#8217;t know about the class while it&#8217;s compiling the code, how can
you possibly use such a class?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In a traditional programming
environment this seems like a far-fetched scenario. But as we move into a larger
programming world there are important cases in which this happens. The first is
component-based programming in which you build projects using
<A NAME="Index1416"></A><I>Rapid Application Development</I> (RAD) in an
application builder tool. This is a visual approach to creating a program (which
you see on the screen as a <I>form</I>) by moving icons that represent
components onto the form. These components are then configured by setting some
of their values at program time. This design-time configuration requires that
any component be instantiable and that it expose some part of itself and allow
its values to be read and set. In addition, components that handle GUI events
must expose information about appropriate methods so that the RAD environment
can assist the programmer in overriding these event-handling methods. Reflection
provides the mechanism to detect the available methods and produce the method
names. <A NAME="Index1417"></A>Java 1.1 provides a structure for component-based
programming through Java Beans (described in Chapter 13).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another compelling motivation for
discovering class information at run-time is to provide the ability to create
and execute objects on remote platforms across a network. This is called
<I>Remote Method Invocation</I> (RMI) and it allows a Java program (version 1.1
and higher) to have objects distributed across many machines. This distribution
can happen for a number of reasons: perhaps you&#8217;re doing a
computation-intensive task and you want to break it up and put pieces on
machines that are idle in order to speed things up. In some situations you might
want to place code that handles particular types of tasks (e.g. &#8220;Business
Rules&#8221; in a multi-tier client/server architecture) on a particular machine
so that machine becomes a common repository describing those actions and it can
be easily changed to affect everyone in the system. (This is an interesting
development since the machine exists solely to make software changes easy!)
Along these lines, distributed computing also supports specialized hardware that
might be good at a particular task &#8211; matrix inversions, for example
&#8211; but inappropriate or too expensive for general purpose
programming.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Java
1.1<A NAME="Index1418"></A>, the class <B>Class</B> (described previously in
this chapter) is extended to support the concept of <I>reflection</I>, and
there&#8217;s an additional library, <B>java.lang.reflect, </B>with classes
<A NAME="Index1419"></A><A NAME="Index1420"></A><B>Field</B>,
<A NAME="Index1421"></A><A NAME="Index1422"></A><B>Method</B>, and
<A NAME="Index1423"></A><A NAME="Index1424"></A><B>Constructor </B>(each of
which implement the <B>Member interface</B>). Objects of these types are created
by the JVM at run-time to represent the corresponding member in the unknown
class. You can then use the <B>Constructor</B>s to create new objects, the
<B>get(&#160;)</B> and <B>set(&#160;)</B> methods to read and modify the fields
associated with <B>Field</B> objects, and the <B>invoke(&#160;)</B> method to
call a method associated with a <B>Method</B> object. In addition, you can call
the convenience methods <B>getFields(&#160;)</B>, <B>getMethods(&#160;)</B>,
<B>getConstructors(&#160;)</B>, etc., to return arrays of the objects
representing the fields, methods, and constructors. (You can find out more by
looking up the class <B>Class</B> in your online documentation.)<B> </B>Thus,
the class information for anonymous objects can be completely determined at run
time, and nothing need be known at compile time.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s important to realize
that there&#8217;s nothing magic about reflection. When you&#8217;re using
reflection to interact with an object of an unknown type, the JVM will simply
look at the object and see that it belongs to a particular class (just like
ordinary RTTI) but then, before it can do anything else, the <B>Class</B> object
must be loaded. Thus, the <B>.class</B> file for that particular type must still
be available to the JVM, either on the local machine or across the network. So
the true <A NAME="Index1425"></A><A NAME="Index1426"></A>difference between RTTI
and reflection is that with RTTI, the compiler opens and examines the
<B>.class</B> file at compile time. Put another way, you can call all the
methods of an object in the &#8220;normal&#8221; way. With reflection, the
<B>.class</B> file is unavailable at compile time; it is opened and examined by
the run-time environment.</FONT><A NAME="_Toc408018650"></A><BR></P></DIV>
<A NAME="Heading360"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A class method extractor</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll rarely need to use the
reflection tools directly; they&#8217;re in the language to support the other
Java features such as object serialization (described in Chapter 10), Java
Beans, and RMI (described later in the book). However, there are times when
it&#8217;s quite useful to be able to dynamically extract information about a
class. One extremely useful tool is a class method extractor. As mentioned
before, looking at a class definition source code or online documentation shows
only the methods that are defined or overridden <I>within that class
definition</I>. But there could be dozens more available to you that have come
from base classes. To locate these is both tedious and time consuming.
Fortunately, reflection provides a way to write a simple tool that will
automatically show you the entire interface. Here&#8217;s the way it
works:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ShowMethods.java</font>
<font color=#009900>// Using Java 1.1 reflection to show all the </font>
<font color=#009900>// methods of a class, even if the methods are </font>
<font color=#009900>// defined in the base class.</font>
<font color=#0000ff>import</font> java.lang.reflect.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ShowMethods {
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> String usage =
    <font color=#004488>"usage: \n"</font> +
    <font color=#004488>"ShowMethods qualified.class.name\n"</font> +
    <font color=#004488>"To show all methods in class or: \n"</font> +
    <font color=#004488>"ShowMethods qualified.class.name word\n"</font> +
    <font color=#004488>"To search for methods involving 'word'"</font>;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length &lt; 1) {
      System.out.println(usage);
      System.exit(0);
    }
    <font color=#0000ff>try</font> {
      Class c = Class.forName(args[0]);
      Method[] m = c.getMethods();
      Constructor[] ctor = c.getConstructors();
      <font color=#0000ff>if</font>(args.length == 1) {
        <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; m.length; i++)
          System.out.println(m[i].toString());
        <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; ctor.length; i++)
          System.out.println(ctor[i].toString());
      } 
      <font color=#0000ff>else</font> {
        <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; m.length; i++)
          <font color=#0000ff>if</font>(m[i].toString()
             .indexOf(args[1])!= -1)
            System.out.println(m[i].toString());
        <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; ctor.length; i++)
          <font color=#0000ff>if</font>(ctor[i].toString()
             .indexOf(args[1])!= -1)
          System.out.println(ctor[i].toString());
      }
    } <font color=#0000ff>catch</font> (ClassNotFoundException e) {
      System.out.println(<font color=#004488>"No such class: "</font> + e);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Class</B> methods
<A NAME="Index1427"></A><A NAME="Index1428"></A><B>getMethods(&#160;)</B> and
<A NAME="Index1429"></A><A NAME="Index1430"></A><B>getConstructors(&#160;)</B>
return an array of <B>Method</B> and <B>Constructor</B>, respectively. Each of
these classes has further methods to dissect the names, arguments, and return
values of the methods they represent. But you can also just use
<B>toString(&#160;)</B>, as is done here, to produce a <B>String</B> with the
entire method signature. The rest of the code is just for extracting command
line information, determining if a particular signature matches with your target
string (using
<A NAME="Index1431"></A><A NAME="Index1432"></A><B>indexOf(&#160;)</B>), and
printing the results.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This shows reflection in action,
since the result produced by <B>Class.forName(&#160;)</B> cannot be known at
compile-time, and therefore all the method signature information is being
extracted at run-time. If you investigate your online documentation on
reflection, you&#8217;ll see that there is enough support to actually set up and
make a method call on an object that&#8217;s totally unknown at compile-time.
Again, this is something you&#8217;ll probably never need to do yourself &#8211;
the support is there for Java and so a programming environment can manipulate
Java Beans &#8211; but it&#8217;s interesting.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An interesting experiment is to run
<B>java ShowMethods ShowMethods</B>. This produces a listing that includes a
<B>public</B> default constructor, even though you can see from the code that no
constructor was defined. The constructor you see is the one that&#8217;s
automatically synthesized by the compiler. If you then make <B>ShowMethods</B> a
non-<B>public</B> class (that is, friendly), the synthesized default constructor
no longer shows up in the output. The synthesized default constructor is
automatically given the same access as the class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output for <B>ShowMethods</B>
is still a little tedious. For example, here&#8217;s a portion of the output
produced by invoking <B>java ShowMethods java.lang.String</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
  java.lang.String.startsWith(java.lang.String,<font color=#0000ff>int</font>)
<font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
  java.lang.String.startsWith(java.lang.String)
<font color=#0000ff>public</font> <font color=#0000ff>boolean</font>
  java.lang.String.endsWith(java.lang.String)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It would be even nicer if the
qualifiers like <B>java.lang</B> could be stripped off. The
<A NAME="Index1433"></A><A NAME="Index1434"></A><B>StreamTokenizer</B> class
introduced in the previous chapter can help solve this problem:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ShowMethodsClean.java</font>
<font color=#009900>// ShowMethods with the qualifiers stripped</font>
<font color=#009900>// to make the results easier to read</font>
<font color=#0000ff>import</font> java.lang.reflect.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ShowMethodsClean {
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> String usage =
    <font color=#004488>"usage: \n"</font> +
    <font color=#004488>"ShowMethodsClean qualified.class.name\n"</font> +
    <font color=#004488>"To show all methods in class or: \n"</font> +
    <font color=#004488>"ShowMethodsClean qualif.class.name word\n"</font> +
    <font color=#004488>"To search for methods involving 'word'"</font>;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length &lt; 1) {
      System.out.println(usage);
      System.exit(0);
    }
    <font color=#0000ff>try</font> {
      Class c = Class.forName(args[0]);
      Method[] m = c.getMethods();
      Constructor[] ctor = c.getConstructors();
      <font color=#009900>// Convert to an array of cleaned Strings:</font>
      String[] n = 
        <font color=#0000ff>new</font> String[m.length + ctor.length];
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; m.length; i++) {
        String s = m[i].toString();
        n[i] = StripQualifiers.strip(s);
      }
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; ctor.length; i++) {
        String s = ctor[i].toString();
        n[i + m.length] = 
          StripQualifiers.strip(s);
      }
      <font color=#0000ff>if</font>(args.length == 1)
        <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; n.length; i++)
          System.out.println(n[i]);
      <font color=#0000ff>else</font>
        <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; n.length; i++)
          <font color=#0000ff>if</font>(n[i].indexOf(args[1])!= -1)
            System.out.println(n[i]);
    } <font color=#0000ff>catch</font> (ClassNotFoundException e) {
      System.out.println(<font color=#004488>"No such class: "</font> + e);
    }
  }
}

<font color=#0000ff>class</font> StripQualifiers {
  <font color=#0000ff>private</font> StreamTokenizer st;
  <font color=#0000ff>public</font> StripQualifiers(String qualified) {
      st = <font color=#0000ff>new</font> StreamTokenizer(
        <font color=#0000ff>new</font> StringReader(qualified));
      st.ordinaryChar(' '); <font color=#009900>// Keep the spaces</font>
  }
  <font color=#0000ff>public</font> String getNext() {
    String s = <font color=#0000ff>null</font>;
    <font color=#0000ff>try</font> {
      <font color=#0000ff>if</font>(st.nextToken() !=
            StreamTokenizer.TT_EOF) {
        <font color=#0000ff>switch</font>(st.ttype) {
          <font color=#0000ff>case</font> StreamTokenizer.TT_EOL:
            s = <font color=#0000ff>null</font>;
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_NUMBER:
            s = Double.toString(st.nval);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_WORD:
            s = <font color=#0000ff>new</font> String(st.sval);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>default</font>: <font color=#009900>// single character in ttype</font>
            s = String.valueOf((<font color=#0000ff>char</font>)st.ttype);
        }
      }
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(e);
    }
    <font color=#0000ff>return</font> s;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String strip(String qualified) {
    StripQualifiers sq = 
      <font color=#0000ff>new</font> StripQualifiers(qualified);
    String s = <font color=#004488>""</font>, si;
    <font color=#0000ff>while</font>((si = sq.getNext()) != <font color=#0000ff>null</font>) {
      <font color=#0000ff>int</font> lastDot = si.lastIndexOf('.');
      <font color=#0000ff>if</font>(lastDot != -1)
        si = si.substring(lastDot + 1);
      s += si;
    }
    <font color=#0000ff>return</font> s;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class <B>ShowMethodsClean</B>
is quite similar to the previous <B>ShowMethods</B>, except that it takes the
arrays of <B>Method</B> and <B>Constructor</B> and converts them into a single
array of <B>String</B>. Each of these <B>String</B> objects is then passed
through<B> StripQualifiers.Strip(&#160;)</B> to remove all the method
qualification. As you can see, this uses the <B>StreamTokenizer</B> and
<B>String</B> manipulation to do its work.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This tool can be a real time-saver
while you&#8217;re programming, when you can&#8217;t remember if a class has a
particular method and you don&#8217;t want to go walking through the class
hierarchy in the online documentation, or if you don&#8217;t know whether that
class can do anything with, for example, <B>Color</B> objects.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Chapter 17 contains a GUI version
of this program so you can leave it running while you&#8217;re writing code, to
allow quick
lookups.</FONT><A NAME="_Toc375545411"></A><A NAME="_Toc408018651"></A><BR></P></DIV>
<A NAME="Heading361"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary<BR><A NAME="Index1435"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">RTTI allows you to discover type
information from an anonymous base-class handle. Thus, it&#8217;s ripe for
misuse <A NAME="Index1436"></A>by the novice since it might make sense before
polymorphic method calls do. For many people coming from a procedural
background, it&#8217;s difficult not to organize their programs into sets of
<B>switch</B> statements. They could accomplish this with RTTI and thus lose the
important value of polymorphism <A NAME="Index1437"></A>in code development and
maintenance. The intent of Java is that you use polymorphic method calls
throughout your code, and you use RTTI only when you must.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, using polymorphic method
calls as they are intended requires that you have control of the base-class
definition because at some point in the extension of your program you might
discover that the base class doesn&#8217;t include the method you need. If the
base class comes from a library or is otherwise controlled by someone else, a
solution to the problem is RTTI: You can inherit a new type and add your extra
method. Elsewhere in the code you can detect your particular type and call that
special method. This doesn&#8217;t destroy the polymorphism and extensibility of
the program because adding a new type will not require you to hunt for switch
statements in your program. However, when you add new code in your main body
that requires your new feature, you must use RTTI to detect your particular
type.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Putting a feature in a base class
might mean that, for the benefit of one particular class, all of the other
classes derived from that base require some meaningless stub of a method. This
makes the interface less clear and annoys those who must override abstract
methods when they derive from that base class. For example, consider a class
hierarchy representing musical instruments. Suppose you wanted to clear the spit
valves of all the appropriate instruments in your orchestra. One option is to
put a <B>ClearSpitValve(&#160;) </B>method in the base class <B>Instrument</B>,
but this is confusing because it implies that <B>Percussion</B> and
<B>Electronic</B> instruments also have spit valves. RTTI provides a much more
reasonable solution in this case because you can place the method in the
specific class (<B>Wind </B>in this case), where it&#8217;s appropriate.
However, a more appropriate solution is to put a
<B>prepareInstrument(&#160;)</B> method in the base class, but you might not see
this when you&#8217;re first solving the problem and could mistakenly assume
that you must use RTTI.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, RTTI will sometimes solve
efficiency problems. If your code nicely uses polymorphism, but it turns out
that one of your objects reacts to this general purpose code in a horribly
inefficient way, you can pick out that type using RTTI and write case-specific
code to improve the efficiency.</FONT><A NAME="_Toc408018652"></A><BR></P></DIV>
<A NAME="Heading362"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Write
a method that takes an object and recursively prints all the classes in that
object&#8217;s
hierarchy.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">In
<B>ToyTest.java</B>, comment out <B>Toy</B>&#8217;s default constructor and
explain what
happens.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
a new type of collection that uses a <B>Vector</B>.<B> </B>Capture the type of
the first object you put in it, and then allow the user to insert objects of
only that type from then
on.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Write
a program to determine whether an array of <B>char</B> is a primitive type or a
true
object.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Implement
<B>clearSpitValve(&#160;)</B> as described in this
chapter.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Implement
the <B>rotate(Shape)</B> method described in this chapter, such that it checks
to see if it is rotating a <B>Circle</B> (and, if so, doesn&#8217;t perform the
operation).</FONT></OL>
<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter10.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter12.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/04/2000</P></DIV>

</BODY>

</HTML>
