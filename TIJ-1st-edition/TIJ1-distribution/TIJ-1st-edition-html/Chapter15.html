<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:Tjava14.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/04/2000
Translation Time:23:26:05
Translation Platform:Win32
Number of Output files:27
This File:Chapter15.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>15: Network programming</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/TIJ2/index.html">2nd Edition</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/javaCD2.html">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 1st edition</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;1998 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter14.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter16.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_17"></A><A NAME="_Toc375545491"></A><A NAME="_Toc407441459"></A><A NAME="_Toc408018764"></A><A NAME="Heading510"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
15: Network programming</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>Historically,
<A NAME="Index2601"></A>network programming has been error-prone, difficult, and
complex.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The programmer had to know many
details about the network and sometimes even the hardware. You usually needed to
understand the various &#8220;layers&#8221; of the networking protocol, and
there were a lot of different functions in each different networking library
concerned with connecting, packing, and unpacking blocks of information;
shipping those blocks back and forth; and handshaking. It was a daunting
task.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, the concept of networking
is not so difficult. You want to get some information from that machine over
there and move it to this machine here, or vice versa. It&#8217;s quite similar
to reading and writing files, except that the file exists on a remote machine
and the remote machine can decide exactly what it wants to do about the
information you&#8217;re requesting or sending.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of Java&#8217;s great strengths
is painless networking. As much as possible, the underlying details of
networking have been abstracted away and taken care of within the JVM and local
machine installation of Java. The programming model you use is that of a file;
in fact, you actually wrap the network connection (a &#8220;socket&#8221;) with
stream objects, so you end up using the same method calls as you do with all
other streams. In addition, Java&#8217;s built-in multithreading is
exceptionally handy when dealing with another networking issue: handling
multiple connections at once.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter introduces
Java&#8217;s networking support using easy-to-understand
examples.</FONT><A NAME="_Toc375545492"></A><A NAME="_Toc408018765"></A><BR></P></DIV>
<A NAME="Heading511"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Identifying a machine</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, in order to tell one
machine from another and to make sure that you are connected with the machine
you want, there must be some way of uniquely <A NAME="Index2602"></A>identifying
machines on a network. Early networks were satisfied to provide unique names for
machines within the local network. However, Java works within the Internet,
which requires a way to uniquely identify a machine from all the others <I>in
the world</I>. This is accomplished with the
<A NAME="Index2603"></A><A NAME="Index2604"></A><A NAME="Index2605"></A>IP
(Internet Protocol) address that can exist in two forms:
<A NAME="Index2606"></A><A NAME="Index2607"></A><A NAME="Index2608"></A><A NAME="Index2609"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	The familiar DNS (Domain Name Service) form. My
domain name is <B>bruceeckel.com</B>, so suppose I have a computer called
<B>Opus</B> in my domain. Its domain name would be <B>Opus.bruceeckel.com</B>.
This is exactly the kind of name that you use when you send email to people, and
is often incorporated into a World-Wide-Web
address.</FONT><LI><FONT FACE="Georgia">	Alternatively, you can use the
&#8220;dotted quad&#8221; form, which is four numbers separated by dots, such as
<B>123.255.28.120</B>.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In
both cases, the IP address is represented internally as a 32-bit
number</FONT><A NAME="fnB59" HREF="#fn59">[59]</A><FONT FACE="Georgia">
(so each of the quad numbers cannot exceed 255), and you can get a special Java
object to represent this number from either of the forms above by using the
<B>static</B> <B>InetAddress.getByName(&#160;)</B> method that&#8217;s in
<B>java.net</B>. The result is an object of type <B>InetAddress</B> that you can
use to build a &#8220;socket&#8221; as you will see later.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a simple example of using
<B>InetAddress.getByName(&#160;)</B>, consider what happens if you have a
dial-up Internet service provider (ISP). Each time you dial up, you are assigned
a temporary IP address. But while you&#8217;re connected, your IP address has
the same validity as any other IP address on the Internet. If someone connects
to your machine using your IP address then they can connect to a Web server or
FTP server that you have running on your machine. Of course, they need to know
your IP address, and since it&#8217;s assigned each time you dial up, how can
you find out what it is?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following program uses
<B>InetAddress.getByName(&#160;)</B> to produce your IP address. To use it, you
must know the name of your computer. It has been tested only on Windows 95, but
there you can go to &#8220;Settings,&#8221; &#8220;Control Panel,&#8221;
&#8220;Network,&#8221; and then select the &#8220;Identification&#8221; tab.
&#8220;Computer name&#8221; is the name to put on the command
line.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: WhoAmI.java</font>
<font color=#009900>// Finds out your network address when you're </font>
<font color=#009900>// connected to the Internet.</font>
<font color=#0000ff>package</font> c15;
<font color=#0000ff>import</font> java.net.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WhoAmI {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> Exception {
    <font color=#0000ff>if</font>(args.length != 1) {
      System.err.println(
        <font color=#004488>"Usage: WhoAmI MachineName"</font>);
      System.exit(1);
    }
    InetAddress a = 
      InetAddress.getByName(args[0]);
    System.out.println(a);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In my case, the machine is called
&#8220;Colossus&#8221; (from the movie of the same name, because I keep putting
bigger disks on it). So, once I&#8217;ve connected to my ISP I run the
program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java WhoAmI Colossus</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I get back a message like this (of
course, the address is different each time):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Colossus/199.190.87.75</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If I tell my friend this address,
he can log onto my personal Web server by going to the URL
<I>http://199.190.87.75</I> (only as long as I continue to stay connected during
that session). This can sometimes be a handy way to distribute information to
someone else or to test out a Web site configuration before posting it to a
&#8220;real&#8221;
server.</FONT><A NAME="_Toc375545493"></A><A NAME="_Toc408018766"></A><BR></P></DIV>
<A NAME="Heading512"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Servers and clients</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The whole point of a network is to
allow two machines to connect and talk to each other. Once the two machines have
found each other they can have a nice, two-way conversation. But how do they
find each other? It&#8217;s like getting lost in an amusement park: one machine
has to stay in one place and listen while the other machine says, &#8220;Hey,
where are you?&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The machine that &#8220;stays in
one place&#8221; is called the
<A NAME="Index2610"></A><A NAME="Index2611"></A><I>server</I>, and the one that
seeks is called the
<A NAME="Index2612"></A><A NAME="Index2613"></A><I>client</I>. This distinction
is important only while the client is trying to connect to the server. Once
they&#8217;ve connected, it becomes a two-way communication process and it
doesn&#8217;t matter anymore that one happened to take the role of server and
the other happened to take the role of the client.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So the job of the server is to
listen for a connection, and that&#8217;s performed by the special server object
that you create. The job of the client is to try to make a connection to a
server, and this is performed by the special client object you create. Once the
connection is made, you&#8217;ll see that at both server and client ends, the
connection is just magically turned into an IO stream object, and from then on
you can treat the connection as if you were reading from and writing to a file.
Thus, after the connection is made you will just use the familiar IO commands
from Chapter 10. This is one of the nice features of Java
networking.</FONT><BR></P></DIV>
<A NAME="Heading513"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Testing programs without a network<BR><A NAME="Index2614"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For many reasons, you might not
have a client machine, a server machine, and a network available to test your
programs. You might be performing exercises in a classroom situation, or you
could be writing programs that aren&#8217;t yet stable enough to put onto the
network. The creators of the Internet Protocol were aware of this issue, and
they created a special address called
<A NAME="Index2615"></A><A NAME="Index2616"></A><B>localhost</B> to be the
<A NAME="Index2617"></A><A NAME="Index2618"></A>&#8220;local loopback&#8221; IP
address for testing without a network. The generic way to produce this address
in Java is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>InetAddress addr = InetAddress.getByName(<font color=#0000ff>null</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you hand
<B>getByName(&#160;)</B> a <B>null</B>, it defaults to using the
<B>localhost</B>. The <B>InetAddress</B> is what you use to refer to the
particular machine, and you must produce this before you can go any further. You
can&#8217;t manipulate the contents of an <B>InetAddress </B>(but you can print
them out, as you&#8217;ll see in the next example). The only way you can create
an <B>InetAddress</B> is through one of that class&#8217;s <B>static</B> member
methods <B>getByName(&#160;)</B> (which is what you&#8217;ll usually use),
<B>getAllByName(&#160;)</B>, or <B>getLocalHost(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also produce the local
loopback address by handing it the string <B>localhost</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>InetAddress.getByName(<font color=#004488>"localhost"</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">or by using its dotted quad form to
name the reserved IP number for the loopback:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>InetAddress.getByName(<font color=#004488>"127.0.0.1"</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All three forms produce the same
result.</FONT><A NAME="_Toc375545494"></A><A NAME="_Toc408018767"></A><BR></P></DIV>
<A NAME="Heading514"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Port: a unique place <BR>within the machine</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An IP address isn&#8217;t enough to
identify a unique server, since many servers can exist on one machine. Each IP
machine also contains <I>ports</I>, and when you&#8217;re setting up a client or
a server you must choose a <A NAME="Index2619"></A><A NAME="Index2620"></A>port
where both client and server agree to connect; if you&#8217;re meeting someone,
the IP address is the neighborhood and the port is the bar.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The port is not a physical location
in a machine, but a software abstraction (mainly for bookkeeping purposes). The
client program knows how to connect to the machine via its IP address, but how
does it connect to a desired service (potentially one of many on that machine)?
That&#8217;s where the port numbers come in as second level of addressing. The
idea is that if you ask for a particular port, you&#8217;re requesting the
service that&#8217;s associated with the port number. The time of day is a
simple example of a service. Typically, each service is associated with a unique
port number on a given server machine. It&#8217;s up to the client to know ahead
of time which port number the desired service is running on. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The system services reserve the use
of ports 1 through 1024, so you shouldn&#8217;t use those or any other port that
you know to be in use. The first choice for examples in this book will be port
8080 (in memory of the venerable old 8-bit Intel 8080 chip in my first computer,
a CP/M
machine).</FONT><A NAME="_Toc375545495"></A><A NAME="_Toc408018768"></A><BR></P></DIV>
<A NAME="Heading515"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Sockets</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <I>socket</I> is the software
abstraction used to represent the &#8220;terminals&#8221; of a connection
between two machines. For a given connection, there&#8217;s a socket on each
machine, and you can imagine a hypothetical &#8220;cable&#8221; running between
the two machines with each end of the &#8220;cable&#8221; plugged into a socket.
Of course, the physical hardware and cabling between machines is completely
unknown. The whole point of the abstraction is that we don&#8217;t have to know
more than is necessary.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Java, you create a socket to
make the connection to the other machine, then you get an <B>InputStream</B> and
<B>OutputStream</B> (or, with the appropriate converters, <B>Reader</B> and
<B>Writer</B>)<B> </B>from the socket in order to be able to treat the
connection as an IO stream object. There are two stream-based socket classes: a
<B>ServerSocket</B> that a server uses to &#8220;listen&#8221; for incoming
connections and a <B>Socket</B> that a client uses in order to initiate a
connection. Once a client makes a socket connection, the <B>ServerSocket</B>
returns (via the <B>accept(&#160;)</B>
<A NAME="Index2621"></A><A NAME="Index2622"></A>method) a corresponding server
side <B>Socket</B> through which direct communications will take place. From
then on, you have a true <B>Socket</B> to <B>Socket</B> connection and you treat
both ends the same way because they <I>are</I> the same. At this point, you use
the methods
<A NAME="Index2623"></A><A NAME="Index2624"></A><B>getInputStream(&#160;)</B>
and
<A NAME="Index2625"></A><A NAME="Index2626"></A><B>getOutputStream(&#160;)</B>
to produce the corresponding <B>InputStream</B> and <B>OutputStream</B> objects
from each <B>Socket</B>. These must be wrapped inside buffers and formatting
classes just like any other stream object described in Chapter
10.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of the term
<B>ServerSocket</B> would seem to be another example of a confusing name scheme
in the Java libraries. You might think <B>ServerSocket</B> would be better named
&#8220;ServerConnector&#8221; or something without the word &#8220;Socket&#8221;
in it. You might also think that <B>ServerSocket</B> and <B>Socket</B> should
both be inherited from some common base class. Indeed, the two classes do have
several methods in common but not enough to give them a common base class.
Instead, <B>ServerSocket</B>&#8217;s job is to wait until some other machine
connects to it, then to return an actual <B>Socket</B>. This is why
<B>ServerSocket</B> seems to be a bit misnamed, since its job isn&#8217;t really
to be a socket but instead to make a <B>Socket</B> object when someone else
connects to it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, the <B>ServerSocket</B>
does create a physical &#8220;server&#8221; or listening socket on the host
machine. This socket listens for incoming connections and then returns an
&#8220;established&#8221; socket (with the local and remote endpoints defined)
via the <B>accept(&#160;)</B> method. The confusing part is that both of these
sockets (listening and established) are associated with the same server socket.
The listening socket can accept only new connection requests and not data
packets. So while <B>ServerSocket</B> doesn&#8217;t make much sense
programmatically, it does &#8220;physically.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you create a
<B>ServerSocket</B>, you give it only a port number. You don&#8217;t have to
give it an IP address because it&#8217;s already on the machine it represents.
When you create a <B>Socket</B>, however, you must give both the IP address and
the port number where you&#8217;re trying to connect. (On the other hand, the
<B>Socket</B> that comes back from <B>ServerSocket.accept(&#160;)</B> already
contains all this
information.)</FONT><A NAME="_Toc375545496"></A><A NAME="_Toc408018769"></A><BR></P></DIV>
<A NAME="Heading516"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A simple server and client</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example makes the simplest use
of servers and clients using sockets. All the server does is wait for a
connection, then uses the <B>Socket</B> produced by that connection to create an
<B>InputStream</B> and <B>OutputStream</B>. After that, everything it reads from
the <B>InputStream</B> it echoes to the <B>OutputStream</B> until it receives
the line END, at which time it closes the connection.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The client makes the connection to
the server, then creates an <B>OutputStream</B>. Lines of text are sent through
the <B>OutputStream</B>. The client also creates an <B>InputStream</B> to hear
what the server is saying (which, in this case, is just the words echoed
back).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both the server and client use the
same port number and the client uses the local loopback address to connect to
the server on the same machine so you don&#8217;t have to test it over a
network. (For some configurations, you might need to be <I>connected</I> to a
network for the programs to work, even if you aren&#8217;t communicating over
that network.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here is the
server:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: JabberServer.java</font>
<font color=#009900>// Very simple server that just</font>
<font color=#009900>// echoes whatever the client sends.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.net.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> JabberServer {  
  <font color=#009900>// Choose a port outside of the range 1-1024:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> PORT = 8080;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> IOException {
    ServerSocket s = <font color=#0000ff>new</font> ServerSocket(PORT);
    System.out.println(<font color=#004488>"Started: "</font> + s);
    <font color=#0000ff>try</font> {
      <font color=#009900>// Blocks until a connection occurs:</font>
      Socket socket = s.accept();
      <font color=#0000ff>try</font> {
        System.out.println(
          <font color=#004488>"Connection accepted: "</font>+ socket);
        BufferedReader in = 
          <font color=#0000ff>new</font> BufferedReader(
            <font color=#0000ff>new</font> InputStreamReader(
              socket.getInputStream()));
        <font color=#009900>// Output is automatically flushed</font>
        <font color=#009900>// by PrintWriter:</font>
        PrintWriter out = 
          <font color=#0000ff>new</font> PrintWriter(
            <font color=#0000ff>new</font> BufferedWriter(
              <font color=#0000ff>new</font> OutputStreamWriter(
                socket.getOutputStream())),<font color=#0000ff>true</font>);
        <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {  
          String str = in.readLine();
          <font color=#0000ff>if</font> (str.equals(<font color=#004488>"END"</font>)) <font color=#0000ff>break</font>;
          System.out.println(<font color=#004488>"Echoing: "</font> + str);
          out.println(str);
        }
      <font color=#009900>// Always close the two sockets...</font>
      } <font color=#0000ff>finally</font> {
        System.out.println(<font color=#004488>"closing..."</font>);
        socket.close();
      }
    } <font color=#0000ff>finally</font> {
      s.close();
    }
  } 
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the
<B>ServerSocket</B> just needs a port number, not an IP address (since
it&#8217;s running on <I>this</I> machine!). When you call
<B>accept(&#160;)</B>, the method <I>blocks</I> until some client tries to
connect to it. That is, it&#8217;s there waiting for a connection but other
processes can run (see Chapter 14). When a connection is made,
<B>accept(&#160;)</B> returns with a <B>Socket</B> object representing that
connection. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The responsibility for cleaning up
the sockets is crafted carefully here. If the <B>ServerSocket</B> constructor
fails, the program just quits (notice we must assume that the constructor for
<B>ServerSocket</B> doesn&#8217;t leave any open network sockets lying around if
it fails). For this case, <B>main(&#160;)</B> <B>throws</B> <B>IOException</B>
so a <B>try</B> block is not necessary. If the <B>ServerSocket</B> constructor
is successful then all other method calls must be guarded in a
<B>try-finally</B> block to ensure that, no matter how the block is left, the
<B>ServerSocket</B> is properly closed.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The same logic is used for the
<B>Socket</B> returned by <B>accept(&#160;)</B>. If <B>accept(&#160;)</B> fails,
then we must assume that the <B>Socket</B> doesn&#8217;t exist or hold any
resources, so it doesn&#8217;t need to be cleaned up. If it&#8217;s successful,
however, the following statements must be in a <B>try-finally</B> block so that
if they fail the <B>Socket</B> will still be cleaned up. Care is required here
because sockets use important non-memory resources, so you must be diligent in
order to clean them up (since there is no destructor in Java to do it for
you).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both the <B>ServerSocket</B> and
the <B>Socket</B> produced by <B>accept(&#160;)</B> are printed to
<B>System.out</B>. This means that their <B>toString(&#160;)</B> methods are
automatically called. These produce:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>ServerSocket[addr=0.0.0.0,PORT=0,localport=8080]
Socket[addr=127.0.0.1,PORT=1077,localport=8080]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Shortly, you&#8217;ll see how these
fit together with what the client is doing.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next part of the program looks
just like opening files for reading and writing except that the
<B>InputStream</B> and <B>OutputStream</B> are created from the <B>Socket</B>
object. Both the <B>InputStream</B> and <B>OutputStream </B>objects are
converted to Java 1.1<A NAME="Index2627"></A>
<A NAME="Index2628"></A><A NAME="Index2629"></A><B>Reader </B>and
<A NAME="Index2630"></A><A NAME="Index2631"></A><B>Writer</B> objects using the
&#8220;converter&#8221; classes
<A NAME="Index2632"></A><A NAME="Index2633"></A><B>InputStreamReader</B> and
<A NAME="Index2634"></A><A NAME="Index2635"></A><B>OutputStreamWriter</B>,
respectively. You could also have used the Java 1.0<A NAME="Index2636"></A>
<A NAME="Index2637"></A><A NAME="Index2638"></A><B>InputStream</B> and
<A NAME="Index2639"></A><A NAME="Index2640"></A><B>OutputStream</B> classes
directly, but with output there&#8217;s a distinct advantage to using the
<B>Writer</B> approach. This appears with
<A NAME="Index2641"></A><A NAME="Index2642"></A><B>PrintWriter</B>, which has an
overloaded constructor that takes a second argument, a <B>boolean </B>flag that
indicates whether to automatically flush the output at the end of each
<B>println(&#160;)</B> (but <I>not </I><B>print(&#160;)</B>) statement. Every
time you write to <B>out</B>, its buffer must be flushed so the information goes
out over the network. Flushing is important for this particular example because
the client and server each wait for a line from the other party before
proceeding. If flushing doesn&#8217;t occur, the information will not be put
onto the network until the buffer is full, which causes lots of problems in this
example.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When writing network programs you
need to be careful about using automatic flushing. Every time you flush the
buffer a packet must be created and sent. In this case, that&#8217;s exactly
what we want, since if the packet containing the line isn&#8217;t sent then the
handshaking back and forth between server and client will stop. Put another way,
the end of a line is the end of a message. But in many cases messages
aren&#8217;t delimited by lines so it&#8217;s much more efficient to not use
auto flushing and instead let the built-in buffering decide when to build and
send a packet. This way, larger packets can be sent and the process will be
faster.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that, like virtually all
streams you open, these are buffered. There&#8217;s an exercise at the end of
the chapter to show you what happens if you don&#8217;t buffer the streams
(things get slow).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The infinite <B>while</B> loop
reads lines from the<B> BufferedReader in </B>and writes information to
<B>System.out</B> and to the <B>PrintWriter</B> <B>out</B>. Note that these
could be any streams, they just happen to be connected to the network.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the client sends the line
consisting of &#8220;END&#8221; the program breaks out of the loop and closes
the <B>Socket</B>. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the
client:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: JabberClient.java</font>
<font color=#009900>// Very simple client that just sends</font>
<font color=#009900>// lines to the server and reads lines</font>
<font color=#009900>// that the server sends.</font>
<font color=#0000ff>import</font> java.net.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> JabberClient {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> IOException {
    <font color=#009900>// Passing null to getByName() produces the</font>
    <font color=#009900>// special "Local Loopback" IP address, for</font>
    <font color=#009900>// testing on one machine w/o a network:</font>
    InetAddress addr = 
      InetAddress.getByName(<font color=#0000ff>null</font>);
    <font color=#009900>// Alternatively, you can use </font>
    <font color=#009900>// the address or name:</font>
    <font color=#009900>// InetAddress addr = </font>
    <font color=#009900>//    InetAddress.getByName("127.0.0.1");</font>
    <font color=#009900>// InetAddress addr = </font>
    <font color=#009900>//    InetAddress.getByName("localhost");</font>
    System.out.println(<font color=#004488>"addr = "</font> + addr);
    Socket socket = 
      <font color=#0000ff>new</font> Socket(addr, JabberServer.PORT);
    <font color=#009900>// Guard everything in a try-finally to make</font>
    <font color=#009900>// sure that the socket is closed:</font>
    <font color=#0000ff>try</font> {
      System.out.println(<font color=#004488>"socket = "</font> + socket);
      BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(
            socket.getInputStream()));
      <font color=#009900>// Output is automatically flushed</font>
      <font color=#009900>// by PrintWriter:</font>
      PrintWriter out =
        <font color=#0000ff>new</font> PrintWriter(
          <font color=#0000ff>new</font> BufferedWriter(
            <font color=#0000ff>new</font> OutputStreamWriter(
              socket.getOutputStream())),<font color=#0000ff>true</font>);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i ++) {
        out.println(<font color=#004488>"howdy "</font> + i);
        String str = in.readLine();
        System.out.println(str);
      }
      out.println(<font color=#004488>"END"</font>);
    } <font color=#0000ff>finally</font> {
      System.out.println(<font color=#004488>"closing..."</font>);
      socket.close();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B> you can see
all three ways to produce the <B>InetAddress</B> of the local loopback IP
address: using <B>null</B>, <B>localhost</B>, or the explicit reserved address
<B>127.0.0.1</B>. Of course, if you want to connect to a machine across a
network you substitute that machine&#8217;s IP address. When the <B>InetAddress
addr</B> is printed (via the automatic call to its <B>toString(&#160;)</B>
method) the result is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>localhost/127.0.0.1</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By handing <B>getByName(&#160;)</B>
a <B>null</B>, it defaulted to finding the <B>localhost</B>, and that produced
the special address <B>127.0.0.1</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the
<A NAME="Index2643"></A><A NAME="Index2644"></A><B>Socket</B> called
<B>socket</B> is created with both the <B>InetAddress</B> and the port number.
To understand what it means when you print out one of these <B>Socket
</B>objects, remember that an Internet connection is determined uniquely by
these four pieces of data: <B>clientHost</B>, <B>clientPortNumber</B>,
<B>serverHost</B>, and <B>serverPortNumber</B>. When the server comes up, it
takes up its assigned port (8080) on the localhost (127.0.0.1). When the client
comes up, it is allocated to the next available port on its machine, 1077 in
this case, which also happens to be on the same machine (127.0.0.1) as the
server. Now, in order for data to move between the client and server, each side
has to know where to send it. Therefore, during the process of connecting to the
&#8220;known&#8221; server, the client sends a &#8220;return address&#8221; so
the server knows where to send its data. This is what you see in the example
output for the server side:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Socket[addr=127.0.0.1,port=1077,localport=8080]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This means that the server just
accepted a connection from 127.0.0.1 on port 1077 while listening on its local
port (8080). On the client side:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Socket[addr=localhost/127.0.0.1,PORT=8080,localport=1077]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">which means that the client made a
connection to 127.0.0.1 on port 8080 using the local port 1077.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that every time
you start up the client anew, the local port number is incremented. It starts at
1025 (one past the reserved block of ports) and keeps going up until you reboot
the machine, at which point it starts at 1025 again. (On UNIX machines, once the
upper limit of the socket range is reached, the numbers will wrap around to the
lowest available number again.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the <B>Socket</B> object has
been created, the process of turning it into a <B>BufferedReader</B> and
<B>PrintWriter</B> is the same as in the server (again, in both cases you start
with a <B>Socket</B>). Here, the client initiates the conversation by sending
the string &#8220;howdy&#8221; followed by a number. Note that the buffer must
again be flushed (which happens automatically via the second argument to the
<B>PrintWriter </B>constructor). If the buffer isn&#8217;t flushed, the whole
conversation will hang because the initial &#8220;howdy&#8221; will never get
sent (the buffer isn&#8217;t full enough to cause the send to happen
automatically). Each line that is sent back from the server is written to
<B>System.out</B> to verify that everything is working correctly. To terminate
the conversation, the agreed-upon &#8220;END&#8221; is sent. If the client
simply hangs up, then the server throws an exception.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the same care is
taken here to ensure that the network resources represented by the <B>Socket</B>
are properly cleaned up, using a <B>try-finally</B> block.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sockets produce a
<A NAME="Index2645"></A>&#8220;dedicated&#8221; connection that persists until
it is explicitly disconnected. (The dedicated connection can still be
disconnected un-explicitly if one side, or an intermediary link, of the
connection crashes.) This means the two parties are locked in communication and
the connection is constantly open. This seems like a logical approach to
networking, but it puts an extra load on the network. Later in the chapter
you&#8217;ll see a different approach to networking, in which the connections
are only
temporary.</FONT><A NAME="_Toc375545497"></A><A NAME="_Toc408018770"></A><BR></P></DIV>
<A NAME="Heading517"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Serving multiple clients<BR><A NAME="Index2646"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>JabberServer</B> works, but
it can handle only one client at a time. In a typical server, you&#8217;ll want
to be able to deal with many clients at once. The answer is
<A NAME="Index2647"></A><A NAME="Index2648"></A>multithreading, and in languages
that don&#8217;t directly support multithreading this means all sorts of
complications. In Chapter 14 you saw that multithreading in Java is about as
simple as possible, considering that multithreading is a rather complex topic.
Because threading in Java is reasonably straightforward, making a server that
handles multiple clients is relatively easy.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The basic scheme is to make a
single <B>ServerSocket</B> in the server and call <B>accept(&#160;)</B> to wait
for a new connection. When <B>accept(&#160;)</B> returns, you take the resulting
<B>Socket</B> and use it to create a new thread whose job is to serve that
particular client. Then you call <B>accept(&#160;)</B> again to wait for a new
client.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the following server code, you
can see that it looks similar to the <B>JabberServer.java</B> example except
that all of the operations to serve a particular client have been moved inside a
separate thread class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MultiJabberServer.java</font>
<font color=#009900>// A server that uses multithreading to handle </font>
<font color=#009900>// any number of clients.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.net.*;

<font color=#0000ff>class</font> ServeOneJabber <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> Socket socket;
  <font color=#0000ff>private</font> BufferedReader in;
  <font color=#0000ff>private</font> PrintWriter out;
  <font color=#0000ff>public</font> ServeOneJabber(Socket s) 
      <font color=#0000ff>throws</font> IOException {
    socket = s;
    in = 
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(
          socket.getInputStream()));
    <font color=#009900>// Enable auto-flush:</font>
    out = 
      <font color=#0000ff>new</font> PrintWriter(
        <font color=#0000ff>new</font> BufferedWriter(
          <font color=#0000ff>new</font> OutputStreamWriter(
            socket.getOutputStream())), <font color=#0000ff>true</font>);
    <font color=#009900>// If any of the above calls throw an </font>
    <font color=#009900>// exception, the caller is responsible for</font>
    <font color=#009900>// closing the socket. Otherwise the thread</font>
    <font color=#009900>// will close it.</font>
    start(); <font color=#009900>// Calls run()</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {  
        String str = in.readLine();
        <font color=#0000ff>if</font> (str.equals(<font color=#004488>"END"</font>)) <font color=#0000ff>break</font>;
        System.out.println(<font color=#004488>"Echoing: "</font> + str);
        out.println(str);
      }
      System.out.println(<font color=#004488>"closing..."</font>);
    } <font color=#0000ff>catch</font> (IOException e) {
    } <font color=#0000ff>finally</font> {
      <font color=#0000ff>try</font> {
        socket.close();
      } <font color=#0000ff>catch</font>(IOException e) {}
    }
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MultiJabberServer {  
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> PORT = 8080;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
      <font color=#0000ff>throws</font> IOException {
    ServerSocket s = <font color=#0000ff>new</font> ServerSocket(PORT);
    System.out.println(<font color=#004488>"Server Started"</font>);
    <font color=#0000ff>try</font> {
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
        <font color=#009900>// Blocks until a connection occurs:</font>
        Socket socket = s.accept();
        <font color=#0000ff>try</font> {
          <font color=#0000ff>new</font> ServeOneJabber(socket);
        } <font color=#0000ff>catch</font>(IOException e) {
          <font color=#009900>// If it fails, close the socket,</font>
          <font color=#009900>// otherwise the thread will close it:</font>
          socket.close();
        }
      }
    } <font color=#0000ff>finally</font> {
      s.close();
    }
  } 
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>ServeOneJabber </B>thread
takes the <B>Socket</B> object that&#8217;s produced by <B>accept(&#160;)</B> in
<B>main(&#160;)</B> every time a new client makes a connection. Then, as before,
it creates a <B>BufferedReader</B> and auto-flushed <B>PrintWriter</B> object
using the <B>Socket</B>. Finally, it calls the special <B>Thread</B> method
<B>start(&#160;)</B>, which performs thread initialization and then calls
<B>run(&#160;)</B>. This performs the same kind of action as in the previous
example: reading something from the socket and then echoing it back until it
reads the special &#8220;END&#8221; signal.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The responsibility for cleaning up
the socket must again be carefully designed. In this case, the socket is created
outside of the <B>ServeOneJabber</B> so the responsibility can be shared. If the
<B>ServeOneJabber</B> constructor fails, it will just throw the exception to the
caller, who will then clean up the thread. But if the constructor succeeds, then
the <B>ServeOneJabber</B> object takes over responsibility for cleaning up the
thread, in its <B>run(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice the simplicity of the
<B>MultiJabberServer</B>. As before, a <B>ServerSocket</B> is created and
<B>accept(&#160;)</B> is called to allow a new connection. But this time, the
return value of <B>accept(&#160;)</B> (a <B>Socket</B>) is passed to the
constructor for <B>ServeOneJabber,</B> which creates a new thread to handle that
connection. When the connection is terminated, the thread simply goes
away.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the creation of the
<B>ServerSocket</B> fails, the exception is again thrown through
<B>main(&#160;)</B>. But if it succeeds, the outer <B>try-finally</B> guarantees
its cleanup. The inner <B>try-catch</B> guards only against the failure of the
<B>ServeOneJabber</B> constructor; if the constructor succeeds, then the
<B>ServeOneJabber</B> thread will close the associated socket.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To test that the server really does
handle multiple clients, the following program creates many clients (using
threads) that connect to the same server. Each thread has a limited lifetime,
and when it goes away, that leaves space for the creation of a new thread. The
maximum number of threads allowed is determined by the <B>final int
maxthreads</B>. You&#8217;ll notice that this value is rather critical, since if
you make it too high the threads seem to run out of resources and the program
mysteriously fails.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MultiJabberClient.java</font>
<font color=#009900>// Client that tests the MultiJabberServer</font>
<font color=#009900>// by starting up multiple clients.</font>
<font color=#0000ff>import</font> java.net.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> JabberClientThread <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> Socket socket;
  <font color=#0000ff>private</font> BufferedReader in;
  <font color=#0000ff>private</font> PrintWriter out;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> counter = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> id = counter++;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> threadcount = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> threadCount() { 
    <font color=#0000ff>return</font> threadcount; 
  }
  <font color=#0000ff>public</font> JabberClientThread(InetAddress addr) {
    System.out.println(<font color=#004488>"Making client "</font> + id);
    threadcount++;
    <font color=#0000ff>try</font> {
      socket = 
        <font color=#0000ff>new</font> Socket(addr, MultiJabberServer.PORT);
    } <font color=#0000ff>catch</font>(IOException e) {
      <font color=#009900>// If the creation of the socket fails, </font>
      <font color=#009900>// nothing needs to be cleaned up.</font>
    }
    <font color=#0000ff>try</font> {    
      in = 
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(
            socket.getInputStream()));
      <font color=#009900>// Enable auto-flush:</font>
      out = 
        <font color=#0000ff>new</font> PrintWriter(
          <font color=#0000ff>new</font> BufferedWriter(
            <font color=#0000ff>new</font> OutputStreamWriter(
              socket.getOutputStream())), <font color=#0000ff>true</font>);
      start();
    } <font color=#0000ff>catch</font>(IOException e) {
      <font color=#009900>// The socket should be closed on any </font>
      <font color=#009900>// failures other than the socket </font>
      <font color=#009900>// constructor:</font>
      <font color=#0000ff>try</font> {
        socket.close();
      } <font color=#0000ff>catch</font>(IOException e2) {}
    }
    <font color=#009900>// Otherwise the socket will be closed by</font>
    <font color=#009900>// the run() method of the thread.</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 25; i++) {
        out.println(<font color=#004488>"Client "</font> + id + <font color=#004488>": "</font> + i);
        String str = in.readLine();
        System.out.println(str);
      }
      out.println(<font color=#004488>"END"</font>);
    } <font color=#0000ff>catch</font>(IOException e) {
    } <font color=#0000ff>finally</font> {
      <font color=#009900>// Always close it:</font>
      <font color=#0000ff>try</font> {
        socket.close();
      } <font color=#0000ff>catch</font>(IOException e) {}
      threadcount--; <font color=#009900>// Ending this thread</font>
    }
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MultiJabberClient {
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> MAX_THREADS = 40;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> IOException, InterruptedException {
    InetAddress addr = 
      InetAddress.getByName(<font color=#0000ff>null</font>);
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>if</font>(JabberClientThread.threadCount() 
         &lt; MAX_THREADS)
        <font color=#0000ff>new</font> JabberClientThread(addr);
      Thread.currentThread().sleep(100);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>JabberClientThread</B>
constructor takes an <B>InetAddress</B> and uses it to open a <B>Socket</B>.
You&#8217;re probably starting to see the pattern: the <B>Socket</B> is always
used to create some kind of <B>Reader </B>and/or <B>Writer </B>(or
<B>InputStream</B> and/or <B>OutputStream</B>) object, which is the only way
that the <B>Socket</B> can be used. (You can, of course, write a class or two to
automate this process instead of doing all the typing if it becomes painful.)
Again, <B>start(&#160;)</B> performs thread initialization and calls
<B>run(&#160;)</B>. Here, messages are sent to the server and information from
the server is echoed to the screen. However, the thread has a limited lifetime
and eventually completes. Note that the socket is cleaned up if the constructor
fails after the socket is created but before the constructor completes.
Otherwise the responsibility for calling <B>close(&#160;)</B> for the socket is
relegated to the <B>run(&#160;)</B> method.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>threadcount</B> keeps track
of how many <B>JabberClientThread</B> objects currently exist. It is incremented
as part of the constructor and decremented as <B>run(&#160;)</B> exits (which
means the thread is terminating). In <B>MultiJabberClient.main(&#160;),</B> you
can see that the number of threads is tested, and if there are too many, no more
are created. Then the method sleeps. This way, some threads will eventually
terminate and more can be created. You can experiment with <B>MAX_THREADS</B> to
see where your particular system begins to have trouble with too many
connections.</FONT><A NAME="_Toc375545498"></A><A NAME="_Toc408018771"></A><BR></P></DIV>
<A NAME="Heading518"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Datagrams<BR><A NAME="Index2649"></A><A NAME="Index2650"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The examples you&#8217;ve seen so
far use the
<A NAME="Index2651"></A><A NAME="Index2652"></A><A NAME="Index2653"></A><I>Transmission
Control Protocol</I> (TCP, also known as
<A NAME="Index2654"></A><A NAME="Index2655"></A><A NAME="Index2656"></A><I>stream-based
sockets</I>), which is designed for ultimate reliability and guarantees that the
data will get there. It allows retransmission of lost data, it provides multiple
paths through different routers in case one goes down, and bytes are delivered
in the order they are sent. All this control and reliability comes at a cost:
TCP has a high overhead.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a second protocol,
called
<A NAME="Index2657"></A><A NAME="Index2658"></A><A NAME="Index2659"></A><A NAME="Index2660"></A><I>User
Datagram Protocol</I> (UDP), which doesn&#8217;t guarantee that the packets will
be delivered and doesn&#8217;t guarantee that they will arrive in the order they
were sent. It&#8217;s called an
&#8220;<A NAME="Index2661"></A><A NAME="Index2662"></A>unreliable
protocol&#8221; (TCP is a
<A NAME="Index2663"></A><A NAME="Index2664"></A>&#8220;reliable
protocol&#8221;), which sounds bad, but because it&#8217;s much faster it can be
useful. There are some applications, such as an audio signal, in which it
isn&#8217;t so critical if a few packets are dropped here or there but speed is
vital. Or consider a time-of-day server, where it really doesn&#8217;t matter if
one of the messages is lost. Also, some applications might be able to fire off a
UDP message to a server and can then assume, if there is no response in a
reasonable period of time, that the message was lost.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The support for datagrams in Java
has the same feel as its support for TCP sockets, but there are significant
differences. With datagrams, you put a
<A NAME="Index2665"></A><A NAME="Index2666"></A><B>DatagramSocket</B> on both
the client and server, but there is no analogy to the <B>ServerSocket</B> that
waits around for a connection. That&#8217;s because there is no
&#8220;connection,&#8221; but instead a datagram just shows up. Another
fundamental difference is that with TCP sockets, once you&#8217;ve made the
connection you don&#8217;t need to worry about who&#8217;s talking to whom
anymore; you just send the data back and forth through conventional streams.
However, with datagrams, the datagram packet must know where it came from and
where it&#8217;s supposed to go. That means you must know these things for each
datagram packet that you load up and ship off.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>DatagramSocket</B> sends and
receives the packets, and the
<A NAME="Index2667"></A><A NAME="Index2668"></A><B>DatagramPacket</B> contains
the information. When you&#8217;re receiving a datagram, you need only provide a
buffer in which the data will be placed; the information about the Internet
address and port number where the information came from will be automatically
initialized when the packet arrives through the <B>DatagramSocket</B>. So the
constructor for a <B>DatagramPacket </B>to receive datagrams
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>DatagramPacket(buf, buf.length)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">in which <B>buf </B>is an array of
<B>byte</B>.<B> </B>Since <B>buf</B> is an array, you might wonder why the
constructor couldn&#8217;t figure out the length of the array on its own. I
wondered this, and can only guess that it&#8217;s a throwback to C-style
programming, in which of course arrays can&#8217;t tell you how big they
are.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can reuse a receiving datagram;
you don&#8217;t have to make a new one each time. Every time you reuse it, the
data in the buffer is overwritten.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The maximum size of the buffer is
restricted only by the allowable datagram packet size, which limits it to
slightly less than 64Kbytes. However, in many applications you&#8217;ll want it
to be much smaller, certainly when you&#8217;re sending data. Your chosen packet
size depends on what you need for your particular application.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you send a datagram, the
<B>DatagramPacket</B> must contain not only the data, but also the Internet
address and port where it will be sent. So the constructor for an outgoing
<B>DatagramPacket</B> is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>DatagramPacket(buf, length, inetAddress, port)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This time, <B>buf</B> (which is a
<B>byte </B>array) already contains the data that you want to send out. The
<B>length</B> might be the length of <B>buf</B>, but it can also be shorter,
indicating that you want to send only that many bytes. The other two arguments
are the Internet address where the packet is going and the destination port
within that machine.</FONT><A NAME="fnB60" HREF="#fn60">[60]</A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might think that the two
constructors create two different objects: one for receiving datagrams and one
for sending them. Good OO design would suggest that these should be two
different classes, rather than one class with different behavior depending on
how you construct the object. This is probably true, but fortunately the use of
<B>DatagramPacket</B>s is simple enough that you&#8217;re not tripped up by the
problem, as you can see in the following example. This example is similar to the
<B>MultiJabberServer</B> and <B>MultiJabberClient</B> example for TCP sockets.
Multiple clients will send datagrams to a server, which will echo them back to
the same client that sent the message.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To simplify the creation of a
<B>DatagramPacket</B> from a <B>String</B> and vice-versa, the example begins
with a utility class, <B>Dgram</B>, to do the work for you:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Dgram.java</font>
<font color=#009900>// A utility class to convert back and forth</font>
<font color=#009900>// Between Strings and DataGramPackets.</font>
<font color=#0000ff>import</font> java.net.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Dgram {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> DatagramPacket toDatagram(
    String s, InetAddress destIA, <font color=#0000ff>int</font> destPort) {
    <font color=#009900>// Deprecated in Java 1.1, but it works:</font>
    <font color=#0000ff>byte</font>[] buf = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[s.length() + 1];
    s.getBytes(0, s.length(), buf, 0);
    <font color=#009900>// The correct Java 1.1 approach, but it's</font>
    <font color=#009900>// Broken (it truncates the String):</font>
    <font color=#009900>// byte[] buf = s.getBytes();</font>
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> DatagramPacket(buf, buf.length, 
      destIA, destPort);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String toString(DatagramPacket p){
    <font color=#009900>// The Java 1.0 approach:</font>
    <font color=#009900>// return new String(p.getData(), </font>
    <font color=#009900>//  0, 0, p.getLength());</font>
    <font color=#009900>// The Java 1.1 approach:</font>
    <font color=#0000ff>return</font> 
      <font color=#0000ff>new</font> String(p.getData(), 0, p.getLength());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first method of <B>Dgram</B>
takes a <B>String</B>, an <B>InetAddress,</B> and a port number and builds a
<B>DatagramPacket</B> by copying the contents of the <B>String</B> into a
<B>byte</B> buffer and passing the buffer into the <B>DatagramPacket</B>
constructor. Notice the &#8220;+1&#8221; in the buffer allocation &#8211; this
was necessary to prevent truncation. The <B>getBytes(&#160;)</B> method of
<B>String</B> is a special operation that copies the <B>char</B>s of a
<B>String</B> into a <B>byte</B> buffer. This method is now deprecated; Java
1.1<A NAME="Index2669"></A> has a &#8220;better&#8221; way to do this but
it&#8217;s commented out here because it truncates the <B>String</B>. So
you&#8217;ll get a deprecation message when you compile it under Java 1.1, but
the behavior will be correct. (This bug might be fixed by the time you read
this.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Dgram.toString(&#160;)</B>
method shows both the Java 1.0<A NAME="Index2670"></A> approach and the Java 1.1
approach (which is different because there&#8217;s a new kind of <B>String</B>
constructor). </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here is the server for the datagram
demonstration:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ChatterServer.java</font>
<font color=#009900>// A server that echoes datagrams</font>
<font color=#0000ff>import</font> java.net.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ChatterServer {
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> INPORT = 1711;
  <font color=#0000ff>private</font> <font color=#0000ff>byte</font>[] buf = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[1000];
  <font color=#0000ff>private</font> DatagramPacket dp = 
    <font color=#0000ff>new</font> DatagramPacket(buf, buf.length);
  <font color=#009900>// Can listen &amp; send on the same socket:</font>
  <font color=#0000ff>private</font> DatagramSocket socket;

  <font color=#0000ff>public</font> ChatterServer() {
    <font color=#0000ff>try</font> {
      socket = <font color=#0000ff>new</font> DatagramSocket(INPORT);
      System.out.println(<font color=#004488>"Server started"</font>);
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
        <font color=#009900>// Block until a datagram appears:</font>
        socket.receive(dp);
        String rcvd = Dgram.toString(dp) +
          <font color=#004488>", from address: "</font> + dp.getAddress() +
          <font color=#004488>", port: "</font> + dp.getPort();
        System.out.println(rcvd);
        String echoString = 
          <font color=#004488>"Echoed: "</font> + rcvd;
        <font color=#009900>// Extract the address and port from the</font>
        <font color=#009900>// received datagram to find out where to</font>
        <font color=#009900>// send it back:</font>
        DatagramPacket echo = 
          Dgram.toDatagram(echoString,
            dp.getAddress(), dp.getPort());
        socket.send(echo);
      }
    } <font color=#0000ff>catch</font>(SocketException e) {
      System.err.println(<font color=#004488>"Can't open socket"</font>);
      System.exit(1);
    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(<font color=#004488>"Communication error"</font>);
      e.printStackTrace();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>new</font> ChatterServer();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>ChatterServer</B> contains a
single <B>DatagramSocket</B> for receiving messages, instead of creating one
each time you&#8217;re ready to receive a new message. The single
<B>DatagramSocket</B> can be used repeatedly. This <B>DatagramSocket</B> has a
port number because this is the server and the client must have an exact address
where it wants to send the datagram. It is given a port number but not an
Internet address because it resides on &#8220;this&#8221; machine so it knows
what its Internet address is (in this case, the default <B>localhost</B>). In
the infinite <B>while</B> loop, the <B>socket</B> is told to
<A NAME="Index2671"></A><A NAME="Index2672"></A><B>receive(&#160;)</B>,
whereupon it blocks until a datagram shows up, and then sticks it into our
designated receiver, the <B>DatagramPacket dp</B>. The packet is converted to a
<B>String</B> along with information about the Internet address and socket where
the packet came from. This information is displayed, and then an extra string is
added to indicate that it is being echoed back from the server.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now there&#8217;s a bit of a
quandary. As you will see, there are potentially many different Internet
addresses and port numbers that the messages might come from &#8211; that is,
the clients can reside on any machine. (In this demonstration they all reside on
the <B>localhost</B>, but the port number for each client is different.) To send
a message back to the client that originated it, you need to know that
client&#8217;s Internet address and port number. Fortunately, this information
is conveniently packaged inside the
<A NAME="Index2673"></A><A NAME="Index2674"></A><B>DatagramPacket</B> that sent
the message, so all you have to do is pull it out using
<A NAME="Index2675"></A><A NAME="Index2676"></A><B>getAddress(&#160;)</B> and
<A NAME="Index2677"></A><A NAME="Index2678"></A><B>getPort(&#160;)</B>, which
are used to build the <B>DatagramPacket</B> <B>echo</B> that is sent back
through the same socket that&#8217;s doing the receiving. In addition, when the
socket sends the datagram, it automatically adds the Internet address and port
information of <I>this</I> machine, so that when the client receives the
message, it can use <B>getAddress(&#160;)</B> and <B>getPort(&#160;)</B> to find
out where the datagram came from. In fact, the only time that
<B>getAddress(&#160;)</B> and <B>getPort(&#160;)</B> don&#8217;t tell you where
the datagram came from is if you create a datagram to send and you call
<B>getAddress(&#160;)</B> and <B>getPort(&#160;)</B> <I>before</I> you send the
datagram (in which case it tells the address and port of this machine, the one
the datagram is being sent from). This is an essential part of datagrams: you
don&#8217;t need to keep track of where a message came from because it&#8217;s
always stored inside the datagram. In fact, the most reliable way to program is
if you don&#8217;t try to keep track, but instead always extract the address and
port from the datagram in question (as is done here).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To test this server, here&#8217;s a
program that makes a number of clients, all of which fire datagram packets to
the server and wait for the server to echo them back.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ChatterClient.java</font>
<font color=#009900>// Tests the ChatterServer by starting multiple </font>
<font color=#009900>// clients, each of which sends datagrams.</font>
<font color=#0000ff>import</font> java.lang.Thread;
<font color=#0000ff>import</font> java.net.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ChatterClient <font color=#0000ff>extends</font> Thread {
  <font color=#009900>// Can listen &amp; send on the same socket:</font>
  <font color=#0000ff>private</font> DatagramSocket s;
  <font color=#0000ff>private</font> InetAddress hostAddress;
  <font color=#0000ff>private</font> <font color=#0000ff>byte</font>[] buf = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[1000];
  <font color=#0000ff>private</font> DatagramPacket dp = 
    <font color=#0000ff>new</font> DatagramPacket(buf, buf.length);
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> id;

  <font color=#0000ff>public</font> ChatterClient(<font color=#0000ff>int</font> identifier) {
    id = identifier;
    <font color=#0000ff>try</font> {
      <font color=#009900>// Auto-assign port number:</font>
      s = <font color=#0000ff>new</font> DatagramSocket();
      hostAddress = 
        InetAddress.getByName(<font color=#004488>"localhost"</font>);
    } <font color=#0000ff>catch</font>(UnknownHostException e) {
      System.err.println(<font color=#004488>"Cannot find host"</font>);
      System.exit(1);
    } <font color=#0000ff>catch</font>(SocketException e) {
      System.err.println(<font color=#004488>"Can't open socket"</font>);
      e.printStackTrace();
      System.exit(1);
    } 
    System.out.println(<font color=#004488>"ChatterClient starting"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 25; i++) {
        String outMessage = <font color=#004488>"Client #"</font> +
          id + <font color=#004488>", message #"</font> + i;
        <font color=#009900>// Make and send a datagram:</font>
        s.send(Dgram.toDatagram(outMessage,
          hostAddress, 
          ChatterServer.INPORT));
        <font color=#009900>// Block until it echoes back:</font>
        s.receive(dp);
        <font color=#009900>// Print out the echoed contents:</font>
        String rcvd = <font color=#004488>"Client #"</font> + id +
          <font color=#004488>", rcvd from "</font> + 
          dp.getAddress() + <font color=#004488>", "</font> + 
          dp.getPort() + <font color=#004488>": "</font> +
          Dgram.toString(dp);
        System.out.println(rcvd);
      }
    } <font color=#0000ff>catch</font>(IOException e) {
      e.printStackTrace();
      System.exit(1);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      <font color=#0000ff>new</font> ChatterClient(i).start();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ChatterClient</B> is created as
a <B>Thread</B> so that multiple clients can be made to bother the server. Here
you can see that the receiving <B>DatagramPacket</B> looks just like the one
used for <B>ChatterServer</B>. In the constructor, the <B>DatagramSocket</B> is
created with no arguments since it doesn&#8217;t need to advertise itself as
being at a particular port number. The Internet address used for this socket
will be &#8220;this machine&#8221; (for the example, <B>localhost</B>) and the
port number will be automatically assigned, as you will see from the output.
This <B>DatagramSocket</B>, like the one for the server, will be used both for
sending and receiving.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>hostAddress</B> is the
Internet address of the host machine you want to talk to. The one part of the
program in which you must know an exact Internet address and port number is the
part in which you make the outgoing <B>DatagramPacket</B>. As is always the
case, the host must be at a known address and port number so that clients can
originate conversations with the host.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each thread is given a unique
identification number (although the port number automatically assigned to the
thread would also provide a unique identifier). In <B>run(&#160;)</B>, a message
<B>String</B> is created that contains the thread&#8217;s identification number
and the message number this thread is currently sending. This <B>String</B> is
used to create a datagram that is sent to the host at its address; the port
number is taken directly from a constant in <B>ChatterServer</B>. Once the
message is sent, <B>receive(&#160;)</B> blocks until the server replies with an
echoing message. All of the information that&#8217;s shipped around with the
message allows you to see that what comes back to this particular thread is
derived from the message that originated from it. In this example, even though
UDP is an &#8220;unreliable&#8221; protocol, you&#8217;ll see that all of the
datagrams get where they&#8217;re supposed to. (This will be true for localhost
and LAN situations, but you might begin to see some failures for non-local
connections.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program,
you&#8217;ll see that each of the threads finishes, which means that each of the
datagram packets sent to the server is turned around and echoed to the correct
recipient; otherwise one or more threads would hang, blocking until their input
shows up.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might think that the only right
way to, for example, transfer a file from one machine to another is through TCP
sockets, since they&#8217;re &#8220;reliable.&#8221; However, because of the
speed of datagrams they can actually be a better solution. You simply break the
file up into packets and number each packet. The receiving machine takes the
packets and reassembles them; a &#8220;header packet&#8221; tells the machine
how many to expect and any other important information. If a packet is lost, the
receiving machine sends a datagram back telling the sender to
retransmit.</FONT><A NAME="_Toc408018772"></A><BR></P></DIV>
<A NAME="Heading519"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
A Web application<BR><A NAME="Index2679"></A><A NAME="Index2680"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now let&#8217;s consider creating
an application to run on the Web, which will show Java in all its glory. Part of
this application will be a Java program running on the Web server, and the other
part will be an <A NAME="Index2681"></A><A NAME="Index2682"></A>applet
that&#8217;s downloaded to the browser. The applet collects information from the
user and sends it back to the application running on the Web server. The task of
the program will be simple: the applet will ask for the email address of the
user, and after verifying that this address is reasonably legitimate (it
doesn&#8217;t contain spaces, and it does contain an &#8216;@&#8217; symbol) the
applet will send the email address to the Web server. The application running on
the server will capture the data and check a data file in which all of the email
addresses are kept. If that address is already in the file, it will send back a
message to that effect, which is displayed by the applet. If the address
isn&#8217;t in the file, it is placed in the list and the applet is informed
that the address was added successfully.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Traditionally, the way to handle
such a problem is to create an
<A NAME="Index2683"></A><A NAME="Index2684"></A>HTML page with a text field and
a &#8220;submit&#8221; button. The user can type whatever he or she wants into
the text field, and it will be submitted to the server without question. As it
submits the data, the Web page also tells the server what to do with the data by
mentioning the
<A NAME="Index2685"></A><A NAME="Index2686"></A><A NAME="Index2687"></A>Common
Gateway Interface (CGI) program that the server should run after receiving this
data. This CGI program is typically written in either Perl or C (and sometimes
C++, if the server supports it), and it must handle everything. First it looks
at the data and decides whether it&#8217;s in the correct format. If not, the
CGI program must create an HTML page to describe the problem; this page is
handed to the server, which sends it back to the user. The user must then back
up a page and try again. If the data is correct, the CGI program opens the data
file and either adds the email address to the file or discovers that the address
is already in the file. In both cases it must format an appropriate HTML page
for the server to return to the user.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As Java programmers, this seems
like an awkward way for us to solve the problem, and naturally, we&#8217;d like
to do the whole thing in Java. First, we&#8217;ll use a Java applet to take care
of data validation at the client site, without all that tedious Web traffic and
page formatting. Then let&#8217;s skip the Perl CGI script in favor of a Java
application running on the server. In fact, let&#8217;s skip the Web server
altogether and simply make our own network connection from the applet to the
Java application on the server!</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you&#8217;ll see, there are a
number of issues that make this a more complicated problem than it seems. It
would be ideal to write the applet using Java 1.1<A NAME="Index2688"></A> but
that&#8217;s hardly practical. At this writing, the number of users running Java
1.1-enabled browsers is small, and although such browsers are now commonly
available, you&#8217;ll probably need to take into account that a significant
number of users will be slow to upgrade. So to be on the safe side, the applet
will be programmed using only Java 1.0<A NAME="Index2689"></A> code. With this
in mind, there will be no JAR files to combine <B>.class</B> files in the
applet, so the applet should be designed to create as few <B>.class</B> files as
possible to minimize download time.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Well, it turns out the Web server
(the one available to me when I wrote the example) <I>does</I> have Java in it,
but only Java 1.0<A NAME="Index2690"></A>! So the server application must also
be written using Java 1.0.</FONT><A NAME="_Toc408018773"></A><BR></P></DIV>
<A NAME="Heading520"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The server application</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now consider the server
application, which will be called <B>NameCollector</B>. What happens if more
than one user at a time tries to submit their email addresses? If
<B>NameCollector</B> uses TCP/IP sockets, then it must use the multithreading
approach shown earlier to handle more than one client at a time. But all of
these threads will try to write to a single file where all the email addresses
will be kept. This would require a locking mechanism to make sure that more than
one thread doesn&#8217;t access the file at once. A semaphore will do the trick,
but perhaps there&#8217;s a simpler way. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If we use datagrams instead,
multithreading is unnecessary. A single
<A NAME="Index2691"></A><A NAME="Index2692"></A>datagram socket will listen for
incoming datagrams, and when one appears the program will process the message
and send the reply as a datagram back to whomever sent the request. If the
datagram gets lost, then the user will notice that no reply comes and can then
re-submit the request.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the server application
receives a datagram and unpacks it, it must extract the email address and check
the file to see if that address is there already (and if it isn&#8217;t, add
it). And now we run into another problem. It turns out that Java 1.0
doesn&#8217;t quite have the horsepower to easily manipulate the file containing
the email addresses (Java 1.1<A NAME="Index2693"></A> does). However, the
problem can be solved in C quite readily, and this will provide an excuse to
show you the easiest way to
<A NAME="Index2694"></A><A NAME="Index2695"></A><A NAME="Index2696"></A><A NAME="Index2697"></A>connect
a non-Java program to a Java program. A <A NAME="Index2698"></A><B>Runtime</B>
object for a program has a method called
<A NAME="Index2699"></A><A NAME="Index2700"></A><B>exec(&#160;)</B> that will
start up a separate program on the machine and return a
<A NAME="Index2701"></A><A NAME="Index2702"></A><B>Process</B> object. You can
get an <A NAME="Index2703"></A><A NAME="Index2704"></A><B>OutputStream</B> that
connects to standard input for this separate program and an
<A NAME="Index2705"></A><A NAME="Index2706"></A><B>InputStream</B> that connects
to standard output. All you need to do is write a program using any language
that takes its input from standard input and writes the output to standard
output. This is a convenient trick when you run into a problem that can&#8217;t
be solved easily or quickly enough in Java (or when you have legacy code you
don&#8217;t want to rewrite). You can also use Java&#8217;s <I>native
methods</I> (see Appendix A) but those are much more involved.</FONT><BR></P></DIV>
<A NAME="Heading521"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The C program</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The job of this non-Java
application (written in C because Java wasn&#8217;t appropriate for CGI
programming; if nothing else, the startup time is prohibitive) is to manage the
list of email addresses. Standard input will accept an email address and the
program will look up the name in the list to see if it&#8217;s already there. If
not, it will add it and report success, but if the name is already there then it
will report that. Don&#8217;t worry if you don&#8217;t completely understand
what the following code means; it&#8217;s just one example of how you can write
a program in another language and use it from Java. The particular programming
language doesn&#8217;t really matter as long as it can read from standard input
and write to standard output.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Listmgr.c</font>
<font color=#009900>// Used by NameCollector.java to manage </font>
<font color=#009900>// the email list file on the server</font>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BSIZE 250

<font color=#0000ff>int</font> alreadyInList(FILE* list, <font color=#0000ff>char</font>* name) {
  <font color=#0000ff>char</font> lbuf[BSIZE];
  <font color=#009900>// Go to the beginning of the list:</font>
  fseek(list, 0, SEEK_SET);
  <font color=#009900>// Read each line in the list:</font>
  <font color=#0000ff>while</font>(fgets(lbuf, BSIZE, list)) {
    <font color=#009900>// Strip off the newline:</font>
    <font color=#0000ff>char</font> * newline = strchr(lbuf, '\n');
    <font color=#0000ff>if</font>(newline != 0) 
      *newline = '\0';
    <font color=#0000ff>if</font>(strcmp(lbuf, name) == 0)
      <font color=#0000ff>return</font> 1;
  }
  <font color=#0000ff>return</font> 0;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>char</font> buf[BSIZE];
  FILE* list = fopen(<font color=#004488>"emlist.txt"</font>, <font color=#004488>"a+t"</font>);
  <font color=#0000ff>if</font>(list == 0) {
    perror(<font color=#004488>"could not open emlist.txt"</font>);
    exit(1);
  }
  <font color=#0000ff>while</font>(1) {
    gets(buf); <font color=#009900>/* From stdin */</font>
    <font color=#0000ff>if</font>(alreadyInList(list, buf)) {
      printf(<font color=#004488>"Already in list: %s"</font>, buf);
      fflush(stdout);
    }
    <font color=#0000ff>else</font> {
      fseek(list, 0, SEEK_END);
      fprintf(list, <font color=#004488>"%s\n"</font>, buf);
      fflush(list);
      printf(<font color=#004488>"%s added to list"</font>, buf);
      fflush(stdout);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This assumes that the C compiler
accepts <B>&#8216;//&#8217;</B> style comments. (Many do, and you can also
compile this program with a C++ compiler.) If yours doesn&#8217;t, simply delete
those comments.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first function in the file
checks to see whether the name you hand it as a second argument (a pointer to a
<B>char</B>)<B> </B>is in the file. Here, the file is passed as a <B>FILE</B>
pointer to an already-opened file (the file is opened inside
<B>main(&#160;)</B>). The function <B>fseek(&#160;)</B> moves around in the
file; here it is used to move to the top of the file. <B>fgets(&#160;)</B> reads
a line from the file <B>list</B> into the buffer <B>lbuf</B>, not exceeding the
buffer size <B>BSIZE</B>. This is inside a <B>while </B>loop so that each line
in the file is read. Next, <B>strchr(&#160;)</B> is used to locate the newline
character so that it can be stripped off. Finally, <B>strcmp(&#160;) </B>is used
to compare the name you&#8217;ve passed into the function to the current line
int the file. <B>strcmp(&#160;)</B> returns zero if it finds a match. In this
case the function exits and a one is returned to indicate that yes, the name was
already in the list. (Note that the function returns as soon as it discovers the
match, so it doesn&#8217;t waste time looking at the rest of the list.) If you
get all the way through the list without a match, the function returns
zero.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, the file is
opened using <B>fopen(&#160;)</B>. The first argument is the file name and the
second is the way to open the file; <B>a+</B> means &#8220;Append, and open (or
create if the file does not exist) for update at the end of the file.&#8221; The
<B>fopen(&#160;)</B> function returns a <B>FILE</B> pointer which, if it&#8217;s
zero, means that the open was unsuccessful. This is dealt with by printing an
error message with <B>perror(&#160;)</B> and terminating the program with
<B>exit(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Assuming that the file was opened
successfully, the program enters an infinite loop. The function call
<B>gets(buf)</B> gets a line from standard input (which will be connected to the
Java program, remember) and places it in the buffer <B>buf</B>. This is simply
passed to the <B>alreadyInList(&#160;)</B> function, and if it&#8217;s already
in the list, <B>printf(&#160;)</B> sends that message to standard output (where
the Java program is listening). <B>fflush(&#160;)</B> is a way to flush the
output buffer.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the name is not already in the
list, <B>fseek(&#160;)</B> is used to move to the end of the list and
<B>fprintf(&#160;)</B> &#8220;prints&#8221; the name to the end of the list.
Then <B>printf(&#160;)</B> is used to indicate that the name was added to the
list (again flushing standard output) and the infinite loop goes back to waiting
for a new name.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Remember that you usually cannot
compile this program on your computer and load it onto the Web server machine,
since that machine might use a different processor and operating system. For
example, my Web server runs on an Intel processor but it uses Linux, so I must
download the source code and compile using remote commands (via telnet) with the
C compiler that comes with the Linux distribution.</FONT><BR></P></DIV>
<A NAME="Heading522"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The Java program</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program will first start the C
program above and make the necessary connections to talk to it. Then it will
create a datagram socket that will be used to listen for datagram packets from
the applet.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: NameCollector.java</font>
<font color=#009900>// Extracts email names from datagrams and stores</font>
<font color=#009900>// them inside a file, using Java 1.02.</font>
<font color=#0000ff>import</font> java.net.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> NameCollector {
  <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> COLLECTOR_PORT = 8080;
  <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> BUFFER_SIZE = 1000;
  <font color=#0000ff>byte</font>[] buf = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[BUFFER_SIZE];
  DatagramPacket dp = 
    <font color=#0000ff>new</font> DatagramPacket(buf, buf.length);
  <font color=#009900>// Can listen &amp; send on the same socket:</font>
  DatagramSocket socket;
  Process listmgr;
  PrintStream nameList;
  DataInputStream addResult;
  <font color=#0000ff>public</font> NameCollector() {
    <font color=#0000ff>try</font> {
      listmgr =
        Runtime.getRuntime().exec(<font color=#004488>"listmgr.exe"</font>);
      nameList = <font color=#0000ff>new</font> PrintStream(
        <font color=#0000ff>new</font> BufferedOutputStream(
          listmgr.getOutputStream()));
      addResult = <font color=#0000ff>new</font> DataInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(
          listmgr.getInputStream()));

    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(
        <font color=#004488>"Cannot start listmgr.exe"</font>);
      System.exit(1);
    }
    <font color=#0000ff>try</font> {
      socket =
        <font color=#0000ff>new</font> DatagramSocket(COLLECTOR_PORT);
      System.out.println(
        <font color=#004488>"NameCollector Server started"</font>);
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
        <font color=#009900>// Block until a datagram appears:</font>
        socket.receive(dp);
        String rcvd = <font color=#0000ff>new</font> String(dp.getData(),
            0, 0, dp.getLength());
        <font color=#009900>// Send to listmgr.exe standard input:</font>
        nameList.println(rcvd.trim());
        nameList.flush();
        <font color=#0000ff>byte</font>[] resultBuf = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[BUFFER_SIZE];
        <font color=#0000ff>int</font> byteCount = 
          addResult.read(resultBuf);
        <font color=#0000ff>if</font>(byteCount != -1) {
          String result = 
            <font color=#0000ff>new</font> String(resultBuf, 0).trim();
          <font color=#009900>// Extract the address and port from </font>
          <font color=#009900>// the received datagram to find out </font>
          <font color=#009900>// where to send the reply:</font>
          InetAddress senderAddress =
            dp.getAddress();
          <font color=#0000ff>int</font> senderPort = dp.getPort();
          <font color=#0000ff>byte</font>[] echoBuf = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[BUFFER_SIZE];
          result.getBytes(
            0, byteCount, echoBuf, 0);
          DatagramPacket echo =
            <font color=#0000ff>new</font> DatagramPacket(
              echoBuf, echoBuf.length,
              senderAddress, senderPort);
          socket.send(echo);
        }
        <font color=#0000ff>else</font>
          System.out.println(
            <font color=#004488>"Unexpected lack of result from "</font> +
            <font color=#004488>"listmgr.exe"</font>);
      }
    } <font color=#0000ff>catch</font>(SocketException e) {
      System.err.println(<font color=#004488>"Can't open socket"</font>);
      System.exit(1);
    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(<font color=#004488>"Communication error"</font>);
      e.printStackTrace();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>new</font> NameCollector();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first definitions in
<B>NameCollector</B> should look familiar: the port is chosen, a datagram packet
is created, and there&#8217;s a handle to a <B>DatagramSocket</B>. The next
three definitions concern the connection to the C program: a <B>Process</B>
object is what comes back when the C program is fired up by the Java program,
and that <B>Process</B> object produces the <B>InputStream</B> and
<B>OutputStream</B> objects representing, respectively, the standard output and
standard input of the C program. These must of course be &#8220;wrapped&#8221;
as is usual with Java IO, so we end up with a <B>PrintStream</B> and
<B>DataInputStream</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the work for this program
happens inside the constructor. To start up the C program, the current
<B>Runtime</B> object is procured. This is used to call
<A NAME="Index2707"></A><B>exec(&#160;)</B>, which returns the <B>Process</B>
object. You can see that there are simple calls to produce the streams from the
<B>Process</B> object: <B>getOutputStream(&#160;)</B> and
<B>getInputStream(&#160;)</B>. From this point on, all you need to consider is
sending data to the stream <B>nameList</B> and getting the results from
<B>addResult</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As before, a <B>DatagramSocket</B>
is connected to a port. Inside the infinite <B>while</B> loop, the program calls
<B>receive(&#160;)</B>, which blocks until a datagram shows up. When the
datagram appears, its contents are extracted into the <B>String rcvd</B>. This
is trimmed to remove white space at each end and sent to the C program in the
line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>nameList.println(rcvd.trim());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is only possible because
Java&#8217;s <B>exec(&#160;)</B> provides access to any executable that reads
from standard input and writes to standard output. There are other ways to talk
to non-Java code, which are discussed in Appendix A.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Capturing the result from the C
program is slightly more complicated. You must call
<A NAME="Index2708"></A><B>read(&#160;)</B> and provide a buffer where the
results will be placed. The return value for <B>read(&#160;)</B> is the number
of bytes that came from the C program, and if this value is -1 it means that
something is wrong. Otherwise, the <B>resultBuf</B> is turned into a
<B>String</B> and the spaces are trimmed off. This string is then placed into a
<B>DatagramPacket</B> as before and shipped back to the same address that sent
the request in the first place. Note that the sender&#8217;s address is part of
the <B>DatagramPacket</B> we received.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Remember that although the C
program must be compiled on the Web server, the Java program can be compiled
anywhere since the resulting byte codes will be the same regardless of the
platform on which the program will be
running.</FONT><A NAME="_Toc408018774"></A><BR></P></DIV>
<A NAME="Heading523"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The NameSender applet</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As mentioned earlier, the applet
must be written with Java 1.0<A NAME="Index2709"></A> so that it will run on the
largest number of browsers, so it&#8217;s best if the number of classes produced
is minimized. Thus, instead of using the <B>Dgram</B> class developed earlier,
all of the <A NAME="Index2710"></A><A NAME="Index2711"></A>datagram
manipulations will be placed in line. In addition, the applet needs a thread to
listen for the reply from the server, and instead of making this a separate
thread it&#8217;s integrated into the applet by implementing the
<A NAME="Index2712"></A><B>Runnable</B> interface. This isn&#8217;t as easy to
read, but it produces a one-class (and one-server-hit) applet:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: NameSender.java</font>
<font color=#009900>// An applet that sends an email address</font>
<font color=#009900>// as a datagram, using Java 1.02.</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;
<font color=#0000ff>import</font> java.net.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> NameSender <font color=#0000ff>extends</font> Applet 
    <font color=#0000ff>implements</font> Runnable {
  <font color=#0000ff>private</font> Thread pl = <font color=#0000ff>null</font>;
  <font color=#0000ff>private</font> Button send = <font color=#0000ff>new</font> Button(
    <font color=#004488>"Add email address to mailing list"</font>);
  <font color=#0000ff>private</font> TextField t = <font color=#0000ff>new</font> TextField(
    <font color=#004488>"type your email address here"</font>, 40);
  <font color=#0000ff>private</font> String str = <font color=#0000ff>new</font> String();
  <font color=#0000ff>private</font> Label 
    l = <font color=#0000ff>new</font> Label(), l2 = <font color=#0000ff>new</font> Label();
  <font color=#0000ff>private</font> DatagramSocket s; 
  <font color=#0000ff>private</font> InetAddress hostAddress;
  <font color=#0000ff>private</font> <font color=#0000ff>byte</font>[] buf = 
    <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[NameCollector.BUFFER_SIZE];
  <font color=#0000ff>private</font> DatagramPacket dp =
    <font color=#0000ff>new</font> DatagramPacket(buf, buf.length);
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> vcount = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    Panel p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> GridLayout(2, 1));
    p.add(t);
    p.add(send);
    add(<font color=#004488>"North"</font>, p);
    Panel labels = <font color=#0000ff>new</font> Panel();
    labels.setLayout(<font color=#0000ff>new</font> GridLayout(2, 1));
    labels.add(l);
    labels.add(l2);
    add(<font color=#004488>"Center"</font>, labels);
    <font color=#0000ff>try</font> {
      <font color=#009900>// Auto-assign port number:</font>
      s = <font color=#0000ff>new</font> DatagramSocket();
      hostAddress = InetAddress.getByName(
        getCodeBase().getHost());
    } <font color=#0000ff>catch</font>(UnknownHostException e) {
      l.setText(<font color=#004488>"Cannot find host"</font>);
    } <font color=#0000ff>catch</font>(SocketException e) {
      l.setText(<font color=#004488>"Can't open socket"</font>);
    } 
    l.setText(<font color=#004488>"Ready to send your email address"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(send)) {
      <font color=#0000ff>if</font>(pl != <font color=#0000ff>null</font>) {
        <font color=#009900>// pl.stop(); Deprecated in Java 1.2</font>
        Thread remove = pl;
        pl = <font color=#0000ff>null</font>;
        remove.interrupt();
      }
      l2.setText(<font color=#004488>""</font>);
      <font color=#009900>// Check for errors in email name:</font>
      str = t.getText().toLowerCase().trim();
      <font color=#0000ff>if</font>(str.indexOf(' ') != -1) {
        l.setText(<font color=#004488>"Spaces not allowed in name"</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      <font color=#0000ff>if</font>(str.indexOf(',') != -1) {
        l.setText(<font color=#004488>"Commas not allowed in name"</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      <font color=#0000ff>if</font>(str.indexOf('@') == -1) {
        l.setText(<font color=#004488>"Name must include '@'"</font>);
        l2.setText(<font color=#004488>""</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      <font color=#0000ff>if</font>(str.indexOf('@') == 0) {
        l.setText(<font color=#004488>"Name must preceed '@'"</font>);
        l2.setText(<font color=#004488>""</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      String end = 
        str.substring(str.indexOf('@'));
      <font color=#0000ff>if</font>(end.indexOf('.') == -1) {
        l.setText(<font color=#004488>"Portion after '@' must "</font> +
          <font color=#004488>"have an extension, such as '.com'"</font>);
        l2.setText(<font color=#004488>""</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      <font color=#009900>// Everything's OK, so send the name. Get a</font>
      <font color=#009900>// fresh buffer, so it's zeroed. For some </font>
      <font color=#009900>// reason you must use a fixed size rather</font>
      <font color=#009900>// than calculating the size dynamically:</font>
      <font color=#0000ff>byte</font>[] sbuf = 
        <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[NameCollector.BUFFER_SIZE];
      str.getBytes(0, str.length(), sbuf, 0);
      DatagramPacket toSend =
        <font color=#0000ff>new</font> DatagramPacket(
          sbuf, 100, hostAddress,
          NameCollector.COLLECTOR_PORT);
      <font color=#0000ff>try</font> {
        s.send(toSend);
      } <font color=#0000ff>catch</font>(Exception e) {
        l.setText(<font color=#004488>"Couldn't send datagram"</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      l.setText(<font color=#004488>"Sent: "</font> + str);
      send.setLabel(<font color=#004488>"Re-send"</font>);
      pl = <font color=#0000ff>new</font> Thread(<font color=#0000ff>this</font>);
      pl.start();
      l2.setText(
        <font color=#004488>"Waiting for verification "</font> + ++vcount);
    }
    <font color=#0000ff>else</font> <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#009900>// The thread portion of the applet watches for</font>
  <font color=#009900>// the reply to come back from the server:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>try</font> {
      s.receive(dp);
    } <font color=#0000ff>catch</font>(Exception e) {
      l2.setText(<font color=#004488>"Couldn't receive datagram"</font>);
      <font color=#0000ff>return</font>;
    }
    l2.setText(<font color=#0000ff>new</font> String(dp.getData(),
      0, 0, dp.getLength()));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The UI for the applet is quite
simple. There&#8217;s a <B>TextField</B> in which you type your email address,
and a <B>Button</B> to send the email address to the server. Two <B>Label</B>s
are used to report status back to the user.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By now you can recognize the
<A NAME="Index2713"></A><A NAME="Index2714"></A><B>DatagramSocket</B>,
<A NAME="Index2715"></A><A NAME="Index2716"></A><B>InetAddress</B>, buffer, and
<A NAME="Index2717"></A><A NAME="Index2718"></A><B>DatagramPacket</B> as
trappings of the network connection. Lastly, you can see the <B>run(&#160;)</B>
method that implements the thread portion so the applet can listen for the reply
sent back by the server.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>init(&#160;)</B> method sets
up the GUI with the familiar layout tools, then creates the
<B>DatagramSocket</B> that will be used both for sending and receiving
datagrams.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index2719"></A><A NAME="Index2720"></A><B>action(&#160;)</B> method
(remember, we&#8217;re confined to Java 1.0<A NAME="Index2721"></A> now, so we
can&#8217;t use any slick inner listener classes) watches only to see if you
press the &#8220;send&#8221; button. When the button is pressed, the first
action is to check the <B>Thread pl</B> to see if it&#8217;s <B>null</B>. If
it&#8217;s not <B>null</B>, there&#8217;s a live thread running. The first time
the message is sent a thread is started up to watch for the reply. Thus, if a
thread is running, it means this is not the first time the user has tried to
send the message. The <B>pl </B>handle is set to <B>null</B> and the old
listener is interrupted. (This is the preferred approach, since
<A NAME="Index2722"></A><A NAME="Index2723"></A><B>stop(&#160;)</B> is
deprecated in Java 1.2<A NAME="Index2724"></A> as explained in the previous
chapter.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Regardless of whether this is the
first time the button was pressed, the text in <B>l2</B> is
erased.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next group of statements checks
the email name for errors. The
<A NAME="Index2725"></A><A NAME="Index2726"></A><B>String.indexOf(&#160;)</B>
method is used to search for illegal characters, and if one is found it is
reported to the user. Note that all of this happens without any network
activity, so it&#8217;s fast and it doesn&#8217;t bog down the
Internet.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the name is verified, it is
packaged into a datagram and sent to the host address and port number in the
same way that was described in the earlier datagram example. The first label is
changed to show you that the send has occurred, and the button text is changed
so that it reads &#8220;re-send.&#8221; At this point, the thread is started up
and the second label informs you that the applet is waiting for a reply from the
server. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>run(&#160;)</B> method for
the thread uses the <B>DatagramSocket</B> that lives in <B>NameSender</B> to
<A NAME="Index2727"></A><A NAME="Index2728"></A><B>receive(&#160;)</B>, which
blocks until the datagram packet comes from the server. The resulting packet is
placed into <B>NameSender</B>&#8217;s <B>DatagramPacket dp</B>. The data is
retrieved from the packet and placed into the second label in <B>NameSender</B>.
At this point, the thread terminates and becomes dead. If the reply
doesn&#8217;t come back from the server in a reasonable amount of time, the user
might become impatient and press the button again, thus terminating the current
thread (and, after re-sending the data, starting a new one). Because a thread is
used to listen for the reply, the user still has full use of the
UI.</FONT><BR></P></DIV>
<A NAME="Heading524"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The Web page</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, the applet must go
inside a Web page. Here is the complete Web page; you can see that it&#8217;s
intended to be used to automatically collect names for my mailing
list:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META CONTENT=<font color=#004488>"text</font><font color=#004488>/html"</font>&gt;
&lt;TITLE&gt;
Add Yourself to Bruce Eckel's Java Mailing List
&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY LINK=<font color=#004488>"#0000ff"</font> VLINK=<font color=#004488>"#800080"</font> BGCOLOR=<font color=#004488>"#ffffff"</font>&gt;
&lt;FONT SIZE=6&gt;&lt;P&gt;
Add Yourself to Bruce Eckel's Java Mailing List
&lt;/P&gt;&lt;/FONT&gt;
The applet on <font color=#0000ff>this</font> page will automatically add your email address to the mailing list, so you will receive update information about changes to the online version of <font color=#004488>"Thinking in Java,"</font> notification when the book is in print, information about upcoming Java seminars, and notification about the &#8220;Hands-on Java Seminar&#8221; Multimedia CD. Type in your email address and press the button to automatically add yourself to <font color=#0000ff>this</font> mailing list. &lt;HR&gt;
&lt;applet code=NameSender width=400 height=100&gt;
&lt;/applet&gt;
&lt;HR&gt;
If after several tries, you <font color=#0000ff>do</font> not get verification it means that the Java application on the server is having problems. In <font color=#0000ff>this</font> <font color=#0000ff>case</font>, you can add yourself to the list by sending email to 
&lt;A HREF=<font color=#004488>"mailto:Bruce@EckelObjects.com"</font>&gt;
Bruce@EckelObjects.com&lt;/A&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The applet tag is quite trivial, no
different from the first one presented in Chapter
13.</FONT><A NAME="_Toc408018775"></A><BR></P></DIV>
<A NAME="Heading525"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Problems with this approach</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This certainly seems like an
elegant approach. There&#8217;s no CGI programming and so there are no delays
while the server starts up a CGI program. The datagram approach seems to produce
a nice quick response. In addition, when Java 1.1<A NAME="Index2729"></A> is
available everywhere, the server portion can be written entirely in Java.
(Although it&#8217;s quite interesting to see how easy it is to connect to a
non-Java program using standard input and output.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are problems, however. One
problem is rather subtle: since the Java application is running constantly on
the server and it spends most of its time blocked in the
<A NAME="Index2730"></A><A NAME="Index2731"></A><A NAME="Index2732"></A><B>Datagram.receive(&#160;)</B>
method, there <I>might</I> be some CPU hogging going on. At least, that&#8217;s
the way it appeared on the server where I was experimenting. On the other hand,
there wasn&#8217;t much else happening on that server, and starting the program
using &#8220;nice&#8221; (a Unix program to prevent a process from hogging the
CPU) or its equivalent could solve the problem if you have a more heavily-loaded
server. In any event, it&#8217;s worth keeping your eye on an application like
this &#8211; a blocked <B>receive(&#160;)</B> could hog the
CPU.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second problem is a show
stopper. It concerns firewalls. A
<A NAME="Index2733"></A><A NAME="Index2734"></A>firewall is a machine that sits
between your network and the Internet. It monitors all traffic coming in from
the Internet and going out to the Internet, and makes sure that traffic conforms
to what it expects.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Firewalls are conservative little
beasts. They demand strict conformance to all the rules, and if you&#8217;re not
conforming they assume that you&#8217;re doing something sinful and shut you out
(not quite so bad as the Spanish Inquisition, but close). For example, if you
are on a network behind a firewall and you start connecting to the Internet
using a Web browser, the firewall expects that all your transactions will
connect to the server using the accepted http port, which is 80. Now along comes
this Java applet <B>NameSender,</B> which is trying to send a datagram to port
8080, which is way outside the range of the &#8220;protected&#8221; ports
0-1024. The firewall naturally assumes the worst &#8211; that someone has a
virus &#8211; and it doesn&#8217;t allow the transaction to
happen.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As long as your customers have raw
connections to the Internet (for example, using a typical Internet service
provider) there&#8217;s no problem, but you might have some important customers
dwelling behind firewalls, and they won&#8217;t be able to use your
program.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is rather disheartening after
learning so much Java, because it would seem that you must give up Java on the
server and learn how to write CGI scripts in C or Perl. But as it turns out,
despair is not in order.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One scenario is part of Sun&#8217;s
grand scheme. If everything goes as planned, Web servers will be equipped with
<A NAME="Index2735"></A><A NAME="Index2736"></A><I>servlet servers</I>. These
will take a request from the client (going through the firewall-accepted port
80) and instead of starting up a CGI program they will start up a Java program
called a <I>servlet</I>. This is a little application that&#8217;s designed to
run only on the server. A servlet server will automatically start up the servlet
to handle the client request, which means you can write all your programs in
Java (further enabling the &#8220;100 percent pure Java initiative&#8221;). It
is admittedly an appealing idea: once you&#8217;re comfortable with Java, you
don&#8217;t have to switch to a more primitive language to handle requests on
the server.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since it&#8217;s only for handling
requests on the server, the servlet API has no GUI abilities. This fits quite
well with <B>NameCollector.java</B>, which doesn&#8217;t have a GUI
anyway.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this writing, a low-cost servlet
server was available from <I>java.sun.com</I>. In addition, Sun is encouraging
other Web server manufacturers to add servlet capabilities to their
servers.</FONT><A NAME="_Toc408018776"></A><BR></P></DIV>
<A NAME="Heading526"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Connecting Java to CGI<BR><A NAME="Index2737"></A><A NAME="Index2738"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A Java program can send a CGI
request to a server just like an HTML page can. As with HTML pages, this request
can be either a <A NAME="Index2739"></A><A NAME="Index2740"></A>GET or a
<A NAME="Index2741"></A><A NAME="Index2742"></A>POST. In addition, the Java
program can intercept the output of the CGI program, so you don&#8217;t have to
rely on the program to format a new page and force the user to back up from one
page to another if something goes wrong. In fact, the appearance of the program
can be the same as the previous version.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It also turns out that the code is
simpler, and that CGI isn&#8217;t difficult to write after all. (An innocent
statement that&#8217;s true of many things &#8211; <I>after</I> you understand
them.) So in this section you&#8217;ll get a
<A NAME="Index2743"></A><A NAME="Index2744"></A>crash course in CGI programming.
To solve the general problem, some CGI tools will be created in C++ that will
allow you to easily write a CGI program to solve any problem. The benefit to
this approach is portability &#8211; the example you are about to see will work
on any system that supports CGI, and there&#8217;s no problem with
firewalls.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example also works out the
basics of creating any connection with applets and CGI programs, so you can
easily adapt it to your own
projects.</FONT><A NAME="_Toc408018777"></A><BR></P></DIV>
<A NAME="Heading527"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Encoding data for CGI</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this version, the name
<I>and</I> the email address will be collected and stored in the file in the
form:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>First Last &lt;email@domain.com&gt;;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is a convenient form for many
mailers. Since two fields are being collected, there are no shortcuts because
CGI has a particular format for encoding the data in fields. You can see this
for yourself if you make an ordinary
<A NAME="Index2745"></A><A NAME="Index2746"></A>HTML page and add the
lines:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;Form method=<font color=#004488>"GET"</font> ACTION=<font color=#004488>"</font><font color=#004488>/cgi-bin</font><font color=#004488>/Listmgr2.exe"</font>&gt;
&lt;P&gt;Name: &lt;INPUT TYPE = <font color=#004488>"text"</font> NAME = <font color=#004488>"name"</font> 
VALUE = <font color=#004488>""</font> size = <font color=#004488>"40"</font>&gt;&lt;/p&gt;
&lt;P&gt;Email Address: &lt;INPUT TYPE = <font color=#004488>"text"</font> 
NAME = <font color=#004488>"email"</font> VALUE = <font color=#004488>""</font> size = <font color=#004488>"40"</font>&gt;&lt;/p&gt;
&lt;p&gt;&lt;input type = <font color=#004488>"submit"</font> name = <font color=#004488>"submit"</font> &gt; &lt;/p&gt;
&lt;/Form&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This creates two data entry fields
called <B>name</B> and <B>email</B>, along with a <B>submit</B> button that
collects the data and sends it to a CGI program. <B>Listmgr2.exe</B> is the name
of the executable program that resides in the directory that&#8217;s typically
called &#8220;cgi-bin&#8221; on your Web
server.</FONT><A NAME="fnB61" HREF="#fn61">[61]</A><FONT FACE="Georgia">
(If the named program is not in the cgi-bin directory, you won&#8217;t see any
results.) If you fill out this form and press the &#8220;submit&#8221; button,
you will see in the URL address window of the browser something
like:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>http:<font color=#009900>//www.myhome.com/cgi-bin/Listmgr2.exe?</font>
name=First+Last&amp;email=email@domain.com&amp;submit=Submit</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(Without the line break, of
course). Here you see a little bit of the way that data is encoded to send to
CGI. For one thing, spaces are not allowed (since spaces typically separate
command-line arguments). Spaces are replaced by &#8216;<B>+</B>&#8217; signs. In
addition, each field contains the field name (which is determined by the HTML
page) followed by an &#8216;<B>=</B>&#8217; and the field data, and terminated
by a &#8216;<B>&amp;</B>&#8217;.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point, you might wonder
about the &#8216;<B>+</B>&#8217;, &#8216;<B>=,</B>&#8217; and
&#8216;<B>&amp;</B>&#8217;. What if those are used in the field, as in
&#8220;John &amp; Marsha Smith&#8221;? This is encoded to: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>John+%26+Marsha+Smith</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That is, the special character is
turned into a <B>&#8216;%</B>&#8217; followed by its ASCII value in
hex.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Fortunately, Java has a tool to
perform this encoding for you. It&#8217;s a static method of the class
<A NAME="Index2747"></A><A NAME="Index2748"></A><A NAME="Index2749"></A><B>URLEncoder</B>
called <B>encode(&#160;)</B>. You can experiment with this method using the
following program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: EncodeDemo.java</font>
<font color=#009900>// Demonstration of URLEncoder.encode()</font>
<font color=#0000ff>import</font> java.net.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> EncodeDemo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String s = <font color=#004488>""</font>;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; args.length; i++)
      s += args[i] + <font color=#004488>" "</font>;
    s = URLEncoder.encode(s.trim());
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This takes the command-line
arguments and combines them into a string of words separated by spaces (the
final space is removed using <B>String.trim(&#160;)</B>). These are then encoded
and printed.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To
<A NAME="Index2750"></A><A NAME="Index2751"></A>invoke a CGI program, all the
applet needs to do is collect the data from its fields (or wherever it needs to
collect the data from), URL-encode each piece of data, and then assemble it into
a single string, placing the name of each field followed by an
&#8216;<B>=</B>&#8217;, followed by the data, followed by an
&#8216;<B>&amp;</B>&#8217;. To form the entire CGI command, this string is
placed after the URL of the CGI program and a &#8216;<B>?</B>&#8217;.
That&#8217;s all it takes to invoke any CGI program, and as you&#8217;ll see you
can easily do it within an applet.</FONT><A NAME="_Toc408018778"></A><BR></P></DIV>
<A NAME="Heading528"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The applet</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The applet is actually considerably
simpler than <B>NameSender.java</B>, partly because it&#8217;s so easy to send a
<A NAME="Index2752"></A><A NAME="Index2753"></A>GET request and also because no
thread is required to wait for the reply. There are now two fields instead of
one, but you&#8217;ll notice that much of the applet looks familiar, from
<B>NameSender.java</B>.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: NameSender2.java</font>
<font color=#009900>// An applet that sends an email address</font>
<font color=#009900>// via a CGI GET, using Java 1.02.</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;
<font color=#0000ff>import</font> java.net.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> NameSender2 <font color=#0000ff>extends</font> Applet {
  <font color=#0000ff>final</font> String CGIProgram = <font color=#004488>"Listmgr2.exe"</font>;
  Button send = <font color=#0000ff>new</font> Button(
    <font color=#004488>"Add email address to mailing list"</font>);
  TextField name = <font color=#0000ff>new</font> TextField(
    <font color=#004488>"type your name here"</font>, 40),
    email = <font color=#0000ff>new</font> TextField(
    <font color=#004488>"type your email address here"</font>, 40);
  String str = <font color=#0000ff>new</font> String();
  Label l = <font color=#0000ff>new</font> Label(), l2 = <font color=#0000ff>new</font> Label();
  <font color=#0000ff>int</font> vcount = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    Panel p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> GridLayout(3, 1));
    p.add(name);
    p.add(email);
    p.add(send);
    add(<font color=#004488>"North"</font>, p);
    Panel labels = <font color=#0000ff>new</font> Panel();
    labels.setLayout(<font color=#0000ff>new</font> GridLayout(2, 1));
    labels.add(l);
    labels.add(l2);
    add(<font color=#004488>"Center"</font>, labels);
    l.setText(<font color=#004488>"Ready to send email address"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(send)) {
      l2.setText(<font color=#004488>""</font>);
      <font color=#009900>// Check for errors in data:</font>
      <font color=#0000ff>if</font>(name.getText().trim()
         .indexOf(' ') == -1) {
        l.setText(
          <font color=#004488>"Please give first and last name"</font>);
        l2.setText(<font color=#004488>""</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      str = email.getText().trim();
      <font color=#0000ff>if</font>(str.indexOf(' ') != -1) {
        l.setText(
          <font color=#004488>"Spaces not allowed in email name"</font>);
        l2.setText(<font color=#004488>""</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      <font color=#0000ff>if</font>(str.indexOf(',') != -1) {
        l.setText(
          <font color=#004488>"Commas not allowed in email name"</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      <font color=#0000ff>if</font>(str.indexOf('@') == -1) {
        l.setText(<font color=#004488>"Email name must include '@'"</font>);
        l2.setText(<font color=#004488>""</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      <font color=#0000ff>if</font>(str.indexOf('@') == 0) {
        l.setText(
          <font color=#004488>"Name must preceed '@' in email name"</font>);
        l2.setText(<font color=#004488>""</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      String end = 
        str.substring(str.indexOf('@'));
      <font color=#0000ff>if</font>(end.indexOf('.') == -1) {
        l.setText(<font color=#004488>"Portion after '@' must "</font> +
          <font color=#004488>"have an extension, such as '.com'"</font>);
        l2.setText(<font color=#004488>""</font>);
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
      }
      <font color=#009900>// Build and encode the email data:</font>
      String emailData = 
        <font color=#004488>"name="</font> + URLEncoder.encode(
          name.getText().trim()) +
        <font color=#004488>"&amp;email="</font> + URLEncoder.encode(
          email.getText().trim().toLowerCase()) +
        <font color=#004488>"&amp;submit=Submit"</font>;
      <font color=#009900>// Send the name using CGI's GET process:</font>
      <font color=#0000ff>try</font> {
        l.setText(<font color=#004488>"Sending..."</font>);
        URL u = <font color=#0000ff>new</font> URL(
          getDocumentBase(), <font color=#004488>"cgi-bin</font><font color=#004488>/"</font> +
          CGIProgram + <font color=#004488>"?"</font> + emailData);
        l.setText(<font color=#004488>"Sent: "</font> + email.getText());
        send.setLabel(<font color=#004488>"Re-send"</font>);
        l2.setText(
          <font color=#004488>"Waiting for reply "</font> + ++vcount);
        DataInputStream server =
          <font color=#0000ff>new</font> DataInputStream(u.openStream());
        String line;
        <font color=#0000ff>while</font>((line = server.readLine()) != <font color=#0000ff>null</font>)
          l2.setText(line);
      } <font color=#0000ff>catch</font>(MalformedURLException e) {
        l.setText(<font color=#004488>"Bad URl"</font>);
      } <font color=#0000ff>catch</font>(IOException e) {
        l.setText(<font color=#004488>"IO Exception"</font>);
      } 
    }
    <font color=#0000ff>else</font> <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The name of the CGI program (which
you&#8217;ll see later) is <B>Listmgr2.exe</B>. Many Web servers are Unix
machines (mine runs Linux) that don&#8217;t traditionally use the <B>.exe</B>
extension for their executable programs, but you can call the program anything
you want under Unix. By using the <B>.exe </B>extension the program can be
tested without change under both Unix and Win32.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As before, the applet sets up its
user interface (with two fields this time instead of one). The only significant
difference occurs inside the <B>action(&#160;) </B>method, which handles the
button press. After the name has been checked, you see the
lines:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>      String emailData = 
        <font color=#004488>"name="</font> + URLEncoder.encode(
          name.getText().trim()) +
        <font color=#004488>"&amp;email="</font> + URLEncoder.encode(
          email.getText().trim().toLowerCase()) +
        <font color=#004488>"&amp;submit=Submit"</font>;
      <font color=#009900>// Send the name using CGI's GET process:</font>
      <font color=#0000ff>try</font> {
        l.setText(<font color=#004488>"Sending..."</font>);
        URL u = <font color=#0000ff>new</font> URL(
          getDocumentBase(), <font color=#004488>"cgi-bin</font><font color=#004488>/"</font> +
          CGIProgram + <font color=#004488>"?"</font> + emailData);
        l.setText(<font color=#004488>"Sent: "</font> + email.getText());
        send.setLabel(<font color=#004488>"Re-send"</font>);
        l2.setText(
          <font color=#004488>"Waiting for reply "</font> + ++vcount);
        DataInputStream server =
          <font color=#0000ff>new</font> DataInputStream(u.openStream());
        String line;
        <font color=#0000ff>while</font>((line = server.readLine()) != <font color=#0000ff>null</font>)
          l2.setText(line);
        <font color=#009900>// ...</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>name</B> and <B>email</B>
data are extracted from their respective text boxes, and the spaces are trimmed
off both ends using
<A NAME="Index2754"></A><A NAME="Index2755"></A><B>trim(&#160;)</B>. The
<B>email</B> name is forced to lower case so all email addresses in the list can
be accurately compared (to prevent accidental duplicates based on
capitalization). The data from each field is URL-encoded, and then the GET
string is assembled in the same way that an HTML page would do it. (This way you
can use a Java applet in concert with any existing CGI program designed to work
with regular HTML GET requests.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point, some Java magic
happens: if you want to connect to any URL, just create a
<A NAME="Index2756"></A><A NAME="Index2757"></A><B>URL</B> object and hand the
address to the constructor. The constructor makes the connection with the server
(and, with Web servers, all the action happens in making the connection, via the
string used as the URL). In this case, the URL points to the cgi-bin directory
of the current Web site (the base address of the current Web site is produced
with
<A NAME="Index2758"></A><A NAME="Index2759"></A><B>getDocumentBase(&#160;)</B>).
When the Web server sees &#8220;cgi-bin&#8221; in a URL, it expects that to be
followed by the name of the program inside the cgi-bin directory that you want
it to run. Following the program name is a question mark and the argument string
that the CGI program will look for in the QUERY_STRING environment variable, as
you&#8217;ll see.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Usually when you make any sort of
request, you get back (you&#8217;re forced to accept in return) an HTML page.
With Java <B>URL</B> objects, however, you can intercept anything that comes
back from the <A NAME="Index2760"></A><A NAME="Index2761"></A>CGI program by
getting an <B>InputStream</B> from the <B>URL</B> object. This is performed with
the
<A NAME="Index2762"></A><A NAME="Index2763"></A><A NAME="Index2764"></A><B>URL</B>
<B>openStream(&#160;)</B> method, which is in turn wrapped in a
<B>DataInputStream</B>. Then you can read lines, and when
<B>readLine(&#160;)</B> returns <B>null</B> the CGI program has finished its
output.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The CGI program you&#8217;re about
to see returns only one line, a string indicating success or failure (and the
details of the failure). This line is captured and placed into the second
<B>Label</B> field so the user can see the results.</FONT><BR></P></DIV>
<A NAME="Heading529"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Displaying a Web page from within an
applet<BR><A NAME="Index2765"></A><A NAME="Index2766"></A><A NAME="Index2767"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s also possible for the
applet to display the result of the CGI program as a Web page, just as if it
were running in normal HTML mode. You can do this with the following
line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>getAppletContext().showDocument(u);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><A NAME="Index2768"></A><A NAME="Index2769"></A><FONT FACE="Georgia">
in which <B>u</B> is the <B>URL</B> object. Here&#8217;s a simple example that
redirects you to another Web page. The page happens to be the output of a CGI
program, but you can as easily go to an ordinary HTML page, so you could build
on this applet to produce a password-protected gateway to a particular portion
of your Web site:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ShowHTML.java</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;
<font color=#0000ff>import</font> java.net.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ShowHTML <font color=#0000ff>extends</font> Applet {
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> String CGIProgram = <font color=#004488>"MyCGIProgram"</font>;
  Button send = <font color=#0000ff>new</font> Button(<font color=#004488>"Go"</font>);
  Label l = <font color=#0000ff>new</font> Label();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    add(send);
    add(l);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(send)) {
      <font color=#0000ff>try</font> {
        <font color=#009900>// This could be an HTML page instead of</font>
        <font color=#009900>// a CGI program. Notice that this CGI </font>
        <font color=#009900>// program doesn't use arguments, but </font>
        <font color=#009900>// you can add them in the usual way.</font>
        URL u = <font color=#0000ff>new</font> URL(
          getDocumentBase(), 
          <font color=#004488>"cgi-bin</font><font color=#004488>/"</font> + CGIProgram);
        <font color=#009900>// Display the output of the URL using</font>
        <font color=#009900>// the Web browser, as an ordinary page:</font>
        getAppletContext().showDocument(u);
      } <font color=#0000ff>catch</font>(Exception e) {
        l.setText(e.toString());
      } 
    }
    <font color=#0000ff>else</font> <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The beauty of the
<A NAME="Index2770"></A><A NAME="Index2771"></A><B>URL</B> class is how much it
shields you from. You can connect to Web servers without knowing much at all
about what&#8217;s going on under the
covers.</FONT><A NAME="_Toc408018779"></A><BR></P></DIV>
<A NAME="Heading530"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The CGI program in
C++<BR><A NAME="Index2772"></A><A NAME="Index2773"></A><A NAME="Index2774"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point you could follow the
previous example and write the CGI program for the server using ANSI C. One
argument for doing this is that ANSI C can be found virtually everywhere.
However, C++ has become quite ubiquitous, especially in the form of the
<A NAME="Index2775"></A><A NAME="Index2776"></A>GNU C++
Compiler</FONT><A NAME="fnB62" HREF="#fn62">[62]</A><FONT FACE="Georgia">
(<B>g++</B>)<B> </B>that can be downloaded free from the Internet for virtually
any platform (and often comes pre-installed with operating systems such as
Linux). As you will see, this means that you can get the benefit of
object-oriented programming in a CGI program.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To avoid throwing too many new
concepts at you all at once, this program will not be a &#8220;pure&#8221; C++
program; some code will be written in plain C even though C++ alternatives
exist. This isn&#8217;t a significant issue because the biggest benefit in using
C++ for this program is the ability to create classes. Since what we&#8217;re
concerned with when parsing the CGI information is the field name-value pairs,
one class (<B>Pair</B>)<B> </B>will be used to represent a single name-value
pair and a second class (<B>CGI_vector</B>) will automatically parse the CGI
string into <B>Pair</B> objects that it will hold (as a <B>vector</B>) so you
can fetch each <B>Pair</B> out at your leisure.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program is also interesting
because it demonstrates some of the pluses and minuses of
<A NAME="Index2777"></A><A NAME="Index2778"></A>C++ in contrast with Java.
You&#8217;ll see some similarities; for example the <B>class</B> keyword. Access
control has identical keywords <B>public</B> and <B>private</B>, but
they&#8217;re used differently: they control a block instead of a single method
or field (that is, if you say <B>private:</B> each following definition is
<B>private</B> until you say <B>public:</B>). Also, when you create a class, all
the definitions automatically default to <B>private</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the reasons for using C++
here is the convenience of the
<A NAME="Index2779"></A><A NAME="Index2780"></A><A NAME="Index2781"></A>C++
<I>Standard Template Library</I>. Among other things, the STL contains a
<B>vector</B> class. This is a C++ <B>template</B>, which means that it will be
configured at compile time so it will hold objects of only a particular type (in
this case, <B>Pair</B> objects). Unlike the Java <B>Vector</B>, which will
accept anything, the C++ <B>vector</B> template will cause a compile-time error
message if you try to put anything but a <B>Pair</B> object into the
<B>vector</B>, and when you get something out of the <B>vector</B> it will
automatically be a <B>Pair</B> object, without casting. Thus, the checking
happens at compile time and produces a more robust program. In addition, the
program can run faster since you don&#8217;t have to perform run-time casts. The
<B>vector </B>also overloads the <B>operator[] </B>so you have a convenient
syntax for extracting <B>Pair </B>objects. The <B>vector</B> template will be
used in the creation of <B>CGI_vector</B>, which you&#8217;ll see is a fairly
short definition considering how powerful it is.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">On the down side, look at the
complexity of the definition of <B>Pair</B> in the following code. <B>Pair
</B>has more method definitions than you&#8217;re used to seeing in Java code,
because the C++ programmer must know how to control copying with the
copy-constructor and assignment with the overloaded <B>operator=</B>. As
described in Chapter 12, occasionally you need to concern yourself with similar
things in Java, but in C++ you must be aware of them almost
constantly.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The project will start with a
reusable portion, which consists of <B>Pair</B> and <B>CGI_vector</B> in a C++
header file. Technically, you shouldn&#8217;t cram this much into a header file,
but for these examples it doesn&#8217;t hurt anything and it will also look more
Java-like, so it will be easier for you to read:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CGITools.h</font>
<font color=#009900>// Automatically extracts and decodes data</font>
<font color=#009900>// from CGI GETs and POSTs. Tested with GNU C++ </font>
<font color=#009900>// (available for most server machines).</font>
#include &lt;string.h&gt;
#include &lt;vector&gt; <font color=#009900>// STL vector</font>
using namespace std;

<font color=#009900>// A class to hold a single name-value pair from</font>
<font color=#009900>// a CGI query. CGI_vector holds Pair objects and</font>
<font color=#009900>// returns them from its operator[].</font>
<font color=#0000ff>class</font> Pair {
  <font color=#0000ff>char</font>* nm;
  <font color=#0000ff>char</font>* val;
<font color=#0000ff>public</font>:
  Pair() { nm = val = 0; }
  Pair(<font color=#0000ff>char</font>* name, <font color=#0000ff>char</font>* value) {
    <font color=#009900>// Creates new memory:</font>
    nm = decodeURLString(name);
    val = decodeURLString(value);
  }
  <font color=#0000ff>const</font> <font color=#0000ff>char</font>* name() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> nm; }
  <font color=#0000ff>const</font> <font color=#0000ff>char</font>* value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#009900>// Test for "emptiness"</font>
  bool empty() <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> (nm == 0) || (val == 0);
  }
  <font color=#009900>// Automatic type conversion for boolean test:</font>
  operator bool() <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> (nm != 0) &amp;&amp; (val != 0);
  }
  <font color=#009900>// The following constructors &amp; destructor are</font>
  <font color=#009900>// necessary for bookkeeping in C++.</font>
  <font color=#009900>// Copy-constructor:</font>
  Pair(<font color=#0000ff>const</font> Pair&amp; p) {
    <font color=#0000ff>if</font>(p.nm == 0 || p.val == 0) {
      nm = val = 0;
    } <font color=#0000ff>else</font> {
      <font color=#009900>// Create storage &amp; copy rhs values:</font>
      nm = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[strlen(p.nm) + 1];
      strcpy(nm, p.nm);
      val = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[strlen(p.val) + 1];
      strcpy(val, p.val);
    }
  }
  <font color=#009900>// Assignment operator:</font>
  Pair&amp; operator=(<font color=#0000ff>const</font> Pair&amp; p) {
    <font color=#009900>// Clean up old lvalues:</font>
    delete nm;
    delete val;
    <font color=#0000ff>if</font>(p.nm == 0 || p.val == 0) {
      nm = val = 0;
    } <font color=#0000ff>else</font> {
      <font color=#009900>// Create storage &amp; copy rhs values:</font>
      nm = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[strlen(p.nm) + 1];
      strcpy(nm, p.nm);
      val = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[strlen(p.val) + 1];
      strcpy(val, p.val);
    }
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  } 
  ~Pair() { <font color=#009900>// Destructor</font>
    delete nm; <font color=#009900>// 0 value OK</font>
    delete val;
  }
  <font color=#009900>// If you use this method outide this class, </font>
  <font color=#009900>// you're responsible for calling 'delete' on</font>
  <font color=#009900>// the pointer that's returned:</font>
  <font color=#0000ff>static</font> <font color=#0000ff>char</font>* 
  decodeURLString(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* URLstr) {
    <font color=#0000ff>int</font> len = strlen(URLstr);
    <font color=#0000ff>char</font>* result = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[len + 1];
    memset(result, len + 1, 0);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0, j = 0; i &lt;= len; i++, j++) {
      <font color=#0000ff>if</font>(URLstr[i] == '+')
        result[j] = ' ';
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(URLstr[i] == '%') {
        result[j] =
          translateHex(URLstr[i + 1]) * 16 +
          translateHex(URLstr[i + 2]);
        i += 2; <font color=#009900>// Move past hex code</font>
      } <font color=#0000ff>else</font> <font color=#009900>// An ordinary character</font>
        result[j] = URLstr[i];
    }
    <font color=#0000ff>return</font> result;
  }
  <font color=#009900>// Translate a single hex character; used by</font>
  <font color=#009900>// decodeURLString():</font>
  <font color=#0000ff>static</font> <font color=#0000ff>char</font> translateHex(<font color=#0000ff>char</font> hex) {
    <font color=#0000ff>if</font>(hex &gt;= 'A')
      <font color=#0000ff>return</font> (hex &amp; 0xdf) - 'A' + 10;
    <font color=#0000ff>else</font>
      <font color=#0000ff>return</font> hex - '0';
  }
};

<font color=#009900>// Parses any CGI query and turns it</font>
<font color=#009900>// into an STL vector of Pair objects:</font>
<font color=#0000ff>class</font> CGI_vector : <font color=#0000ff>public</font> vector&lt;Pair&gt; {
  <font color=#0000ff>char</font>* qry;
  <font color=#0000ff>const</font> <font color=#0000ff>char</font>* start; <font color=#009900>// Save starting position</font>
  <font color=#009900>// Prevent assignment and copy-construction:</font>
  <font color=#0000ff>void</font> operator=(CGI_vector&amp;);
  CGI_vector(CGI_vector&amp;);
<font color=#0000ff>public</font>:
  <font color=#009900>// const fields must be initialized in the C++</font>
  <font color=#009900>// "Constructor initializer list":</font>
  CGI_vector(<font color=#0000ff>char</font>* query) :
      start(<font color=#0000ff>new</font> <font color=#0000ff>char</font>[strlen(query) + 1]) {
    qry = (<font color=#0000ff>char</font>*)start; <font color=#009900>// Cast to non-const</font>
    strcpy(qry, query);
    Pair p;
    <font color=#0000ff>while</font>((p = nextPair()) != 0)
      push_back(p);
  }
  <font color=#009900>// Destructor:</font>
  ~CGI_vector() { delete start; }
<font color=#0000ff>private</font>:
  <font color=#009900>// Produces name-value pairs from the query </font>
  <font color=#009900>// string. Returns an empty Pair when there's </font>
  <font color=#009900>// no more query string left:</font>
  Pair nextPair() {
    <font color=#0000ff>char</font>* name = qry;
    <font color=#0000ff>if</font>(name == 0 || *name == '\0')
      <font color=#0000ff>return</font> Pair(); <font color=#009900>// End, return null Pair</font>
    <font color=#0000ff>char</font>* value = strchr(name, '=');
    <font color=#0000ff>if</font>(value == 0)
      <font color=#0000ff>return</font> Pair(); <font color=#009900>// Error, return null Pair</font>
    <font color=#009900>// Null-terminate name, move value to start</font>
    <font color=#009900>// of its set of characters:</font>
    *value = '\0';
    value++;
    <font color=#009900>// Look for end of value, marked by '&amp;':</font>
    qry = strchr(value, '&amp;');
    <font color=#0000ff>if</font>(qry == 0) qry = <font color=#004488>""</font>; <font color=#009900>// Last pair found</font>
    <font color=#0000ff>else</font> {
      *qry = '\0'; <font color=#009900>// Terminate value string</font>
      qry++; <font color=#009900>// Move to next pair</font>
    }
    <font color=#0000ff>return</font> Pair(name, value);
  }
}; <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After the <B>#include</B>
statements, you see a line that says:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>using namespace std;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Namespaces in C++ solve one of the
problems taken care of by the <B>package</B> scheme in Java: hiding library
names. The <B>std</B> namespace refers to the Standard C++ library, and
<B>vector</B> is in this library so the line is required.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Pair</B> class starts out
looking pretty simple: it just holds two (<B>private</B>)<B> </B>character
pointers, one for the name and one for the value. The default constructor simply
sets these pointers to zero, since in C++ an object&#8217;s memory isn&#8217;t
automatically zeroed. The second constructor calls the method
<B>decodeURLString(&#160;)</B> that produces a decoded string in newly-allocated
heap memory. This memory must be managed and destroyed by the object, as you
will see in the destructor. The <B>name(&#160;)</B> and <B>value(&#160;)</B>
methods produce read-only pointers to the respective fields. The
<B>empty(&#160;)</B> method is a way for you to ask the <B>Pair</B> object
whether either of its fields are empty; it returns a <B>bool,</B> which is
C++&#8217;s built-in primitive Boolean data type. The <B>operator
bool(&#160;)</B> uses a special case of
<A NAME="Index2782"></A><A NAME="Index2783"></A>C++ <I>operator overloading</I>,
which allows you to control automatic type conversion. If you have a <B>Pair</B>
object called <B>p</B> and you use it in an expression in which a Boolean result
is expected, such as <B>if(p) { //...</B>, then the compiler will recognize that
it has a <B>Pair</B> and it needs a Boolean, so it will automatically call
<B>operator bool(&#160;)</B> to perform the necessary
conversion.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next three methods are part of
the bookkeeping that&#8217;s necessary when you create a class in C++. In the
so-called &#8220;canonical form&#8221; for a C++ class, you must define the
necessary &#8220;ordinary&#8221; constructors as well as a copy-constructor and
the assignment operator, <B>operator= </B>(and the destructor, to clean up the
memory). You must define these because they can be quietly called by the
compiler when you pass objects in and out of a function (this calls the
copy-constructor) or when you assign objects (the assignment operator). Once
you&#8217;ve gone through the trouble to understand how the copy-constructor and
assignment operator work you can write robust classes in C++, but it is a bit of
a learning experience.</FONT><A NAME="fnB63" HREF="#fn63">[63]</A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index2784"></A><A NAME="Index2785"></A>copy-constructor <B>Pair(const
Pair&amp;)</B> is automatically called whenever you pass an object into or out
of a function <I>by value</I>. That is, you aren&#8217;t passing the address of
the object you&#8217;re making a copy of the whole object inside the function
frame. This isn&#8217;t an option in Java since you pass only handles, thus
there&#8217;s no copy-constructor in Java. (If you want to make a local
duplicate, you <B>clone(&#160;)</B> the object &#8211; see Chapter 12.)
Likewise, if you assign a handle in Java, it&#8217;s simply copied. But
assignment in C++ means that the entire object is copied. In the
copy-constructor, you create new storage and copy the source data, but with the
assignment operator you must release the old storage before allocating new
storage. What you&#8217;re seeing is probably the worst-case complexity scenario
for a C++ class, but it&#8217;s one of the reasons Java proponents can argue
that Java is a lot simpler than C++. In Java you pass handles and there&#8217;s
a garbage collector, so you don&#8217;t have to do this kind of
thing.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This isn&#8217;t quite the whole
story. The <B>Pair</B> class is using <B>char*</B> for <B>nm</B> and <B>val</B>,
and the worst-case complexity occurs primarily around pointers. If you use the
more modern Standard C++ <B>string</B> class instead of <B>char*</B>, things get
much simpler (however, not all compilers have caught up enough to come with
<B>string</B>). Then, the first part of <B>Pair</B> looks like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Pair {
  string nm;
  string val;
<font color=#0000ff>public</font>:
  Pair() { }
  Pair(<font color=#0000ff>char</font>* name, <font color=#0000ff>char</font>* value) {
    nm = decodeURLString(name);
    val = decodeURLString(value);
  }
  <font color=#0000ff>const</font> <font color=#0000ff>char</font>* name() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> nm.c_str(); }
  <font color=#0000ff>const</font> <font color=#0000ff>char</font>* value() <font color=#0000ff>const</font> { 
    <font color=#0000ff>return</font> val.c_str(); 
  }
  <font color=#009900>// Test for "emptiness"</font>
  bool empty() <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> (nm.length() == 0) 
      || (val.length() == 0);
  }
  <font color=#009900>// Automatic type conversion for boolean test:</font>
  operator bool() <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> (nm.length() != 0) 
      &amp;&amp; (val.length() != 0);
  }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(Also, for this case
<B>decodeURLString(&#160;)</B> returns a <B>string</B> instead of a
<B>char*</B>.) You don&#8217;t need to define a copy-constructor,
<B>operator=,</B> or destructor because the compiler does that for you, and does
it correctly. But even if it sometimes works automatically, C++ programmers must
still know the details of copy-construction and assignment.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The remainder of the <B>Pair</B>
class consists of the two methods <B>decodeURLString(&#160;)</B> and a helper
method <B>translateHex(&#160;)</B>, which is used by
<B>decodeURLString(&#160;)</B>. (Note that <B>translateHex(&#160;)</B> does not
guard against bad user input such as &#8220;%1H.&#8221;) After allocating
adequate storage (which must be released by the destructor),
<B>decodeURLString(&#160;)</B> moves through and replaces each
&#8216;<B>+</B>&#8217; with a space and each hex code (beginning with a
&#8216;<B>%</B>&#8217;) with the appropriate character.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CGI_vector</B> parses and holds
an entire CGI GET command. It is inherited from the STL <B>vector,</B> which is
instantiated to hold <B>Pair</B>s. Inheritance in C++ is denoted by using a
colon at the point you&#8217;d say <B>extends</B> in Java. In addition,
inheritance defaults to <B>private</B> so you&#8217;ll almost always need to use
the <B>public</B> keyword as was done here. You can also see that
<B>CGI_vector</B> has a copy-constructor and an <B>operator=</B>, but
they&#8217;re both declared as <B>private</B>. This is to prevent the compiler
from synthesizing the two functions (which it will do if you don&#8217;t declare
them yourself), but it also prevents the client programmer from passing a
<B>CGI_vector</B> by value or from using assignment.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CGI_vector</B>&#8217;s job is to
take the QUERY_STRING and parse it into name-value pairs, which it will do with
the aid of <B>Pair</B>. First it copies the string into locally-allocated memory
and keeps track of the starting address with the constant pointer <B>start.
</B>(This is later used in the destructor to release the memory.)<B> </B>Then it
uses its method <B>nextPair(&#160;)</B> to parse the string into raw name-value
pairs, delimited by &#8216;<B>=</B>&#8217; and<B> </B>&#8216;<B>&amp;</B>&#8217;
signs. These are handed by <B>nextPair(&#160;)</B> to the <B>Pair</B>
constructor so <B>nextPair(&#160;)</B> can return the <B>Pair</B> object, which
is then added to the <B>vector</B> with <B>push_back(&#160;)</B>. When
<B>nextPair(&#160;)</B> runs out of QUERY_STRING, it returns
zero.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now that the basic tools are
defined, they can easily be used in a CGI program, like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Listmgr2.cpp</font>
<font color=#009900>// CGI version of Listmgr.c in C++, which </font>
<font color=#009900>// extracts its input via the GET submission </font>
<font color=#009900>// from the associated applet. Also works as</font>
<font color=#009900>// an ordinary CGI program with HTML forms.</font>
#include &lt;stdio.h&gt;
#include <font color=#004488>"CGITools.h"</font>
<font color=#0000ff>const</font> <font color=#0000ff>char</font>* dataFile = <font color=#004488>"list2.txt"</font>;
<font color=#0000ff>const</font> <font color=#0000ff>char</font>* notify = <font color=#004488>"Bruce@EckelObjects.com"</font>;
#undef DEBUG

<font color=#009900>// Similar code as before, except that it looks</font>
<font color=#009900>// for the email name inside of '&lt;&gt;':</font>
<font color=#0000ff>int</font> inList(FILE* list, <font color=#0000ff>const</font> <font color=#0000ff>char</font>* emailName) {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> BSIZE = 255;
  <font color=#0000ff>char</font> lbuf[BSIZE];
  <font color=#0000ff>char</font> emname[BSIZE];
  <font color=#009900>// Put the email name in '&lt;&gt;' so there's no</font>
  <font color=#009900>// possibility of a match within another name:</font>
  sprintf(emname, <font color=#004488>"&lt;%s&gt;"</font>, emailName);
  <font color=#009900>// Go to the beginning of the list:</font>
  fseek(list, 0, SEEK_SET);
  <font color=#009900>// Read each line in the list:</font>
  <font color=#0000ff>while</font>(fgets(lbuf, BSIZE, list)) {
    <font color=#009900>// Strip off the newline: </font>
    <font color=#0000ff>char</font> * newline = strchr(lbuf, '\n');
    <font color=#0000ff>if</font>(newline != 0) 
      *newline = '\0';
    <font color=#0000ff>if</font>(strstr(lbuf, emname) != 0)
      <font color=#0000ff>return</font> 1;
  }
  <font color=#0000ff>return</font> 0;
}

<font color=#0000ff>void</font> main() {
  <font color=#009900>// You MUST print this out, otherwise the </font>
  <font color=#009900>// server will not send the response:</font>
  printf(<font color=#004488>"Content-type: text</font><font color=#004488>/plain\n\n"</font>);
  FILE* list = fopen(dataFile, <font color=#004488>"a+t"</font>);
  <font color=#0000ff>if</font>(list == 0) {
    printf(<font color=#004488>"error: could not open database. "</font>);
    printf(<font color=#004488>"Notify %s"</font>, notify);
    <font color=#0000ff>return</font>;
  }
  <font color=#009900>// For a CGI "GET," the server puts the data</font>
  <font color=#009900>// in the environment variable QUERY_STRING:</font>
  CGI_vector query(getenv(<font color=#004488>"QUERY_STRING"</font>));
  #<font color=#0000ff>if</font> defined(DEBUG)
  <font color=#009900>// Test: dump all names and values</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; query.size(); i++) {
    printf(<font color=#004488>"query[%d].name() = [%s], "</font>, 
      i, query[i].name());
    printf(<font color=#004488>"query[%d].value() = [%s]\n"</font>, 
      i, query[i].value());
  }
  #endif(DEBUG)
  Pair name = query[0];
  Pair email = query[1];
  <font color=#0000ff>if</font>(name.empty() || email.empty()) {
    printf(<font color=#004488>"error: null name or email"</font>);
    <font color=#0000ff>return</font>;
  } 
  <font color=#0000ff>if</font>(inList(list, email.value())) {
    printf(<font color=#004488>"Already in list: %s"</font>, email.value());
    <font color=#0000ff>return</font>;
  }
  <font color=#009900>// It's not in the list, add it:</font>
  fseek(list, 0, SEEK_END);
  fprintf(list, <font color=#004488>"%s &lt;%s&gt;;\n"</font>, 
    name.value(), email.value());
  fflush(list);
  fclose(list);
  printf(<font color=#004488>"%s &lt;%s&gt; added to list\n"</font>, 
    name.value(), email.value());
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>alreadyInList(&#160;)</B>
function is almost identical to the previous version, except that it assumes all
email names are inside &#8216;<B>&lt;&gt;</B>&#8217;. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you use the
<A NAME="Index2786"></A><A NAME="Index2787"></A><A NAME="Index2788"></A>GET
approach (which is normally done in the HTML METHOD tag of the FORM directive,
but which is controlled here by the way the data is sent), the Web server grabs
everything after the &#8216;?&#8217; and puts in into the environment variable
<A NAME="Index2789"></A><A NAME="Index2790"></A>QUERY_STRING. So to read that
information you have to get the value of QUERY_STRING, which you do using the
standard C library function <B>getenv(&#160;)</B>. In <B>main(&#160;)</B>,<B>
</B>notice how simple the act of parsing the QUERY_STRING is: you just hand it
to the constructor for the <B>CGI_vector</B> object called <B>query </B>and all
the work is done for you. From then on you can pull out the names and values
from <B>query</B> as if it were an array. (This is because the <B>operator[]</B>
is overloaded in <B>vector.</B>) You can see how this works in the debug code,
which is surrounded by the preprocessor directives <B>#if defined(DEBUG)</B> and
<B>#endif(DEBUG)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now it&#8217;s important to
understand something about CGI. A CGI program is handed its input in one of two
ways: through QUERY_STRING during a GET (as in this case) or through standard
input during a POST. But a CGI program sends its output through standard output,
typically using <B>printf(&#160;) </B>in a C program. Where does this output go?
Back to the Web server, which decides what to do with it. The server makes this
decision based on the <B>content-type</B> header, which means that if the
<A NAME="Index2791"></A><A NAME="Index2792"></A><A NAME="Index2793"></A><B>content-type</B>
header isn&#8217;t the first thing it sees, it won&#8217;t know what to do with
the data. Thus, it&#8217;s essential that you start the output of all CGI
programs with the <B>content-type</B> header.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this case, we want the server to
feed all the information directly back to the client program (which is our
applet, waiting for its reply). The information should be unchanged, so the
<B>content-type</B> is <B>text/plain</B>. Once the server sees this, it will
echo all strings right back to the client. So each of the strings you see, three
for error conditions and one for a successful add, will end up back at the
applet.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Adding the email name uses the same
code. In the case of the CGI script, however, there isn&#8217;t an infinite loop
&#8211; the program just responds and then terminates. Each time a CGI request
comes in, the program is started in response to that request, and then it shuts
down. Thus there is no possibility of CPU hogging, and the only performance
issue concerns starting the program up and opening the file, which are dwarfed
by the overhead of the Web server as it handles the CGI
request.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the advantages of this
design is that, now that <B>Pair</B> and <B>CGI_vector</B> are defined, most of
the work is done for you so you can easily create your own CGI program simply by
modifying <B>main(&#160;)</B>. Eventually, servlet servers will probably be
ubiquitous, but in the meantime C++ is still handy for creating fast CGI
programs.</FONT><A NAME="_Toc408018780"></A><BR></P></DIV>
<A NAME="Heading531"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
What about
POST?<BR><A NAME="Index2794"></A><A NAME="Index2795"></A><A NAME="Index2796"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Using a GET is fine for many
applications. However, GET passes its data to the CGI program through an
environment variable, and some Web servers can run out of environment space with
long GET strings (you should start worrying at about 200 characters). CGI
provides a solution for this: POST. With POST, the data is encoded and
concatenated the same way as a GET, but POST uses standard input to pass the
encoded query string to the CGI program. All you have to do is determine the
length of the query string, and this length is stored in the environment
variable CONTENT_LENGTH. Once you know the length, you can allocate storage and
read the precise number of bytes from standard input.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Pair</B> and
<B>CGI_vector</B> from <B>CGITools.h</B> can be used as is for a CGI program
that handles POSTs. The following listing shows how simple it is to write such a
CGI program. In this example, &#8220;pure&#8221; C++ will be used so the
<B>stdio.h</B> library will be dropped in favor of <B>iostream</B>s. With
<B>iostream</B>s, two predefined objects are available: <B>cin,</B> which
connects to standard input, and <B>cout,</B> which connects to standard output.
There are several ways to read from <B>cin</B> and write to <B>cout</B>, but the
following program take the common approach of using
&#8216;<B>&lt;&lt;</B>&#8217; to send information to <B>cout</B>, and the use of
a member function (in this case, <B>read(&#160;)</B>) to read from
<B>cin</B>.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: POSTtest.cpp</font>
<font color=#009900>// CGI_vector works as easily with POST as it</font>
<font color=#009900>// does with GET. Written in "pure" C++.</font>
#include &lt;iostream.h&gt;
#include <font color=#004488>"CGITools.h"</font>

<font color=#0000ff>void</font> main() {
  cout &lt;&lt; <font color=#004488>"Content-type: text</font><font color=#004488>/plain\n"</font> &lt;&lt; endl;
  <font color=#009900>// For a CGI "POST," the server puts the length</font>
  <font color=#009900>// of the content string in the environment </font>
  <font color=#009900>// variable CONTENT_LENGTH:</font>
  <font color=#0000ff>char</font>* clen = getenv(<font color=#004488>"CONTENT_LENGTH"</font>);
  <font color=#0000ff>if</font>(clen == 0) {
    cout &lt;&lt; <font color=#004488>"Zero CONTENT_LENGTH"</font> &lt;&lt; endl;
    <font color=#0000ff>return</font>;
  }
  <font color=#0000ff>int</font> len = atoi(clen);
  <font color=#0000ff>char</font>* query_str = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[len + 1];
  cin.read(query_str, len);
  query_str[len] = '\0';
  CGI_vector query(query_str);
  <font color=#009900>// Test: dump all names and values</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; query.size(); i++)
    cout &lt;&lt; <font color=#004488>"query["</font> &lt;&lt; i &lt;&lt; <font color=#004488>"].name() = ["</font> &lt;&lt;
      query[i].name() &lt;&lt; <font color=#004488>"], "</font> &lt;&lt;
      <font color=#004488>"query["</font> &lt;&lt; i &lt;&lt; <font color=#004488>"].value() = ["</font> &lt;&lt;
      query[i].value() &lt;&lt; <font color=#004488>"]"</font> &lt;&lt; endl;
  delete query_str; <font color=#009900>// Release storage</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>getenv(&#160;)</B> function
returns a pointer to a character string representing the content length. If this
pointer is zero, the CONTENT_LENGTH environment variable has not been set, so
something is wrong. Otherwise, the character string must be converted to an
integer using the ANSI C library function <B>atoi(&#160;)</B>. The length is
used with <B>new </B>to allocate enough storage to hold the query string (plus
its null terminator), and then <B>read(&#160;)</B> is called for <B>cin</B>. The
<B>read(&#160;)</B> function takes a pointer to the destination buffer and the
number of bytes to read. The <B>query_str</B> is then null-terminated to
indicate the end of the character string.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point, the query string is
no different from a GET query string, so it is handed to the constructor for
<B>CGI_vector</B>. The different fields in the vector are then available just as
in the previous example.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To test this program, you must
compile it in the cgi-bin directory of your host Web server. Then you can
perform a simple test by writing an HTML page like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META CONTENT=<font color=#004488>"text</font><font color=#004488>/html"</font>&gt;
&lt;TITLE&gt;A test of standard HTML POST&lt;/TITLE&gt;
&lt;/HEAD&gt;
Test, uses standard html POST
&lt;Form method=<font color=#004488>"POST"</font> ACTION=<font color=#004488>"</font><font color=#004488>/cgi-bin</font><font color=#004488>/POSTtest"</font>&gt;
&lt;P&gt;Field1: &lt;INPUT TYPE = <font color=#004488>"text"</font> NAME = <font color=#004488>"Field1"</font> 
VALUE = <font color=#004488>""</font> size = <font color=#004488>"40"</font>&gt;&lt;/p&gt;
&lt;P&gt;Field2: &lt;INPUT TYPE = <font color=#004488>"text"</font> NAME = <font color=#004488>"Field2"</font> 
VALUE = <font color=#004488>""</font> size = <font color=#004488>"40"</font>&gt;&lt;/p&gt;
&lt;P&gt;Field3: &lt;INPUT TYPE = <font color=#004488>"text"</font> NAME = <font color=#004488>"Field3"</font> 
VALUE = <font color=#004488>""</font> size = <font color=#004488>"40"</font>&gt;&lt;/p&gt;
&lt;P&gt;Field4: &lt;INPUT TYPE = <font color=#004488>"text"</font> NAME = <font color=#004488>"Field4"</font> 
VALUE = <font color=#004488>""</font> size = <font color=#004488>"40"</font>&gt;&lt;/p&gt;
&lt;P&gt;Field5: &lt;INPUT TYPE = <font color=#004488>"text"</font> NAME = <font color=#004488>"Field5"</font> 
VALUE = <font color=#004488>""</font> size = <font color=#004488>"40"</font>&gt;&lt;/p&gt;
&lt;P&gt;Field6: &lt;INPUT TYPE = <font color=#004488>"text"</font> NAME = <font color=#004488>"Field6"</font> 
VALUE = <font color=#004488>""</font> size = <font color=#004488>"40"</font>&gt;&lt;/p&gt;
&lt;p&gt;&lt;input type = <font color=#004488>"submit"</font> name = <font color=#004488>"submit"</font> &gt; &lt;/p&gt;
&lt;/Form&gt;
&lt;/HTML&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you fill this out and submit
it, you&#8217;ll get back a simple text page containing the parsed results, so
you can see that the CGI program works correctly.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, it&#8217;s a little more
interesting to submit the data using an applet. Submitting
<A NAME="Index2797"></A><A NAME="Index2798"></A><A NAME="Index2799"></A>POST
data is a different process, however. After you invoke the CGI program in the
usual way, you must make a direct connection to the server so you can feed it
the query string. The server then turns around and feeds the query string to the
CGI program via standard input.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make a direct connection to the
server, you must take the URL you&#8217;ve created and call
<A NAME="Index2800"></A><A NAME="Index2801"></A><B>openConnection(&#160;)</B> to
produce a <A NAME="Index2802"></A><A NAME="Index2803"></A><B>URLConnection</B>.
Then, because a <B>URLConnection</B> doesn&#8217;t usually allow you to send
data to it, you must call the magic function
<A NAME="Index2804"></A><A NAME="Index2805"></A><B>setDoOutput(true)</B> along
with <A NAME="Index2806"></A><A NAME="Index2807"></A><B>setDoInput(true)
</B>and<B>
<A NAME="Index2808"></A><A NAME="Index2809"></A>setAllowUserInteraction(false)</B>.</FONT><A NAME="fnB64" HREF="#fn64">[64]</A><FONT FACE="Georgia">
Finally, you can call
<A NAME="Index2810"></A><A NAME="Index2811"></A><B>getOutputStream(&#160;)</B>
to produce an <B>OutputStream</B>, which you wrap inside a
<B>DataOutputStream</B> so you can talk to it conveniently. Here&#8217;s an
applet that does just that, after collecting data from its various
fields:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: POSTtest.java</font>
<font color=#009900>// An applet that sends its data via a CGI POST</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;
<font color=#0000ff>import</font> java.net.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> POSTtest <font color=#0000ff>extends</font> Applet {
  <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> SIZE = 10;
  Button submit = <font color=#0000ff>new</font> Button(<font color=#004488>"Submit"</font>);
  TextField[] t = <font color=#0000ff>new</font> TextField[SIZE];
  String query = <font color=#004488>""</font>;
  Label l = <font color=#0000ff>new</font> Label();
  TextArea ta = <font color=#0000ff>new</font> TextArea(15, 60);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    Panel p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> GridLayout(t.length + 2, 2));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; t.length; i++) {
      p.add(<font color=#0000ff>new</font> Label(
        <font color=#004488>"Field "</font> + i + <font color=#004488>"  "</font>, Label.RIGHT));
      p.add(t[i] = <font color=#0000ff>new</font> TextField(30));
    }
    p.add(l);
    p.add(submit);
    add(<font color=#004488>"North"</font>, p);
    add(<font color=#004488>"South"</font>, ta);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(submit)) {
      query = <font color=#004488>""</font>;
      ta.setText(<font color=#004488>""</font>);
      <font color=#009900>// Encode the query from the field data:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; t.length; i++)
         query += <font color=#004488>"Field"</font> + i + <font color=#004488>"="</font> +
           URLEncoder.encode(
             t[i].getText().trim()) +
           <font color=#004488>"&amp;"</font>;
      query += <font color=#004488>"submit=Submit"</font>;
      <font color=#009900>// Send the name using CGI's POST process:</font>
      <font color=#0000ff>try</font> {
        URL u = <font color=#0000ff>new</font> URL(
          getDocumentBase(), <font color=#004488>"cgi-bin</font><font color=#004488>/POSTtest"</font>);
        URLConnection urlc = u.openConnection();
        urlc.setDoOutput(<font color=#0000ff>true</font>);
        urlc.setDoInput(<font color=#0000ff>true</font>);
        urlc.setAllowUserInteraction(<font color=#0000ff>false</font>);
        DataOutputStream server = 
          <font color=#0000ff>new</font> DataOutputStream(
            urlc.getOutputStream());
        <font color=#009900>// Send the data</font>
        server.writeBytes(query);
        server.close();
        <font color=#009900>// Read and display the response. You</font>
        <font color=#009900>// cannot use </font>
        <font color=#009900>// getAppletContext().showDocument(u);</font>
        <font color=#009900>// to display the results as a Web page!</font>
        DataInputStream in = 
          <font color=#0000ff>new</font> DataInputStream(
            urlc.getInputStream());
        String s;
        <font color=#0000ff>while</font>((s = in.readLine()) != <font color=#0000ff>null</font>) {
          ta.appendText(s + <font color=#004488>"\n"</font>);
        }
        in.close();
      }
      <font color=#0000ff>catch</font> (Exception e) {
        l.setText(e.toString());
      }
    }
    <font color=#0000ff>else</font> <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the information is sent to the
server, you can call
<A NAME="Index2812"></A><A NAME="Index2813"></A><B>getInputStream(&#160;)</B>
and wrap the return value in a <B>DataInputStream</B> so that you can read the
results. One thing you&#8217;ll notice is that the results are displayed as
lines of text in a <B>TextArea</B>. Why not simply use
<A NAME="Index2814"></A><A NAME="Index2815"></A><B>getAppletContext().showDocument(u)</B>?
Well, this is one of those mysteries. The code above works fine, but if you try
to use <B>showDocument(&#160;) </B>instead, everything stops working &#8211;
almost. That is, <B>showDocument(&#160;)</B> <I>does</I> work, but what you get
back from <B>POSTtest</B> is &#8220;Zero CONTENT_LENGTH.&#8221; So somehow,
<B>showDocument(&#160;)</B> prevents the POST query from being passed on to the
CGI program. It&#8217;s difficult to know whether this is a bug that will be
fixed, or some lack of understanding on my part (the books I looked at were
equally abstruse). In any event, if you can stand to limit yourself to looking
at the text that comes back from the CGI program, the above applet works
fine.</FONT><A NAME="_Toc408018781"></A><BR></P></DIV>
<A NAME="Heading532"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Connecting to databases <BR>with JDBC</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It has been estimated that half of
all software development involves client/server operations. A great promise of
Java has been the ability to build platform-independent client/server database
applications. In Java 1.1<A NAME="Index2816"></A> this has come to fruition with
<A NAME="Index2817"></A><A NAME="Index2818"></A><A NAME="Index2819"></A>Java
DataBase Connectivity (JDBC).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the major problems with
databases has been the feature wars between the database companies. There is a
&#8220;standard&#8221; database language,
<A NAME="Index2820"></A><A NAME="Index2821"></A>Structured Query Language
(SQL-92), but usually you must know which database vendor you&#8217;re working
with despite the standard. JDBC is designed to be platform-independent, so you
don&#8217;t need to worry about the database you&#8217;re using while
you&#8217;re programming. However, it&#8217;s still possible to make
vendor-specific calls from JDBC so you aren&#8217;t restricted from doing what
you must.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">JDBC, like many of the APIs in
Java, is designed for simplicity. The method calls you make correspond to the
logical operations you&#8217;d think of doing when gathering data from a
database: connect to the database, create a statement and execute the query, and
look at the result set.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To allow this platform
independence, JDBC provides a <I>driver manager</I> that dynamically maintains
all the driver objects that your database queries will need. So if you have
three different kinds of vendor databases to connect to, you&#8217;ll need three
different driver objects. The driver objects register themselves with the driver
manager at the time of loading, and you can force the loading using
<B>Class.forName(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To open a database, you must create
a &#8220;<A NAME="Index2822"></A><A NAME="Index2823"></A>database URL&#8221;
that specifies:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	That you&#8217;re using JDBC with
&#8220;jdbc&#8221;</FONT><LI><FONT FACE="Georgia">	The
&#8220;subprotocol&#8221;: the name of the driver or the name of a database
connectivity mechanism. Since the design of JDBC was inspired by
<A NAME="Index2824"></A>ODBC, the first subprotocol available is the
&#8220;jdbc-odbc bridge,&#8221; specified by
&#8220;odbc&#8221;</FONT><LI><FONT FACE="Georgia">	The database
identifier. This varies with the database driver used, but it generally provides
a logical name that is mapped by the database administration software to a
physical directory where the database tables are located. For your database
identifier to have any meaning, you must register the name using your database
administration software. (The process of registration varies from platform to
platform.)</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All this
information is combined into one string, the &#8220;database URL.&#8221; For
example, to connect through the ODBC subprotocol to a database identified as
&#8220;people,&#8221; the database URL could be:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>String dbUrl = <font color=#004488>"jdbc:odbc:people"</font>;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re connecting across a
network, the database URL will also contain the information identifying the
remote machine.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you&#8217;re ready to connect
to the database, you call the <B>static</B> method
<B>DriverManager.getConnection(&#160;)</B>, passing it the database URL, the
user name, and a password to get into the database. You get back a
<B>Connection</B> object that you can then use to query and manipulate the
database.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example opens a
database of contact information and looks for a person&#8217;s last name as
given on the command line. It selects only the names of people that have email
addresses, then prints out all the ones that match the given last
name:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Lookup.java</font>
<font color=#009900>// Looks up email addresses in a </font>
<font color=#009900>// local database using JDBC</font>
<font color=#0000ff>import</font> java.sql.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Lookup {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String dbUrl = <font color=#004488>"jdbc:odbc:people"</font>;
    String user = <font color=#004488>""</font>;
    String password = <font color=#004488>""</font>;
    <font color=#0000ff>try</font> {
      <font color=#009900>// Load the driver (registers itself)</font>
      Class.forName(
        <font color=#004488>"sun.jdbc.odbc.JdbcOdbcDriver"</font>);
      Connection c = DriverManager.getConnection(
        dbUrl, user, password);
      Statement s = c.createStatement();
      <font color=#009900>// SQL code:</font>
      ResultSet r = 
        s.executeQuery(
          <font color=#004488>"SELECT FIRST, LAST, EMAIL "</font> +
          <font color=#004488>"FROM people.csv people "</font> +
          <font color=#004488>"WHERE "</font> +
          <font color=#004488>"(LAST='"</font> + args[0] + <font color=#004488>"') "</font> +
          <font color=#004488>" AND (EMAIL Is Not Null) "</font> +
          <font color=#004488>"ORDER BY FIRST"</font>);
      <font color=#0000ff>while</font>(r.next()) {
        <font color=#009900>// Capitalization doesn't matter:</font>
        System.out.println(
          r.getString(<font color=#004488>"Last"</font>) + <font color=#004488>", "</font> 
          + r.getString(<font color=#004488>"fIRST"</font>)
          + <font color=#004488>": "</font> + r.getString(<font color=#004488>"EMAIL"</font>) );
      }
      s.close(); <font color=#009900>// Also closes ResultSet</font>
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see the creation of the
database URL as previously described. In this example, there is no password
protection on the database so the user name and password are empty
strings.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the connection is made with
<B>DriverManager.getConnection(&#160;)</B>, you can use the resulting
<B>Connection</B> object to<B> </B>create a <B>Statement</B> object using the
<A NAME="Index2825"></A><A NAME="Index2826"></A><B>createStatement(&#160;)</B>
method. With the resulting
<A NAME="Index2827"></A><A NAME="Index2828"></A><B>Statement</B>, you can call
<A NAME="Index2829"></A><A NAME="Index2830"></A><B>executeQuery(&#160;)</B>,
passing in a string containing an SQL-92 standard SQL statement. (You&#8217;ll
see shortly how you can generate this statement automatically, so you
don&#8217;t have to know much about SQL.) </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>executeQuery(&#160;)
</B>method returns a
<A NAME="Index2831"></A><A NAME="Index2832"></A><B>ResultSet</B> object, which
is quite a bit like an iterator: the <B>next(&#160;)</B> method moves the
iterator to the next record in the statement, or returns <B>false</B> if the end
of the result set has been reached. You&#8217;ll always get a <B>ResultSet</B>
object back from <B>executeQuery(&#160;)</B> even if a query results in an empty
set (that is, an exception is not thrown). Note that you must call
<B>next(&#160;)</B> once before trying to read any record data. If the result
set is empty, this first call to <B>next(&#160;)</B> will return <B>false</B>.
For each record in the result set, you can select the fields using (among other
approaches) the field name as a string. Also note that the capitalization of the
field name is ignored &#8211; it doesn&#8217;t matter with an SQL database. You
determine the type you&#8217;ll get back by calling
<A NAME="Index2833"></A><A NAME="Index2834"></A><B>getInt(&#160;)</B>,
<A NAME="Index2835"></A><A NAME="Index2836"></A><B>getString(&#160;)</B>,
<A NAME="Index2837"></A><A NAME="Index2838"></A><B>getFloat(&#160;)</B>, etc. At
this point, you&#8217;ve got your database data in Java native format and can do
whatever you want with it using ordinary Java
code.</FONT><A NAME="_Toc408018782"></A><BR></P></DIV>
<A NAME="Heading533"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Getting the example to work</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With JDBC, understanding the code
is relatively simple. The confusing part is making it work on your particular
system. The reason this is confusing is that it requires you to figure out how
to get your JDBC driver to load properly, and how to set up a database using
your database administration software.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, this process can vary
radically from machine to machine, but the process I used to make it work under
32-bit Windows might give you clues to help you attack your own
situation.</FONT><BR></P></DIV>
<A NAME="Heading534"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Step 1: Find the JDBC Driver</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The program above contains the
statement:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Class.forName(<font color=#004488>"sun.jdbc.odbc.JdbcOdbcDriver"</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This implies a directory structure,
which is deceiving. With this particular installation of JDK 1.1, there was no
file called <B>JdbcOdbcDriver.class</B>, so if you looked at this example and
went searching for it you&#8217;d be frustrated. Other published examples use a
pseudo name, such as &#8220;myDriver.ClassName,&#8221; which is less than
helpful. In fact, the load statement above for the jdbc-odbc driver (the only
one that actually comes with JDK 1.1) appears in only a few places in the online
documentation (in particular, a page labeled &#8220;JDBC-ODBC Bridge
Driver&#8221;). If the load statement above doesn&#8217;t work, then the name
might have been changed as part of a Java version change, so you should hunt
through the documentation again.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the load statement is wrong,
you&#8217;ll get an exception at this point. To test whether your driver load
statement is working correctly, comment out the code after the statement and up
to the <B>catch</B> clause; if the program throws no exceptions it means that
the driver is loading properly.</FONT><BR></P></DIV>
<A NAME="Heading535"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Step 2: Configure the database</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Again, this is specific to 32-bit
Windows; you might need to do some research to figure it out for your own
platform.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, open the control panel. You
might find two icons that say &#8220;ODBC.&#8221; You must use the one that says
&#8220;32bit ODBC,&#8221; since the other one is for backwards compatibility
with 16-bit ODBC software and will produce no results for JDBC. When you open
the &#8220;32bit ODBC&#8221; icon, you&#8217;ll see a tabbed dialog with a
number of tabs, including &#8220;User DSN,&#8221; &#8220;System DSN,&#8221;
&#8220;File DSN,&#8221; etc., in which &#8220;DSN&#8221; means &#8220;Data
Source Name.&#8221; It turns out that for the JDBC-ODBC bridge, the only place
where it&#8217;s important to set up your database is &#8220;System DSN,&#8221;
but you&#8217;ll also want to test your configuration and create queries, and
for that you&#8217;ll also need to set up your database in &#8220;File
DSN.&#8221; This will allow the Microsoft Query tool (that comes with Microsoft
Office) to find the database. Note that other query tools are also available
from other vendors.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most interesting database is
one that you&#8217;re already using. Standard ODBC supports a number of
different file formats including such venerable workhorses as DBase. However, it
also includes the simple &#8220;comma-separated ASCII&#8221; format, which
virtually every data tool has the ability to write. In my case, I just took my
&#8220;people&#8221; database that I&#8217;ve been maintaining for years using
various contact-management tools and exported it as a comma-separated ASCII file
(these typically have an extension of <B>.csv</B>). In the &#8220;File
DSN&#8221; section I chose &#8220;Add,&#8221; chose the text driver to handle my
comma-separated ASCII file, and then un-checked &#8220;use current
directory&#8221; to allow me to specify the directory where I exported the data
file.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice when you do
this that you don&#8217;t actually specify a file, only a directory.
That&#8217;s because a database is typically represented as a collection of
files under a single directory (although it could be represented in other forms
as well). Each file usually contains a single table, and the SQL statements can
produce results that are culled from multiple tables in the database (this is
called a <A NAME="Index2839"></A><A NAME="Index2840"></A><I>join</I>). A
database that contains only a single table (like this one) is usually called a
<A NAME="Index2841"></A><A NAME="Index2842"></A><A NAME="Index2843"></A><I>flat-file
database</I>. Most problems that go beyond the simple storage and retrieval of
data generally require multiple tables that must be related by joins to produce
the desired results, and these are called
<A NAME="Index2844"></A><A NAME="Index2845"></A><A NAME="Index2846"></A><I>relational</I>
databases.</FONT><BR></P></DIV>
<A NAME="Heading536"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Step 3: Test the configuration</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To test the configuration
you&#8217;ll need a way to discover whether the database is visible from a
program that queries it. Of course, you can simply run the JDBC program example
above up to and including the statement:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Connection c = DriverManager.getConnection(
  dbUrl, user, password);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If an exception is thrown, your
configuration was incorrect.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, it&#8217;s useful to get a
query-generation tool involved at this point. I used Microsoft Query that came
with Microsoft Office, but you might prefer something else. The query tool must
know where the database is, and Microsoft Query required that I go to the ODBC
Administrator&#8217;s &#8220;File DSN&#8221; tab and add a new entry there,
again specifying the text driver and the directory where my database lives. You
can name the entry anything you want, but it&#8217;s helpful to use the same
name you used in &#8220;System DSN.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you&#8217;ve done this, you
will see that your database is available when you create a new query using your
query tool.</FONT><BR></P></DIV>
<A NAME="Heading537"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Step 4: Generate your SQL query</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The query that I created using
Microsoft Query not only showed me that my database was there and in good order,
but it also automatically created the SQL code that I needed to insert into my
Java program. I wanted a query that would search for records that had the last
name that was typed on the command line when starting the Java program. So as a
starting point, I searched for a specific last name, &#8216;Eckel&#8217;. I also
wanted to display only those names that had email addresses associated with
them. The steps I took to create this query were:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	Start a new query and use the Query Wizard.
Select the &#8220;people&#8221; database. (This is the equivalent of opening the
database connection using the appropriate database
URL.)</FONT><LI><FONT FACE="Georgia">	Select the &#8220;people&#8221;
table within the database. From within the table, choose the columns FIRST,
LAST, and EMAIL.</FONT><LI><FONT FACE="Georgia">	Under &#8220;Filter
Data,&#8221; choose LAST and select &#8220;equals&#8221; with an argument of
Eckel. Click the &#8220;And&#8221; radio
button.</FONT><LI><FONT FACE="Georgia">	Choose EMAIL and select &#8220;Is
not Null.&#8221;</FONT><LI><FONT FACE="Georgia">	Under &#8220;Sort
By,&#8221; choose
FIRST.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The result of
this query will show you whether you&#8217;re getting what you
want.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now you can press the SQL button
and without any research on your part, up will pop the correct SQL code, ready
for you to cut and paste. For this query, it looked like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>SELECT people.FIRST, people.LAST, people.EMAIL
FROM people.csv people
WHERE (people.LAST='Eckel') AND 
(people.EMAIL Is Not Null)
ORDER BY people.FIRST</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With more complicated queries
it&#8217;s easy to get things wrong, but with a query tool you can interactively
test your queries and automatically generate the correct code. It&#8217;s hard
to argue the case for doing this by hand.</FONT><BR></P></DIV>
<A NAME="Heading538"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Step 5: Modify and paste in your query</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that the code
above looks different from what&#8217;s used in the program. That&#8217;s
because the query tool uses full qualification for all of the names, even when
there&#8217;s only one table involved. (When more than one table is involved,
the qualification prevents collisions between columns from different tables that
have the same names.) Since this query involves only one table, you can
optionally remove the &#8220;people&#8221; qualifier from most of the names,
like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>SELECT FIRST, LAST, EMAIL
FROM people.csv people
WHERE (LAST='Eckel') AND 
(EMAIL Is Not Null)
ORDER BY FIRST</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, you don&#8217;t want
this program to be hard coded to look for only one name. Instead, it should hunt
for the name given as the command-line argument. Making these changes and
turning the SQL statement into a dynamically-created <B>String</B>
produces:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#004488>"SELECT FIRST, LAST, EMAIL "</font> +
<font color=#004488>"FROM people.csv people "</font> +
<font color=#004488>"WHERE "</font> +
<font color=#004488>"(LAST='"</font> + args[0] + <font color=#004488>"') "</font> +
<font color=#004488>" AND (EMAIL Is Not Null) "</font> +
<font color=#004488>"ORDER BY FIRST"</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">SQL has another way to insert names
into a query called
<A NAME="Index2847"></A><A NAME="Index2848"></A><A NAME="Index2849"></A><I>stored
procedures</I>, which is used for speed. But for much of your database
experimentation and for your first cut, building your own query strings in Java
is fine.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see from this example that
by using the tools currently available &#8211; in particular the query-building
tool &#8211; database programming with SQL and JDBC can be quite
straightforward.</FONT><A NAME="_Toc408018783"></A><BR></P></DIV>
<A NAME="Heading539"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A GUI version of the lookup program</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s more useful to leave the
lookup program running all the time and simply switch to it and type in a name
whenever you want to look someone up. The following program creates the lookup
program as an application/applet, and it also adds name completion so the data
will show up without forcing you to type the entire last name:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: VLookup.java</font>
<font color=#009900>// GUI version of Lookup.java</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.applet.*;
<font color=#0000ff>import</font> java.sql.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> VLookup <font color=#0000ff>extends</font> Applet {
  String dbUrl = <font color=#004488>"jdbc:odbc:people"</font>;
  String user = <font color=#004488>""</font>;
  String password = <font color=#004488>""</font>;
  Statement s;
  TextField searchFor = <font color=#0000ff>new</font> TextField(20);
  Label completion = 
    <font color=#0000ff>new</font> Label(<font color=#004488>"                        "</font>);
  TextArea results = <font color=#0000ff>new</font> TextArea(40, 20);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    searchFor.addTextListener(<font color=#0000ff>new</font> SearchForL());
    Panel p = <font color=#0000ff>new</font> Panel();
    p.add(<font color=#0000ff>new</font> Label(<font color=#004488>"Last name to search for:"</font>));
    p.add(searchFor);
    p.add(completion);
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    add(p, BorderLayout.NORTH);
    add(results, BorderLayout.CENTER);
    <font color=#0000ff>try</font> {
      <font color=#009900>// Load the driver (registers itself)</font>
      Class.forName(
        <font color=#004488>"sun.jdbc.odbc.JdbcOdbcDriver"</font>);
      Connection c = DriverManager.getConnection(
        dbUrl, user, password);
      s = c.createStatement();
    } <font color=#0000ff>catch</font>(Exception e) {
      results.setText(e.getMessage());
    }
  }
  <font color=#0000ff>class</font> SearchForL <font color=#0000ff>implements</font> TextListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> textValueChanged(TextEvent te) {
      ResultSet r;
      <font color=#0000ff>if</font>(searchFor.getText().length() == 0) {
        completion.setText(<font color=#004488>""</font>);
        results.setText(<font color=#004488>""</font>);
        <font color=#0000ff>return</font>;
      }
      <font color=#0000ff>try</font> {
        <font color=#009900>// Name completion:</font>
        r = s.executeQuery(
          <font color=#004488>"SELECT LAST FROM people.csv people "</font> +
          <font color=#004488>"WHERE (LAST Like '"</font> +
          searchFor.getText()  + 
          <font color=#004488>"%') ORDER BY LAST"</font>);
        <font color=#0000ff>if</font>(r.next()) 
          completion.setText(
            r.getString(<font color=#004488>"last"</font>));
        r = s.executeQuery(
          <font color=#004488>"SELECT FIRST, LAST, EMAIL "</font> +
          <font color=#004488>"FROM people.csv people "</font> +
          <font color=#004488>"WHERE (LAST='"</font> + 
          completion.getText() +
          <font color=#004488>"') AND (EMAIL Is Not Null) "</font> +
          <font color=#004488>"ORDER BY FIRST"</font>);
      } <font color=#0000ff>catch</font>(Exception e) {
        results.setText(
          searchFor.getText() + <font color=#004488>"\n"</font>);
        results.append(e.getMessage());
        <font color=#0000ff>return</font>; 
      }
      results.setText(<font color=#004488>""</font>);
      <font color=#0000ff>try</font> {
        <font color=#0000ff>while</font>(r.next()) {
          results.append(
            r.getString(<font color=#004488>"Last"</font>) + <font color=#004488>", "</font> 
            + r.getString(<font color=#004488>"fIRST"</font>) + 
            <font color=#004488>": "</font> + r.getString(<font color=#004488>"EMAIL"</font>) + <font color=#004488>"\n"</font>);
        }
      } <font color=#0000ff>catch</font>(Exception e) {
        results.setText(e.getMessage());
      }
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    VLookup applet = <font color=#0000ff>new</font> VLookup();
    Frame aFrame = <font color=#0000ff>new</font> Frame(<font color=#004488>"Email lookup"</font>);
    aFrame.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(500,200);
    applet.init();
    applet.start();
    aFrame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Much of the database logic is the
same, but you can see that a <B>TextListener</B> is added to listen to the
<B>TextField</B>, so that whenever you type a new character it first tries to do
a name completion by looking up the last name in the database and using the
first one that shows up. (It places it in the <B>completion</B> <B>Label</B>,
and uses that as the lookup text.) This way, as soon as you&#8217;ve typed
enough characters for the program to uniquely find the name you&#8217;re looking
for, you can stop.</FONT><A NAME="_Toc408018784"></A><BR></P></DIV>
<A NAME="Heading540"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Why the JDBC API <BR>seems so complex</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you browse the online
documentation for JDBC it can seem daunting. In particular, in the
<A NAME="Index2850"></A><A NAME="Index2851"></A><B>DatabaseMetaData</B>
interface &#8211; which is just huge, contrary to most of the interfaces you see
in Java &#8211; there are methods such as
<B>dataDefinitionCausesTransactionCommit(&#160;)</B>,
<B>getMaxColumnNameLength(&#160;)</B>, <B>getMaxStatementLength(&#160;)</B>,
<B>storesMixedCaseQuotedIdentifiers(&#160;)</B>,
<B>supportsANSI92IntermediateSQL(&#160;)</B>,
<B>supportsLimitedOuterJoins(&#160;)</B>, and so on. What&#8217;s this all
about?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As mentioned earlier, databases
have seemed from their inception to be in a constant state of turmoil, primarily
because the demand for database applications, and thus database tools, is so
great. Only recently has there been any convergence on the common language of
SQL (and there are plenty of other database languages in common use). But even
with an SQL &#8220;standard&#8221; there are so many variations on that theme
that JDBC must provide the large <B>DatabaseMetaData</B> interface so that your
code can discover the capabilities of the particular &#8220;standard&#8221; SQL
database that it&#8217;s currently connected to. In short, you can write simple,
transportable SQL, but if you want to optimize speed your coding will multiply
tremendously as you investigate the capabilities of a particular vendor&#8217;s
database.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This, of course, is not
Java&#8217;s fault. The discrepancies between database products are just
something that JDBC tries to help compensate for. But bear in mind that your
life will be easier if you can either write generic queries and not worry too
much about performance, or, if you must tune for performance, know the platform
you&#8217;re writing for so you don&#8217;t need to write all that investigation
code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is more JDBC information
available in the electronic documents that come as part of the Java
1.1<A NAME="Index2852"></A> distribution from Sun. In addition, you can find
more in the book <I>JDBC Database Access with Java </I>(Hamilton, Cattel, and
Fisher, Addison-Wesley 1997). Other JDBC books are appearing
regularly.</FONT><A NAME="_Toc408018785"></A><BR></P></DIV>
<A NAME="Heading541"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Remote methods</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Traditional approaches to executing
code on other machines across a network have been confusing as well as tedious
and error-prone to implement. The nicest way to think about this problem is that
some object happens to live on another machine, and you can send a message to
that object and get a result as if the object lived on your local machine. This
simplification is exactly what Java 1.1<A NAME="Index2853"></A>
<A NAME="Index2854"></A><A NAME="Index2855"></A><I>Remote Method Invocation</I>
(RMI) allows you to do. This section walks you through the steps necessary to
create your own RMI objects.</FONT><A NAME="_Toc408018786"></A><BR></P></DIV>
<A NAME="Heading542"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Remote interfaces</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">RMI makes heavy use of interfaces.
When you want to create a remote object, you mask the underlying implementation
by passing around an interface. Thus, when the client gets a handle to a remote
object, what they really get is an interface handle, which <I>happens</I> to
connect to some local stub code that talks across the network. But you
don&#8217;t think about this, you just send messages via your interface
handle.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you create a
<A NAME="Index2856"></A>remote interface, you must follow these guidelines:
<A NAME="Index2857"></A><A NAME="Index2858"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	The remote interface must be <B>public</B> (it
cannot have &#8220;package access,&#8221; that is, it cannot be
&#8220;friendly&#8221;). Otherwise, a client will get an error when attempting
to load a remote object that implements the remote interface.
</FONT><LI><FONT FACE="Georgia">	The remote interface must extend the
interface <B>java.rmi.Remote</B>. </FONT><LI><FONT FACE="Georgia">	Each
method in the remote interface must declare <B>java.rmi.RemoteException</B> in
its <B>throws</B> clause in addition to any application-specific exceptions.
</FONT><LI><FONT FACE="Georgia">	A remote object passed as an argument or
return value (either directly or embedded within a local object) must be
declared as the remote interface, not the implementation
class.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a
simple remote interface that represents an accurate time
service:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PerfectTimeI.java</font>
<font color=#009900>// The PerfectTime remote interface</font>
<font color=#0000ff>package</font> c15.ptime;
<font color=#0000ff>import</font> java.rmi.*;

<font color=#0000ff>interface</font> PerfectTimeI <font color=#0000ff>extends</font> Remote {
  <font color=#0000ff>long</font> getPerfectTime() <font color=#0000ff>throws</font> RemoteException;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It looks like any other interface
except that it extends <B>Remote</B> and all of its methods throw
<B>RemoteException</B>. Remember that an <B>interface</B> and all of its methods
are automatically <B>public</B>.</FONT><A NAME="_Toc408018787"></A><BR></P></DIV>
<A NAME="Heading543"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Implementing the remote interface</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The server must contain a class
that extends
<A NAME="Index2859"></A><A NAME="Index2860"></A><B>UnicastRemoteObject</B> and
implements the remote interface. This class can also have additional methods,
but only the methods in the remote interface will be available to the client, of
course, since the client will get only a handle to the interface, not the class
that implements it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You must explicitly define the
constructor for the remote object even if you&#8217;re only defining a default
constructor that calls the base-class constructor. You must write it out since
it must throw <B>RemoteException</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the implementation of
the remote interface <B>PerfectTimeI</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PerfectTime.java</font>
<font color=#009900>// The implementation of the PerfectTime </font>
<font color=#009900>// remote object</font>
<font color=#0000ff>package</font> c15.ptime;
<font color=#0000ff>import</font> java.rmi.*;
<font color=#0000ff>import</font> java.rmi.server.*;
<font color=#0000ff>import</font> java.rmi.registry.*;
<font color=#0000ff>import</font> java.net.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PerfectTime 
    <font color=#0000ff>extends</font> UnicastRemoteObject
    <font color=#0000ff>implements</font> PerfectTimeI {
  <font color=#009900>// Implementation of the interface:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>long</font> getPerfectTime() 
      <font color=#0000ff>throws</font> RemoteException {
    <font color=#0000ff>return</font> System.currentTimeMillis();
  }
  <font color=#009900>// Must implement constructor to throw</font>
  <font color=#009900>// RemoteException:</font>
  <font color=#0000ff>public</font> PerfectTime() <font color=#0000ff>throws</font> RemoteException {
    <font color=#009900>// super(); // Called automatically</font>
  }
  <font color=#009900>// Registration for RMI serving:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.setSecurityManager(
      <font color=#0000ff>new</font> RMISecurityManager());
    <font color=#0000ff>try</font> {
      PerfectTime pt = <font color=#0000ff>new</font> PerfectTime();
      Naming.bind(
        <font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/colossus:2005</font><font color=#004488>/PerfectTime"</font>, pt);
      System.out.println(<font color=#004488>"Ready to do time"</font>);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, <B>main(&#160;)</B> handles
all the details of setting up the server. When you&#8217;re serving RMI objects,
at some point in your program you must:
<A NAME="Index2861"></A><A NAME="Index2862"></A><A NAME="Index2863"></A><A NAME="Index2864"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	Create and install a security manager that
supports RMI. The only one available for RMI as part of the Java distribution is
<B>RMISecurityManager</B>.</FONT><LI><FONT FACE="Georgia">	Create one or
more instances of a remote object. Here, you can see the creation of the
<B>PerfectTime</B> object.</FONT><LI><FONT FACE="Georgia">	Register at
least one of the remote objects with the RMI remote object registry for
bootstrapping purposes. One remote object can have methods that produce handles
to other remote objects. This allows you to set it up so the client must go to
the registry only once, to get the first remote
object.</FONT></OL><A NAME="Heading544"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Setting up the registry</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, you see a call to the
<B>static</B> method
<A NAME="Index2865"></A><A NAME="Index2866"></A><A NAME="Index2867"></A><B>Naming.bind(&#160;)</B>.
However, this call requires that the registry be running as a separate process
on the computer. The name of the registry server is
<A NAME="Index2868"></A><A NAME="Index2869"></A><B>rmiregistry</B>, and under
32-bit Windows you say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>start rmiregistry</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">to start it in the background. On
Unix, it is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>rmiregistry &amp;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like many network programs, the
<B>rmiregistry</B> is located at the IP address of whatever machine started it
up, but it must also be listening at a port. If you invoke the
<B>rmiregistry</B> as above, with no argument, the registry&#8217;s port will
default to 1099. If you want it to be at some other port, you add an argument on
the command line to specify the port. For this example, the port will be located
at 2005, so the <B>rmiregistry</B> should be started like this under 32-bit
Windows:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>start rmiregistry 2005</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">or for Unix:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>rmiregistry 2005 &amp;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The information about the port must
also be given to the <B>bind(&#160;)</B> command, as well as the IP address of
the machine where the registry is located. But this brings up what can be a
frustrating problem if you&#8217;re expecting to test RMI programs locally the
way the network programs have been tested so far in this chapter. In the JDK
1.1.1 release, there are a couple of
problems:</FONT><A NAME="fnB65" HREF="#fn65">[65]</A><FONT FACE="Georgia">
<A NAME="Index2870"></A><A NAME="Index2871"></A><A NAME="Index2872"></A><A NAME="Index2873"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia"><B>	localhost </B>does not work with RMI. Thus,
to experiment with RMI on a single machine, you must provide the name of the
machine. To find out the name of your machine under 32-bit Windows, go to the
control panel and select &#8220;Network.&#8221; Select the
&#8220;Identification&#8221; tab, and you&#8217;ll see your computer name. In my
case, I called my computer &#8220;Colossus&#8221; (for all the hard disks
I&#8217;ve had to put on to hold all the different development systems). It
appears that capitalization is
ignored.</FONT><LI><FONT FACE="Georgia">	RMI will not work unless your
computer has an active TCP/IP connection, even if all your components are just
talking to each other on the local machine. This means that you must connect to
your Internet service provider before trying to run the program or you&#8217;ll
get some obscure exception
messages.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Will all this
in mind, the <B>bind(&#160;)</B> command becomes:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Naming.bind(<font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/colossus:2005</font><font color=#004488>/PerfectTime"</font>, pt);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you are using the default port
1099, you don&#8217;t need to specify a port, so you could say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Naming.bind(<font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/colossus</font><font color=#004488>/PerfectTime"</font>, pt);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In a future release of the JDK
(after 1.1) when the <B>localhost</B> bug is fixed, you will be able to perform
local testing by leaving off the IP address and using only the
identifier:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Naming.bind(<font color=#004488>"PerfectTime"</font>, pt);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The name for the service is
arbitrary; it happens to be PerfectTime here, just like the name of the class,
but you could call it anything you want. The important thing is that it&#8217;s
a unique name in the registry that the client knows to look for to procure the
remote object. If the name is already in the registry, you&#8217;ll get an
<A NAME="Index2874"></A><A NAME="Index2875"></A><B>AlreadyBoundException</B>. To
prevent this, you can always use
<A NAME="Index2876"></A><A NAME="Index2877"></A><A NAME="Index2878"></A><B>rebind(&#160;)</B>
instead of <B>bind(&#160;)</B>, since <B>rebind(&#160;)</B> either adds a new
entry or replaces the one that&#8217;s already there.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Even though <B>main(&#160;)</B>
exits, your object has been created and registered so it&#8217;s kept alive by
the registry, waiting for a client to come along and request it. As long as the
<B>rmiregistry</B> is running and you don&#8217;t call
<B>Naming.unbind(&#160;)</B>
<A NAME="Index2879"></A><A NAME="Index2880"></A><A NAME="Index2881"></A>on your
name, the object will be there. For this reason, when you&#8217;re developing
your code you need to shut down the <B>rmiregistry</B> and restart it when you
compile a new version of your remote object.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You aren&#8217;t forced to start up
<B>rmiregistry</B> as an external process. If you know that your application is
the only one that&#8217;s going to use the registry, you can start it up inside
your program with the line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>LocateRegistry.createRegistry(2005);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like before, 2005 is the port
number we happen to be using in this example. This is the equivalent of running
<B>rmiregistry 2005</B> from a command line, but it can often be more convenient
when you&#8217;re developing RMI code since it eliminates the extra steps of
starting and stopping the registry. Once you&#8217;ve executed this code, you
can <B>bind(&#160;)</B> using <B>Naming</B> as
before.</FONT><A NAME="_Toc408018788"></A><BR></P></DIV>
<A NAME="Heading545"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Creating stubs and skeletons</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you compile and run
<B>PerfectTime.java</B>, it won&#8217;t work even if you have the
<B>rmiregistry</B> running correctly. That&#8217;s because the framework for RMI
isn&#8217;t all there yet. You must first create the
<A NAME="Index2882"></A><A NAME="Index2883"></A>stubs and
<A NAME="Index2884"></A><A NAME="Index2885"></A>skeletons that provide the
network connection operations and allow you to pretend that the remote object is
just another local object on your machine.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What&#8217;s going on behind the
scenes is complex. Any objects that you pass into or return from a remote object
must <B>implement
<A NAME="Index2886"></A><A NAME="Index2887"></A>Serializable</B> (if you want to
pass remote references instead of the entire objects, the object arguments can
<B>implement Remote</B>), so you can imagine that the stubs and skeletons are
automatically performing serialization and deserialization as they
&#8220;marshal&#8221; all of the arguments across the network and return the
result. Fortunately, you don&#8217;t have to know any of this, but you <I>do</I>
have to create the stubs and skeletons. This is a simple process: you invoke the
<A NAME="Index2888"></A><A NAME="Index2889"></A><B>rmic</B> tool on your
compiled code, and it creates the necessary files. So the only requirement is
that another step be added to your compilation process.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>rmic</B> tool is particular
about packages and <A NAME="Index2890"></A><A NAME="Index2891"></A>classpaths,
however. <B>PerfectTime.java</B> is in the package <B>c15.Ptime</B>, and even if
you invoke <B>rmic</B> in the same directory in which <B>PerfectTime.class</B>
is located, <B>rmic</B> won&#8217;t find the file, since it searches the
classpath. So you must specify the location off the class path, like
so:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>rmic c15.PTime.PerfectTime</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You don&#8217;t have to be in the
directory containing <B>PerfectTime.class</B> when you execute this command, but
the results will be placed in the current directory.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When <B>rmic</B> runs successfully,
you&#8217;ll have two new classes in the directory:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>PerfectTime_Stub.<font color=#0000ff>class</font>
PerfectTime_Skel.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">corresponding to the stub and
skeleton. Now you&#8217;re ready to get the server and client to talk to each
other.</FONT><A NAME="_Toc408018789"></A><BR></P></DIV>
<A NAME="Heading546"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using the remote object</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The whole point of RMI is to make
the use of remote objects simple. The only extra thing that you must do in your
client program is to look up and fetch the remote interface from the server.
From then on, it&#8217;s just regular Java programming: sending messages to
objects. Here&#8217;s the program that uses <B>PerfectTime</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: DisplayPerfectTime.java</font>
<font color=#009900>// Uses remote object PerfectTime</font>
<font color=#0000ff>package</font> c15.ptime;
<font color=#0000ff>import</font> java.rmi.*;
<font color=#0000ff>import</font> java.rmi.registry.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DisplayPerfectTime {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.setSecurityManager(
      <font color=#0000ff>new</font> RMISecurityManager());
    <font color=#0000ff>try</font> {
      PerfectTimeI t = 
        (PerfectTimeI)Naming.lookup(
          <font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/colossus:2005</font><font color=#004488>/PerfectTime"</font>);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        System.out.println(<font color=#004488>"Perfect time = "</font> +
          t.getPerfectTime());
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The ID string is the same as the
one used to register the object with <B>Naming</B>, and the first part
represents the URL and port number. Since you&#8217;re using a URL, you can also
specify a machine on the Internet.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What comes back from
<B>Naming.lookup(&#160;)</B> must be cast to the remote interface, <I>not</I> to
the class. If you use the class instead, you&#8217;ll get an
exception.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see in the method
call</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>t.getPerfectTime(&#160;)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">that once you have a handle to the
remote object, programming with it is indistinguishable from programming with a
local object (with one difference: remote methods throw
<A NAME="Index2892"></A><A NAME="Index2893"></A><B>RemoteException</B>).</FONT><A NAME="_Toc408018790"></A><BR></P></DIV>
<A NAME="Heading547"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Alternatives to RMI</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">RMI is just one way to create
objects that can be distributed across a network. It has the advantage of being
a &#8220;pure Java&#8221; solution, but if you have a lot of code written in
some other language, it might not meet your needs. The two most compelling
alternatives are Microsoft&#8217;s <A NAME="Index2894"></A>DCOM (which,
according to Microsoft&#8217;s plan, will eventually be hosted on platforms
other than Windows) and <A NAME="Index2895"></A><A NAME="Index2896"></A>CORBA,
which is supported in Java 1.1<A NAME="Index2897"></A> and was designed from the
start to be cross-platform. You can get an introduction to distributed objects
in Java (albeit with a clear bias towards CORBA) in <I>Client/Server Programming
with Java and CORBA</I> by Orfali &amp; Harkey (John Wiley &amp; Sons, 1997). A
more serious treatment of CORBA is given by <I>Java Programming with CORBA</I>
by<I> </I>Andreas Vogel</FONT><BR><FONT FACE="Georgia">and Keith Duddy
(John Wiley &amp; Sons,
1997).</FONT><A NAME="_Toc375545499"></A><A NAME="_Toc408018791"></A><BR></P></DIV>
<A NAME="Heading548"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s actually a lot more
to networking than can be covered in this introductory treatment. Java
networking also provides fairly extensive support for URLs, including protocol
handlers for different types of content that can be discovered at an Internet
site.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, an up-and-coming
technology is the <A NAME="Index2898"></A><A NAME="Index2899"></A><I>Servlet
Server</I>, which is an Internet server that uses Java to handle requests
instead of the slow and rather awkward CGI (Common Gateway Interface) protocol.
This means that to provide services on the server side you&#8217;ll be able to
write in Java instead of using some other language that you might not know as
well. You&#8217;ll also get the portability benefits of Java so you won&#8217;t
have to worry about the particular platform the server is hosted
on.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These and other features are fully
and carefully described in <I>Java Network Programming</I> by Elliotte Rusty
Harold (O&#8217;Reilly,
1997).</FONT><A NAME="_Toc375545500"></A><A NAME="_Toc408018792"></A><BR></P></DIV>
<A NAME="Heading549"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Compile
and run the <B>JabberServer</B> and <B>JabberClient</B> programs in this
chapter. Now edit the files to remove all of the buffering for the input and
output, then compile and run them again to observe the
results.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
a server that asks for a password, then opens a file and sends the file over the
network connection. Create a client that connects to this server, gives the
appropriate password, then captures and saves the file. Test the pair of
programs on your machine using the <B>localhost</B> (the local loopback IP
address <B>127.0.0.1</B> produced by calling
<B>InetAddress.getByName(null)</B>).</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Modify
the server in Exercise 2 so that it uses multithreading to handle multiple
clients.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Modify
<B>JabberClient</B> so that output flushing doesn&#8217;t occur and observe the
effect.
</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Build
on <B>ShowHTML.java</B> to produce an applet that is a password-protected
gateway to a particular portion of your Web
site.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">(More
challenging) Create a client/server pair of programs that use datagrams to
transmit a file from one machine to the other. (See the description at the end
of the datagram section of this
chapter.)</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">(More
challenging) Take the <B>VLookup.java</B> program and modify it so that when you
click on the resulting name it automatically takes that name and copies it to
the clipboard (so you can simply paste it into your email). You&#8217;ll need to
look back at the IO stream chapter to remember how to use the Java 1.1
clipboard.</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn59" HREF="#fnB59">[59]</A><FONT FACE="Georgia" SIZE=2>
This means a maximum of just over four billion numbers, which is rapidly running
out. The new standard for IP addresses will use a 128-bit number, which should
produce enough unique IP addresses for the foreseeable future.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn60" HREF="#fnB60">[60]</A><FONT FACE="Georgia" SIZE=2>
TCP and UDP ports are considered unique. That is, you can simultaneously run a
TCP and UDP server on port 8080 without interference.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn61" HREF="#fnB61">[61]</A><FONT FACE="Georgia" SIZE=2>
You can test this under Windows32 using the Microsoft Personal Web Server that
comes with Microsoft Office 97 and some of their other products. This is a nice
way to experiment since you can perform local tests (and it's also fast). If
you're on a different platform or if you don't have Office 97, you might be able
to find a freeware Web server for testing by searching the
Internet.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn62" HREF="#fnB62">[62]</A><FONT FACE="Georgia" SIZE=2>
GNU stands for &#8220;Gnu&#8217;s Not Unix.&#8221; The project, created by the
Free Software Foundation, was originally intended to replace the Unix operating
system with a free version of that OS. Linux appears to have replaced this
initiative, but the GNU tools have played an integral part in the development of
Linux, which comes packaged with many GNU components.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn63" HREF="#fnB63">[63]</A><FONT FACE="Georgia" SIZE=2>
My book <I>Thinking in C++</I> (Prentice-Hall, 1995) devotes an entire chapter
to this subject. Refer to this if you need further information on the
subject.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn64" HREF="#fnB64">[64]</A><FONT FACE="Georgia" SIZE=2>
I can&#8217;t say I really understand what&#8217;s going on here, but I managed
to get it working by studying <I>Java Network Programming</I> by Elliotte Rusty
Harold (O&#8217;Reilly 1997). He alludes to a number of confusing bugs in the
Java networking libraries, so this is an area in which you can&#8217;t just
write code and have it work right away. Be warned.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn65" HREF="#fnB65">[65]</A><FONT FACE="Georgia" SIZE=2>
Many brain cells died in agony to discover this information.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter14.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter16.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/04/2000</P></DIV>

</BODY>

</HTML>
