<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:Tjava14.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/04/2000
Translation Time:23:25:15
Translation Platform:Win32
Number of Output files:27
This File:Chapter10.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>10: The Java  IO system</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/TIJ2/index.html">2nd Edition</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/javaCD2.html">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 1st edition</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;1998 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter09.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter11.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_10"></A><A NAME="_Toc375545381"></A><A NAME="_Toc407441454"></A><A NAME="_Toc408018609"></A><A NAME="Heading302"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
10: The Java <BR>IO system<A NAME="AAA"></A></H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>Creating a good
input/output (IO) system is one of the more difficult tasks for the language
designer.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is evidenced by the number of
different approaches. The challenge seems to be in covering all eventualities.
Not only are there different kinds of IO that you want to communicate with
(files, the console, network connections), but you need to talk to them in a
wide variety of ways (sequential, random-access, binary, character, by lines, by
words, etc.).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java library designers attacked
the problem by creating lots of classes. In fact, there are so many classes for
Java&#8217;s IO system that it can be intimidating at first (ironically, the
Java IO design actually prevents an explosion of classes). There has also been a
significant change in the IO <A NAME="Index980"></A>library between Java
1.0<A NAME="Index981"></A> and Java 1.1<A NAME="Index982"></A>. Instead of
simply replacing the old library with a new one, the designers at Sun extended
the old library and added the new one alongside it. As a result you can
sometimes end up mixing the old and new libraries and creating even more
intimidating code. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter will help you
understand the variety of IO classes in the standard Java library and how to use
them. The first portion of the chapter will introduce the &#8220;old&#8221; Java
1.0<A NAME="Index983"></A> IO stream library, since there is a significant
amount of existing code that uses that library. The remainder of the chapter
will introduce the new features in the Java 1.1 IO library. Note that when you
compile some of the code in the first part of the chapter with a Java 1.1
compiler you can get a &#8220;<A NAME="Index984"></A>deprecated feature&#8221;
warning message at compile time. The code still works; the compiler is just
suggesting that you use certain new features that are described in the latter
part of this chapter. It is valuable, however, to see the difference between the
old and new way of doing things and that&#8217;s why it was left in &#8211; to
increase your understanding (and to allow you to read code written for Java
1.0<A NAME="Index985"></A>).</FONT><A NAME="_Toc375545382"></A><A NAME="_Toc408018610"></A><BR></P></DIV>
<A NAME="Heading303"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Input and output</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java library classes for IO are
divided by <A NAME="Index986"></A>input and <A NAME="Index987"></A>output, as
you can see by looking at the online Java class hierarchy with your Web browser.
By inheritance, all classes derived from
<A NAME="Index988"></A><A NAME="Index989"></A><B>InputStream</B> have basic
methods called <A NAME="Index990"></A><A NAME="Index991"></A><B>read(&#160;)
</B>for reading a single byte or array of bytes. Likewise, all classes derived
from <A NAME="Index992"></A><A NAME="Index993"></A><B>OutputStream </B>have
basic methods called
<A NAME="Index994"></A><A NAME="Index995"></A><B>write(&#160;) </B>for writing a
single byte or array of bytes. However, you won&#8217;t generally use these
methods; they exist so more sophisticated classes can use them as they provide a
more useful interface. Thus, you&#8217;ll rarely create your stream object by
using a single class, but instead will layer multiple objects together to
provide your desired functionality. The fact that you create more than one
object to create a single resulting stream is the primary reason that
Java&#8217;s stream library is confusing.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s helpful to categorize
the classes by their functionality. The library designers started by deciding
that all classes that had anything to do with input would be inherited from
<B>InputStream</B> and all classes that were associated with output would be
inherited from <B>OutputStream</B>.
</FONT><A NAME="_Toc375545383"></A><A NAME="_Toc408018611"></A><BR></P></DIV>
<A NAME="Heading304"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Types of InputStream</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B>&#8217;s job is
to represent classes that produce input from different sources. These sources
can be (and each has an associated subclass of <B>InputStream</B>):
<A NAME="Index996"></A><A NAME="Index997"></A> </FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	An array of
bytes</FONT><LI><FONT FACE="Georgia">	A <B>String</B>
object</FONT><LI><FONT FACE="Georgia">	A
file</FONT><LI><FONT FACE="Georgia">	A &#8220;pipe,&#8221; which works
like a physical pipe: you put things in one end and they come out the
other</FONT><LI><FONT FACE="Georgia">	A sequence of other streams, so you
can collect them together into a single
stream</FONT><LI><FONT FACE="Georgia">	Other sources, such as an Internet
connection. (This will be discussed in a later
chapter.)</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition,
the <B>FilterInputStream</B> is also a type of <B>InputStream</B>, to provide a
base class for "decorator" classes that attach attributes or useful interfaces
to input streams. This is discussed later.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Table 10-1. Types of
InputStream<A NAME="Index998"></A><A NAME="Index999"></A><A NAME="Index1000"></A><A NAME="Index1001"></A><A NAME="Index1002"></A><A NAME="Index1003"></A><A NAME="Index1004"></A><A NAME="Index1005"></A><A NAME="Index1006"></A><A NAME="Index1007"></A><A NAME="Index1008"></A><A NAME="Index1009"></A><A NAME="Index1010"></A><A NAME="Index1011"></A><A NAME="Index1012"></A><A NAME="Index1013"></A><A NAME="Index1014"></A><A NAME="Index1015"></A><A NAME="Index1016"></A><A NAME="Index1017"></A></B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=76 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Class</FONT><BR></P></DIV>
</TH>
<TH WIDTH=90 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Function</FONT><BR></P></DIV>
</TH>
<TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructor
Arguments</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How to use it</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArray-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Allows a buffer in memory to be
used as an <B>InputStream</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The buffer from which to extract
the bytes.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to
a <B>FilterInputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringBuffer-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Converts a <B>String</B> into an
<B>InputStream</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>String</B>. The underlying
implementation actually uses a <B>StringBuffer</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to
a <B>FilterInputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>File-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For reading information from a
file.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>String</B> representing the
file name, or a <B>File</B> or <B>FileDescriptor</B> object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to
a <B>FilterInputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>

<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Piped-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces the data that&#8217;s
being written to the associated <B>PipedOutput-Stream</B>. Implements the
&#8220;piping&#8221; concept.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedOutputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data in
multithreading. Connect it to a <B>FilterInputStream</B> object to provide a
useful interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Sequence-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Coverts two or more
<B>InputStream</B> objects into a single <B>InputStream</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Two <B>InputStream</B> objects or
an <B>Enumeration</B> for a container of <B>InputStream</B>
objects.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to
a <B>FilterInputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Filter-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Abstract class which is an
interface for decorators that provide useful functionality to the other
<B>InputStream</B> classes. See Table 10-3.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 10-3.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 10-3.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545385"></A><A NAME="_Toc408018612"></A></TABLE></P></DIV>
<A NAME="Heading305"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Types of OutputStream<BR><A NAME="Index1018"></A><A NAME="Index1019"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This category includes the classes
that decide where your output will go: an array of bytes (no <B>String</B>,
however; presumably you can create one using the array of bytes), a file, or a
&#8220;pipe.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, the
<B>FilterOutputStream</B> provides a base class for "decorator" classes that
attach attributes or useful interfaces to output streams. This is discussed
later.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Table 10-2. Types of
OutputStream<A NAME="Index1020"></A><A NAME="Index1021"></A><A NAME="Index1022"></A><A NAME="Index1023"></A><A NAME="Index1024"></A><A NAME="Index1025"></A><A NAME="Index1026"></A><A NAME="Index1027"></A></B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=85 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Class</FONT><BR></P></DIV>
</TH>
<TH WIDTH=94 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Function</FONT><BR></P></DIV>
</TH>
<TH WIDTH=157 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructor
Arguments</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TH WIDTH=157 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How to use it</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArray-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Creates a buffer in memory. All the
data that you send to the stream is placed in this buffer.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Optional initial size of the
buffer.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To designate the destination of
your data. Connect it to a <B>FilterOutputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>File-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For sending information to a
file.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>String</B> representing the
file name, or a <B>File</B> or <B>FileDescriptor</B> object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To designate the destination of
your data. Connect it to a <B>FilterOutputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Piped-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any information you write to this
automatically ends up as input for the associated <B>PipedInput-Stream.</B>
Implements the &#8220;piping&#8221; concept.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedInputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To designate the destination of
your data for multithreading. Connect it to a <B>FilterOutputStream</B> object
to provide a useful interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Filter-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Abstract class which is an
interface for decorators that provide useful functionality to the other
<B>OutputStream</B> classes. See Table
</FONT><BR><FONT FACE="Georgia">10-4.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 10-4.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 10-4.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545386"></A><A NAME="_Toc408018613"></A></TABLE></P></DIV>
<A NAME="Heading306"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Adding attributes <BR>and useful interfaces</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of layered objects to
dynamically and transparently add responsibilities to individual objects is
referred to as the
<A NAME="Index1028"></A><A NAME="Index1029"></A><I>decorator</I> pattern.
(Patterns</FONT><A NAME="fnB44" HREF="#fn44">[44]</A><FONT FACE="Georgia">
are the subject of Chapter 16.) The decorator pattern specifies that all objects
that wrap around your initial object have the same interface, to make the use of
the decorators transparent &#8211; you send the same message to an object
whether it&#8217;s been decorated or not. This is the reason for the existence
of the &#8220;filter&#8221; classes in the Java IO library: the abstract
&#8220;filter&#8221; class is the base class for all the decorators. (A
decorator must have the same interface as the object it decorates, but the
decorator can also extend the interface, which occurs in several of the
&#8220;filter&#8221; classes).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Decorators are often used when
subclassing requires a large number of subclasses to support every possible
combination needed &#8211; so many that subclassing becomes impractical. The
Java IO library requires many different combinations of features which is why
the decorator pattern is a good approach. There is a drawback to the decorator
pattern, however. Decorators give you much more flexibility while you&#8217;re
writing a program (since you can easily mix and match attributes), but they add
complexity to your code. The reason that the Java IO library is awkward to use
is that you must create many classes &#8211; the &#8220;core&#8221; IO type plus
all the decorators &#8211; in order to get the single IO object that you want.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The classes that provide the
decorator interface to control a particular <B>InputStream</B> or
<B>OutputStream</B> are the <B>FilterInputStream</B> and
<B>FilterOutputStream</B> &#8211; which don&#8217;t have very intuitive names.
They are derived, respectively, from <B>InputStream</B> and <B>OutputStream</B>,
and they are abstract classes, in theory to provide a common interface for all
the different ways you want to talk to a stream. In fact,
<B>FilterInputStream</B> and <B>FilterOutputStream</B> simply mimic their base
classes, which is the key requirement of the
decorator.</FONT><A NAME="_Toc375545387"></A><A NAME="_Toc408018614"></A><BR></P></DIV>
<A NAME="Heading307"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Reading from an InputStream <BR>with FilterInputStream</H3></FONT>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>FilterInputStream</B>
classes accomplish two significantly different things. <B>DataInputStream</B>
allows you to read different types of primitive data as well as <B>String</B>
objects. (All the methods start with &#8220;read,&#8221; such as
<B>readByte(&#160;)</B>, <B>readFloat(&#160;)</B>, etc.) This, along with its
companion <B>DataOutputStream</B>, allows you to move primitive data from one
place to another via a stream. These &#8220;places&#8221; are determined by the
classes in Table 10-1. If you&#8217;re reading data in blocks and parsing it
yourself, you won&#8217;t need <B>DataInputStream</B>, but in most other cases
you will want to use it to automatically format the data you
read.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The remaining classes modify the
way an <B>InputStream</B> behaves internally: whether it&#8217;s buffered or
unbuffered, if it keeps track of the lines it&#8217;s reading (allowing you to
ask for line numbers or set the line number), and whether you can push back a
single character. The last two classes look a lot like support for building a
compiler (that is, they were added to support the construction of the Java
compiler), so you probably won&#8217;t use them in general programming.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll probably need to
buffer your input almost every time, regardless of the IO device you&#8217;re
connecting to, so it would have made more sense for the IO library to make a
special case for unbuffered input rather than buffered input.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Table 10-3. Types of
FilterInputStream<A NAME="Index1030"></A><A NAME="Index1031"></A><A NAME="Index1032"></A><A NAME="Index1033"></A><A NAME="Index1034"></A><A NAME="Index1035"></A><A NAME="Index1036"></A><A NAME="Index1037"></A></B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Class</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Function</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructor
Arguments</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How to use it</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Data-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Used in concert with
<B>DataOutputStream</B>, so you can read primitives (int, char, long, etc.) from
a stream in a portable fashion.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Contains a full interface to allow
you to read primitive types.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>

<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Buffered-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Use this to prevent a physical read
every time you want more data. You&#8217;re saying &#8220;Use a
buffer.&#8221;</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B>, with optional
buffer size.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This doesn&#8217;t provide an
interface <I>per se</I>, just a requirement that a buffer be used. Attach an
interface object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LineNumber-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Keeps track of line numbers in the
input stream; you can call <B>getLineNumber(&#160;)</B> and
<B>setLineNumber(int)</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This just adds line numbering, so
you&#8217;ll probably attach an interface object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Pushback-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Has a one byte push-back buffer so
that you can push back the last character read.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Generally used in the scanner for a
compiler and probably included because the Java compiler needed it. You probably
won&#8217;t use this.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545388"></A><A NAME="_Toc408018615"></A></TABLE></P></DIV>
<A NAME="Heading308"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Writing to an OutputStream <BR>with FilterOutputStream</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The complement to
<B>DataInputStream</B> is <B>DataOutputStream</B>, which formats each of the
primitive types and <B>String</B> objects onto a stream in such a way that any
<B>DataInputStream</B>, on any machine, can read them. All the methods start
with &#8220;write,&#8221; such as <B>writeByte(&#160;)</B>,
<B>writeFloat(&#160;)</B>, etc.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to do true formatted
output, for example, to the console, use a <B>PrintStream</B>. This is the
endpoint that allows you to print all of the primitive data types and
<B>String</B> objects in a viewable format as opposed to
<B>DataOutputStream,</B> whose goal is to put them on a stream in a way that
<B>DataInputStream</B> can portably reconstruct them. The <B>System.out</B>
static object is a <B>PrintStream</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The two important methods in
<B>PrintStream</B> are <B>print(&#160;)</B> and <B>println(&#160;)</B>, which
are overloaded to print out all the various types. The difference between
<B>print(&#160;)</B> and <B>println(&#160;)</B> is that the latter adds a
newline when it&#8217;s done.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedOutputStream</B> is a
modifier and tells the stream to use buffering so you don&#8217;t get a physical
write every time you write to the stream. You&#8217;ll probably always want to
use this with files, and possibly console IO.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Table 10-4. Types of
FilterOutputStream<A NAME="Index1038"></A><A NAME="Index1039"></A><A NAME="Index1040"></A><A NAME="Index1041"></A><A NAME="Index1042"></A><A NAME="Index1043"></A></B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=85 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Class</FONT><BR></P></DIV>
</TH>
<TH WIDTH=121 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Function</FONT><BR></P></DIV>
</TH>
<TH WIDTH=121 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructor Arguments
</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TH WIDTH=121 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How to use it</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Data-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Used in concert with
<B>DataInputStream</B> so you can write primitives (int, char, long, etc.) to a
stream in a portable fashion.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Contains full interface to allow
you to write primitive types.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For producing formatted output.
While <B>DataOutputStream</B> handles the <I>storage</I> of data,
<B>PrintStream</B> handles <I>display</I>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B>, with optional
boolean indicating that the buffer is flushed with every
newline.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Should be the &#8220;final&#8221;
wrapping for your <B>OutputStream</B> object. You&#8217;ll probably use this a
lot.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Buffered-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Use this to prevent a physical
write every time you send a piece of data. You&#8217;re saying &#8220;Use a
buffer.&#8221; You can call <B>flush(&#160;)</B> to flush the
buffer.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B>, with optional
buffer size.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This doesn&#8217;t provide an
interface <I>per se</I>, just a requirement that a buffer is used. Attach an
interface object.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545389"></A><A NAME="_Toc408018616"></A></TABLE></P></DIV>
<A NAME="Heading309"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Off by itself:
<BR>RandomAccessFile<BR><A NAME="Index1044"></A><A NAME="Index1045"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>RandomAccessFile</B> is used for
files containing records of known size so that you can move from one record to
another using
<A NAME="Index1046"></A><A NAME="Index1047"></A><B>seek(&#160;)</B>, then read
or change the records. The records don&#8217;t have to be the same size; you
just have to be able to determine how big they are and where they are placed in
the file.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At first it&#8217;s a little bit
hard to believe that <B>RandomAccessFile</B> is not part of the
<B>InputStream</B> or <B>OutputStream</B> hierarchy. It has no association with
those hierarchies other than that it happens to implement the
<A NAME="Index1048"></A><A NAME="Index1049"></A><B>DataInput</B> and
<A NAME="Index1050"></A><A NAME="Index1051"></A><B>DataOutput</B> interfaces
(which are also implemented by <B>DataInputStream</B> and
<B>DataOutputStream</B>). It doesn&#8217;t even use any of the functionality of
the existing <B>InputStream</B> or <B>OutputStream</B> classes &#8211;
it&#8217;s a completely separate class, written from scratch, with all of its
own (mostly native) methods. The reason for this may be that
<B>RandomAccessFile</B> has essentially different behavior than the other IO
types, since you can move forward and backward within a file. In any event, it
stands alone, as a direct descendant of <B>Object</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Essentially, a
<B>RandomAccessFile</B> works like a <B>DataInputStream</B> pasted together with
a <B>DataOutputStream </B>and the methods <B>getFilePointer(&#160;)</B> to find
out where you are in the file, <B>seek(&#160;)</B> to move to a new point in the
file, and <B>length(&#160;)</B> to determine the maximum size of the file. In
addition, the constructors require a second argument (identical to
<B>fopen(&#160;) </B>in C) indicating whether you are just randomly reading
(<B>&#8220;r&#8221;</B>) or reading and writing (<B>&#8220;rw&#8221;</B>).
There&#8217;s no support for write-only files, which could suggest that
<B>RandomAccessFile</B> might have worked well if it were inherited from
<B>DataInputStream</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What&#8217;s even more frustrating
is that you could easily imagine wanting to seek within other types of streams,
such as a <B>ByteArrayInputStream</B>, but the seeking methods are available
only in <B>RandomAccessFile</B>, which works for files only.
<B>BufferedInputStream</B> does allow you to
<A NAME="Index1052"></A><A NAME="Index1053"></A><B>mark(&#160;)</B> a position
(whose value is held in a single internal variable) and
<A NAME="Index1054"></A><A NAME="Index1055"></A><B>reset(&#160;)</B> to that
position, but this is limited and not too
useful.</FONT><A NAME="_Toc375545390"></A><A NAME="_Toc408018617"></A><BR></P></DIV>
<A NAME="Heading310"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The File class</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1056"></A><A NAME="Index1057"></A><B>File </B>class has a
deceiving name &#8211; you might think it refers to a file, but it
doesn&#8217;t. It can represent either the <I>name</I> of a particular file or
the <I>names</I> of a set of files in a directory. If it&#8217;s a set of files,
you can ask for the set with the
<A NAME="Index1058"></A><A NAME="Index1059"></A><B>list(&#160;)</B> method, and
this returns an array of <B>String</B>. It makes sense to return an array rather
than one of the flexible collection classes because the number of elements is
fixed, and if you want a different directory listing you just create a different
<B>File</B> object. In fact, &#8220;FilePath&#8221; would have been a better
name. This section shows a complete example of the use of this class, including
the associated
<A NAME="Index1060"></A><A NAME="Index1061"></A><B>FilenameFilter</B>
<B>interface</B>.</FONT><A NAME="_Toc375545391"></A><A NAME="_Toc408018618"></A><BR></P></DIV>
<A NAME="Heading311"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A directory lister<BR><A NAME="Index1062"></A><A NAME="Index1063"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Suppose you&#8217;d like to see a
directory listing. The <B>File</B> object can be listed in two ways. If you call
<B>list(&#160;)</B> with no arguments, you&#8217;ll get the full list that the
<B>File</B> object contains. However, if you want a restricted list, for
example, all of the files with an extension of <B>.java</B>, then you use a
&#8220;directory filter,&#8221; which is a class that tells how to select the
<B>File</B> objects for display.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the code for the
example: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: DirList.java</font>
<font color=#009900>// Displays directory listing</font>
<font color=#0000ff>package</font> c10;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
      String[] list;
      <font color=#0000ff>if</font>(args.length == 0)
        list = path.list();
      <font color=#0000ff>else</font> 
        list = path.list(<font color=#0000ff>new</font> DirFilter(args[0]));
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
        System.out.println(list[i]);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
}

<font color=#0000ff>class</font> DirFilter <font color=#0000ff>implements</font> FilenameFilter {
  String afn;
  DirFilter(String afn) { <font color=#0000ff>this</font>.afn = afn; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String name) {
    <font color=#009900>// Strip path information:</font>
    String f = <font color=#0000ff>new</font> File(name).getName();
    <font color=#0000ff>return</font> f.indexOf(afn) != -1;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>DirFilter</B> class
&#8220;implements&#8221; the <B>interface</B> <B>FilenameFilter</B>. (Interfaces
were covered in Chapter 7.) It&#8217;s useful to see how simple the
<B>FilenameFilter</B> <B>interface</B> is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>interface</font> FilenameFilter {
  <font color=#0000ff>boolean</font> accept(File dir, String name);
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It says that all that this type of
object does is provide a method called <B>accept(&#160;)</B>. The whole reason
behind the creation of this class is to provide the <B>accept(&#160;)</B> method
to the <B>list(&#160;)</B> method so that <B>list(&#160;)</B> can <I>call
back</I> <B>accept(&#160;)</B> to determine which file names should be included
in the list. Thus, this technique is often referred to as a
<A NAME="Index1064"></A><I>callback</I> or sometimes a
<A NAME="Index1065"></A><I>functor</I> (that is, <B>DirFilter</B> is a functor
because its only job is to hold a method). Because <B>list(&#160;)</B> takes a
<B>FilenameFilter</B> object as its argument, it means that you can pass an
object of any class that implements <B>FilenameFilter</B> to choose (even at
run-time) how the <B>list(&#160;)</B> method will behave. The purpose of a
callback is to provide flexibility in the behavior of code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DirFilter</B> shows that just
because an <B>interface</B> contains only a set of methods, you&#8217;re not
restricted to writing only those methods. (You must at least provide definitions
for all the methods in an interface, however.) In this case, the
<B>DirFilter</B> constructor is also created.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>accept(&#160;)</B> method
must accept a <B>File</B> object representing the directory that a particular
file is found in, and a <B>String</B> containing the name of that file. You
might choose to use or ignore either of these arguments, but you will probably
at least use the file name. Remember that the <B>list(&#160;)</B> method is
calling <B>accept(&#160;)</B> for each of the file names in the directory object
to see which one should be included &#8211; this is indicated by the
<B>boolean</B> result returned by <B>accept(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make sure that what you&#8217;re
working with is only the name and contains no path information, all you have to
do is take the <B>String</B> object and create a <B>File</B> object out of it,
then call <B>getName(&#160;)</B> which strips away all the path information (in
a platform-independent way). Then <B>accept(&#160;)</B> uses the
<A NAME="Index1066"></A><A NAME="Index1067"></A><B>String </B>class
<B>indexOf(&#160;)</B> method to see if the search string <B>afn</B> appears
anywhere in the name of the file. If <B>afn</B> is found within the string, the
return value is the starting index of <B>afn</B>, but if it&#8217;s not found
the return value is -1. Keep in mind that this is a simple string search and
does not have regular expression &#8220;wildcard&#8221; matching such as
&#8220;fo?.b?r*&#8221; which is much more difficult to
implement.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>list(&#160;)</B> method
returns an array. You can query this array for its length and then move through
it selecting the array elements. This ability to easily pass an array in and out
of a method is a tremendous improvement over the behavior of C and
C++.</FONT><BR></P></DIV>
<A NAME="Heading312"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Anonymous inner classes</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example is ideal for rewriting
using an
<A NAME="Index1068"></A><A NAME="Index1069"></A><A NAME="Index1070"></A>anonymous
inner class (described in Chapter 7). As a first cut, a method <B>filter(&#160;)
</B>is created that returns a handle to a
<B>FilenameFilter</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: DirList2.java</font>
<font color=#009900>// Uses Java 1.1 anonymous inner classes</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> FilenameFilter 
  filter(<font color=#0000ff>final</font> String afn) {
    <font color=#009900>// Creation of anonymous inner class:</font>
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> FilenameFilter() {
      String fn = afn;
      <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String n) {
        <font color=#009900>// Strip path information:</font>
        String f = <font color=#0000ff>new</font> File(n).getName();
        <font color=#0000ff>return</font> f.indexOf(fn) != -1;
      }
    }; <font color=#009900>// End of anonymous inner class</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
      String[] list;
      <font color=#0000ff>if</font>(args.length == 0)
        list = path.list();
      <font color=#0000ff>else</font> 
        list = path.list(filter(args[0]));
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
        System.out.println(list[i]);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the argument to
<B>filter(&#160;)</B> must be
<A NAME="Index1071"></A><A NAME="Index1072"></A><B>final</B>. This is required
by the anonymous inner class so that it can use an object from outside its
scope.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This design is an improvement
because the <B>FilenameFilter</B> class is now tightly bound to <B>DirList2</B>.
However, you can take this approach one step further and define the anonymous
inner class as an argument to <B>list(&#160;)</B>, in which case it&#8217;s even
smaller:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: DirList3.java</font>
<font color=#009900>// Building the anonymous inner class "in-place"</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList3 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(<font color=#0000ff>final</font> String[] args) {
    <font color=#0000ff>try</font> {
      File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
      String[] list;
      <font color=#0000ff>if</font>(args.length == 0)
        list = path.list();
      <font color=#0000ff>else</font> 
        list = path.list(
          <font color=#0000ff>new</font> FilenameFilter() {
            <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
            accept(File dir, String n) {
              String f = <font color=#0000ff>new</font> File(n).getName();
              <font color=#0000ff>return</font> f.indexOf(args[0]) != -1;
            }
          });
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
        System.out.println(list[i]);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The argument to <B>main(&#160;)</B>
is now <B>final</B>, since the anonymous inner class uses <B>args[0]</B>
directly.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This shows you how anonymous inner
classes allow the creation of quick-and-dirty classes to solve problems. Since
everything in Java revolves around classes, this can be a useful coding
technique. One benefit is that it keeps the code that solves a particular
problem isolated together in one spot. On the other hand, it is not always as
easy to read, so you must use it judiciously.</FONT><BR></P></DIV>
<A NAME="Heading313"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
A sorted directory listing</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Ah, you say that you want the file
names <I>sorted</I>? Since there&#8217;s no support for sorting in Java 1.0 or
Java 1.1<A NAME="Index1073"></A> (although sorting <I>is</I> included in Java
1.2<A NAME="Index1074"></A>), it will have to be added into the program directly
using the <B>SortVector </B>created in Chapter 8:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SortedDirList.java</font>
<font color=#009900>// Displays sorted directory listing</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> c08.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SortedDirList {
  <font color=#0000ff>private</font> File path;
  <font color=#0000ff>private</font> String[] list;
  <font color=#0000ff>public</font> SortedDirList(<font color=#0000ff>final</font> String afn) {
    path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    <font color=#0000ff>if</font>(afn == <font color=#0000ff>null</font>)
      list = path.list();
    <font color=#0000ff>else</font>
      list = path.list(
          <font color=#0000ff>new</font> FilenameFilter() {
            <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
            accept(File dir, String n) {
              String f = <font color=#0000ff>new</font> File(n).getName();
              <font color=#0000ff>return</font> f.indexOf(afn) != -1;
            }
          });
    sort();
  }
  <font color=#0000ff>void</font> print() {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> sort() {
    StrSortVector sv = <font color=#0000ff>new</font> StrSortVector();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      sv.addElement(list[i]);
    <font color=#009900>// The first time an element is pulled from</font>
    <font color=#009900>// the StrSortVector the list is sorted:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      list[i] = sv.elementAt(i);
  }
  <font color=#009900>// Test it:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SortedDirList sd;
    <font color=#0000ff>if</font>(args.length == 0)
      sd = <font color=#0000ff>new</font> SortedDirList(<font color=#0000ff>null</font>);
    <font color=#0000ff>else</font>
      sd = <font color=#0000ff>new</font> SortedDirList(args[0]);
    sd.print();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A few other improvements have been
made. Instead of creating <B>path</B> and <B>list</B> as local variables to
<B>main(&#160;)</B>, they are members of the class so their values can be
accessible for the lifetime of the object. In fact, <B>main(&#160;)</B> is now
just a way to test the class. You can see that the constructor of the class
automatically sorts the list once that list has been created.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The sort is case-insensitive so you
don&#8217;t end up with a list of all the words starting with capital letters,
followed by the rest of the words starting with all the lowercase letters.
However, you&#8217;ll notice that within a group of file names that begin with
the same letter the capitalized words are listed first, which is still not quite
the desired behavior for the sort. This problem will be fixed in Java
1.2<A NAME="Index1075"></A>.</FONT><A NAME="_Toc375545392"></A><A NAME="_Toc408018619"></A><BR></P></DIV>
<A NAME="Heading314"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Checking for and creating directories</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>File</B> class is more than
just a representation for an existing directory path, file, or group of files.
You can also use a <B>File</B> object to create a new
<A NAME="Index1076"></A><A NAME="Index1077"></A>directory or an entire directory
path if it doesn&#8217;t exist. You can also look at the
<A NAME="Index1078"></A><A NAME="Index1079"></A>characteristics of files (size,
last modification date, read/write), see whether a <B>File</B> object represents
a file or a directory, and delete a file. This program shows the remaining
methods available with the <B>File</B> class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MakeDirectories.java</font>
<font color=#009900>// Demonstrates the use of the File class to</font>
<font color=#009900>// create directories and manipulate files.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MakeDirectories {
  <font color=#0000ff>private</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> String usage =
    <font color=#004488>"Usage:MakeDirectories path1 ...\n"</font> +
    <font color=#004488>"Creates each path\n"</font> +
    <font color=#004488>"Usage:MakeDirectories -d path1 ...\n"</font> +
    <font color=#004488>"Deletes each path\n"</font> +
    <font color=#004488>"Usage:MakeDirectories -r path1 path2\n"</font> +
    <font color=#004488>"Renames from path1 to path2\n"</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> usage() {
    System.err.println(usage);
    System.exit(1);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fileData(File f) {
    System.out.println(
      <font color=#004488>"Absolute path: "</font> + f.getAbsolutePath() +
      <font color=#004488>"\n Can read: "</font> + f.canRead() +
      <font color=#004488>"\n Can write: "</font> + f.canWrite() +
      <font color=#004488>"\n getName: "</font> + f.getName() +
      <font color=#004488>"\n getParent: "</font> + f.getParent() +
      <font color=#004488>"\n getPath: "</font> + f.getPath() +
      <font color=#004488>"\n length: "</font> + f.length() +
      <font color=#004488>"\n lastModified: "</font> + f.lastModified());
    <font color=#0000ff>if</font>(f.isFile())
      System.out.println(<font color=#004488>"it's a file"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(f.isDirectory())
      System.out.println(<font color=#004488>"it's a directory"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length &lt; 1) usage();
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-r"</font>)) {
      <font color=#0000ff>if</font>(args.length != 3) usage();
      File 
        old = <font color=#0000ff>new</font> File(args[1]),
        rname = <font color=#0000ff>new</font> File(args[2]);
      old.renameTo(rname);
      fileData(old);
      fileData(rname);
      <font color=#0000ff>return</font>; <font color=#009900>// Exit main</font>
    }
    <font color=#0000ff>int</font> count = 0;
    <font color=#0000ff>boolean</font> del = <font color=#0000ff>false</font>;
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-d"</font>)) {
      count++;
      del = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>for</font>( ; count &lt; args.length; count++) {
      File f = <font color=#0000ff>new</font> File(args[count]);
      <font color=#0000ff>if</font>(f.exists()) {
        System.out.println(f + <font color=#004488>" exists"</font>);
        <font color=#0000ff>if</font>(del) {
          System.out.println(<font color=#004488>"deleting..."</font> + f);
          f.delete();
        }
      } 
      <font color=#0000ff>else</font> { <font color=#009900>// Doesn't exist</font>
        <font color=#0000ff>if</font>(!del) {
          f.mkdirs();
          System.out.println(<font color=#004488>"created "</font> + f);
        }
      }
      fileData(f);
    }  
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>fileData(&#160;)</B> you can
see the various file investigation methods put to use to display information
about the file or directory path.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first method that&#8217;s
exercised by <B>main(&#160;)</B> is
<A NAME="Index1080"></A><A NAME="Index1081"></A><B>renameTo(&#160;)</B>, which
allows you to rename (or move) a file to an entirely new path represented by the
argument, which is another <B>File</B> object. This also works with directories
of any length.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you experiment with the above
program, you&#8217;ll find that you can make a directory path of any complexity
because <A NAME="Index1082"></A><A NAME="Index1083"></A><B>mkdirs(&#160;)</B>
will do all the work for you. In Java 1.0<A NAME="Index1084"></A>, the <B>-d</B>
flag reports that the directory is deleted but it&#8217;s still there; in Java
1.1<A NAME="Index1085"></A> the directory is actually
deleted.</FONT><A NAME="_Toc375545393"></A><A NAME="_Toc408018620"></A><BR></P></DIV>
<A NAME="Heading315"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Typical uses of IO streams</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although there are a lot of IO
stream classes in the library that can be combined in many different ways, there
are just a few ways that you&#8217;ll probably end up using them. However, they
require attention to get the correct combinations. The following rather long
example shows the creation and use of <A NAME="Index1086"></A>typical IO
configurations so you can use it as a reference when writing your own code. Note
that each configuration begins with a commented number and title that
corresponds to the heading for the appropriate explanation that follows in the
text.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: IOStreamDemo.java</font>
<font color=#009900>// Typical IO Stream Configurations</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> com.bruceeckel.tools.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IOStreamDemo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#009900>// 1. Buffered input file</font>
      DataInputStream in =
        <font color=#0000ff>new</font> DataInputStream(
          <font color=#0000ff>new</font> BufferedInputStream(
            <font color=#0000ff>new</font> FileInputStream(args[0])));
      String s, s2 = <font color=#0000ff>new</font> String();
      <font color=#0000ff>while</font>((s = in.readLine())!= <font color=#0000ff>null</font>)
        s2 += s + <font color=#004488>"\n"</font>;
      in.close();

      <font color=#009900>// 2. Input from memory</font>
      StringBufferInputStream in2 =
          <font color=#0000ff>new</font> StringBufferInputStream(s2);
      <font color=#0000ff>int</font> c;
      <font color=#0000ff>while</font>((c = in2.read()) != -1)
        System.out.print((<font color=#0000ff>char</font>)c);

      <font color=#009900>// 3. Formatted memory input</font>
      <font color=#0000ff>try</font> {
        DataInputStream in3 =
          <font color=#0000ff>new</font> DataInputStream(
            <font color=#0000ff>new</font> StringBufferInputStream(s2));
        <font color=#0000ff>while</font>(<font color=#0000ff>true</font>)
          System.out.print((<font color=#0000ff>char</font>)in3.readByte());
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(
          <font color=#004488>"End of stream encountered"</font>);
      }

      <font color=#009900>// 4. Line numbering &amp; file output</font>
      <font color=#0000ff>try</font> {
        LineNumberInputStream li =
          <font color=#0000ff>new</font> LineNumberInputStream(
            <font color=#0000ff>new</font> StringBufferInputStream(s2));
        DataInputStream in4 =
          <font color=#0000ff>new</font> DataInputStream(li);
        PrintStream out1 =
          <font color=#0000ff>new</font> PrintStream(
            <font color=#0000ff>new</font> BufferedOutputStream(
              <font color=#0000ff>new</font> FileOutputStream(
                <font color=#004488>"IODemo.out"</font>)));
        <font color=#0000ff>while</font>((s = in4.readLine()) != <font color=#0000ff>null</font> )
          out1.println(
            <font color=#004488>"Line "</font> + li.getLineNumber() + s);
        out1.close(); <font color=#009900>// finalize() not reliable!</font>
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(
          <font color=#004488>"End of stream encountered"</font>);
      }

      <font color=#009900>// 5. Storing &amp; recovering data</font>
      <font color=#0000ff>try</font> {
        DataOutputStream out2 =
          <font color=#0000ff>new</font> DataOutputStream(
            <font color=#0000ff>new</font> BufferedOutputStream(
              <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
        out2.writeBytes(
          <font color=#004488>"Here's the value of pi: \n"</font>);
        out2.writeDouble(3.14159);
        out2.close();
        DataInputStream in5 =
          <font color=#0000ff>new</font> DataInputStream(
            <font color=#0000ff>new</font> BufferedInputStream(
              <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
        System.out.println(in5.readLine());
        System.out.println(in5.readDouble());
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(
          <font color=#004488>"End of stream encountered"</font>);
      }

      <font color=#009900>// 6. Reading/writing random access files</font>
      RandomAccessFile rf =
        <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        rf.writeDouble(i*1.414);
      rf.close();

      rf =
        <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
      rf.seek(5*8);
      rf.writeDouble(47.0001);
      rf.close();

      rf =
        <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"r"</font>);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        System.out.println(
          <font color=#004488>"Value "</font> + i + <font color=#004488>": "</font> +
          rf.readDouble());
      rf.close();

      <font color=#009900>// 7. File input shorthand</font>
      InFile in6 = <font color=#0000ff>new</font> InFile(args[0]);
      String s3 = <font color=#0000ff>new</font> String();
      System.out.println(
        <font color=#004488>"First line in file: "</font> +
        in6.readLine());
        in6.close();

      <font color=#009900>// 8. Formatted file output shorthand</font>
      PrintFile out3 = <font color=#0000ff>new</font> PrintFile(<font color=#004488>"Data2.txt"</font>);
      out3.print(<font color=#004488>"Test of PrintFile"</font>);
      out3.close();

      <font color=#009900>// 9. Data file output shorthand</font>
      OutFile out4 = <font color=#0000ff>new</font> OutFile(<font color=#004488>"Data3.txt"</font>);
      out4.writeBytes(<font color=#004488>"Test of outDataFile\n\r"</font>);
      out4.writeChars(<font color=#004488>"Test of outDataFile\n\r"</font>);
      out4.close();

    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.out.println(
        <font color=#004488>"File Not Found:"</font> + args[0]);
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(<font color=#004488>"IO Exception"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><A NAME="_Toc375545394"></A><A NAME="_Toc408018621"></A><BR></P></DIV>
<A NAME="Heading316"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Input streams</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, one common thing
you&#8217;ll want to do is print formatted output to the console, but
that&#8217;s already been simplified in the package <B>com.bruceeckel.tools</B>
created in Chapter 5.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Parts 1 through 4 demonstrate the
creation and use of input streams (although part 4 also shows the simple use of
an output stream as a testing tool).</FONT><BR></P></DIV>
<A NAME="Heading317"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
1. Buffered input file</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To open a file for input, you use a
<A NAME="Index1087"></A><A NAME="Index1088"></A><B>FileInputStream</B> with a
<B>String</B> or a <B>File</B> object as the file name. For speed, you&#8217;ll
want that file to be buffered so you give the resulting handle to the
constructor for a
<A NAME="Index1089"></A><A NAME="Index1090"></A><B>BufferedInputStream</B>. To
read input in a formatted fashion, you give that resulting handle to the
constructor for a
<A NAME="Index1091"></A><A NAME="Index1092"></A><B>DataInputStream</B>, which is
your final object and the interface you read from.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this example, only the
<A NAME="Index1093"></A><A NAME="Index1094"></A><B>readLine(&#160;)</B> method
is used, but of course any of the <B>DataInputStream</B> methods are available.
When you reach the end of the file, <B>readLine(&#160;)</B> returns <B>null</B>
so that is used to break out of the <B>while</B> loop.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>String s2</B> is used to
accumulate the entire contents of the file (including newlines that must be
added since <B>readLine(&#160;)</B> strips them off). <B>s2 </B>is then used in
the later portions of this program. Finally, <B>close(&#160;)</B> is called to
close the file. Technically, <B>close(&#160;)</B> will be called when
<B>finalize(&#160;)</B> is run, and this is supposed to happen (whether or not
garbage collection occurs) as the program exits. However, Java
1.0<A NAME="Index1095"></A> has a rather important bug, so this doesn&#8217;t
happen. In Java 1.1<A NAME="Index1096"></A> you must explicitly call
<A NAME="Index1097"></A><B>System.runFinalizersOnExit(true)</B> to guarantee
that <B>finalize(&#160;)</B> will be called for every object in the system. The
safest approach is to explicitly call
<A NAME="Index1098"></A><A NAME="Index1099"></A><B>close(&#160;)</B> for
files.</FONT><BR></P></DIV>
<A NAME="Heading318"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
2. Input from memory</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This piece takes the <B>String
s2</B> that now contains the entire contents of the file and uses it to create a
<A NAME="Index1100"></A><A NAME="Index1101"></A><B>StringBufferInputStream.</B>
(A <B>String</B>, not a <A NAME="Index1102"></A><B>StringBuffer</B>, is required
as the constructor argument.) Then <B>read(&#160;)</B> is used to read each
character one at a time and send it out to the console. Note that
<B>read(&#160;)</B> returns the next byte as an <B>int</B> and thus it must be
cast to a <B>char</B> to print properly.</FONT><BR></P></DIV>
<A NAME="Heading319"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
3. Formatted memory input</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The interface for
<B>StringBufferInputStream</B> is limited, so you usually enhance it by wrapping
it inside a
<A NAME="Index1103"></A><A NAME="Index1104"></A><B>DataInputStream</B>. However,
if you choose to read the characters out a byte at a time using
<B>readByte(&#160;)</B>, any value is valid so the return value cannot be used
to detect the end of input. Instead, you can use the
<A NAME="Index1105"></A><A NAME="Index1106"></A><B>available(&#160;) </B>method
to find out how many more characters are available. Here&#8217;s an example that
shows how to read a file one byte at a time:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: TestEOF.java</font>
<font color=#009900>// Testing for the end of file while reading</font>
<font color=#009900>// a byte at a time.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestEOF {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      DataInputStream in = 
        <font color=#0000ff>new</font> DataInputStream(
         <font color=#0000ff>new</font> BufferedInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"TestEof.java"</font>)));
      <font color=#0000ff>while</font>(in.available() != 0)
        System.out.print((<font color=#0000ff>char</font>)in.readByte());
    } <font color=#0000ff>catch</font> (IOException e) {
      System.err.println(<font color=#004488>"IOException"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>available(&#160;)</B>
works differently depending on what sort of medium you&#8217;re reading from
&#8211; it&#8217;s literally &#8220;the number of bytes that can be read
<I>without blocking</I>.&#8221;<A NAME="Index1107"></A><A NAME="Index1108"></A>
With a file this means the whole file, but with a different kind of stream this
might not be true, so use it thoughtfully.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You could also detect the end of
input in cases like these by catching an exception. However, the use of
exceptions for control flow is considered a misuse of that
feature.</FONT><BR></P></DIV>
<A NAME="Heading320"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
4. Line numbering and file output</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example shows the use of the
<A NAME="Index1109"></A><A NAME="Index1110"></A><B>LineNumberInputStream</B> to
keep track of the input line numbers. Here, you cannot simply gang all the
constructors together, since you have to keep a handle to the
<B>LineNumberInputStream.</B> (Note that this is <I>not</I> an inheritance
situation, so you cannot simply cast <B>in4</B> to a
<B>LineNumberInputStream.</B>) Thus, <B>li</B> holds the handle to the
<B>LineNumberInputStream,</B> which is then used to create a
<B>DataInputStream</B> for easy reading.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example also shows how to
write formatted data to a file. First, a
<A NAME="Index1111"></A><A NAME="Index1112"></A><B>FileOutputStream</B> is
created to connect to the file. For efficiency, this is made a
<A NAME="Index1113"></A><A NAME="Index1114"></A><B>BufferedOutputStream</B>,
which is what you&#8217;ll virtually always want to do, but you&#8217;re forced
to do it explicitly. Then for the formatting it&#8217;s turned into a
<A NAME="Index1115"></A><A NAME="Index1116"></A><B>PrintStream</B>. The data
file created this way is readable as an ordinary text file.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the methods that indicates
when a <A NAME="Index1117"></A><A NAME="Index1118"></A><B>DataInputStream</B> is
exhausted is
<A NAME="Index1119"></A><A NAME="Index1120"></A><B>readLine(&#160;)</B>, which
returns <B>null</B> when there are no more strings to read. Each line is printed
to the file along with its line number, which is acquired through
<B>li</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll see an explicit
<B>close(&#160;)</B> for <B>out1</B>, which would make sense <I>if</I> the
program were to turn around and read the same file again. However, this program
ends without ever looking at the file <B>IODemo.out</B>. As mentioned before, if
you don&#8217;t call <B>close(&#160;)</B> for all your output files, you might
discover that the buffers don&#8217;t get flushed so they&#8217;re
incomplete.</FONT><A NAME="_Toc375545395"></A><A NAME="_Toc408018622"></A><BR></P></DIV>
<A NAME="Heading321"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Output streams</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The two primary kinds of output
streams are separated by the way they write data: one writes it for human
consumption, and the other writes it to be re-acquired by a
<A NAME="Index1121"></A><A NAME="Index1122"></A><B>DataInputStream</B>. The
<A NAME="Index1123"></A><A NAME="Index1124"></A><B>RandomAccessFile</B> stands
alone, although its data format is compatible with the <B>DataInputStream</B>
and
<A NAME="Index1125"></A><A NAME="Index1126"></A><B>DataOutputStream</B>.</FONT><BR></P></DIV>
<A NAME="Heading322"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
5. Storing and recovering data</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index1127"></A><A NAME="Index1128"></A><B>PrintStream</B> formats data
so it&#8217;s readable by a human. To output data so that it can be recovered by
another stream, you use a <B>DataOutputStream</B> to write the data and a
<B>DataInputStream</B> to recover the data. Of course, these streams could be
anything, but here a file is used, buffered for both reading and
writing.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the character string is
written using
<A NAME="Index1129"></A><A NAME="Index1130"></A><B>writeBytes(&#160;)</B> and
not <A NAME="Index1131"></A><A NAME="Index1132"></A><B>writeChars(&#160;)</B>.
If you use the latter, you&#8217;ll be writing the 16-bit Unicode characters.
Since there is no complementary &#8220;readChars&#8221; method in
<B>DataInputStream</B>, you&#8217;re stuck pulling these characters off one at a
time with
<A NAME="Index1133"></A><A NAME="Index1134"></A><B>readChar(&#160;)</B>. So for
ASCII, it&#8217;s easier to write the characters as bytes followed by a newline;
then use <A NAME="Index1135"></A><A NAME="Index1136"></A><B>readLine(&#160;)</B>
to read back the bytes as a regular ASCII line.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1137"></A><A NAME="Index1138"></A><B>writeDouble(&#160;)</B>
stores the <B>double</B> number to the stream and the complementary
<A NAME="Index1139"></A><A NAME="Index1140"></A><B>readDouble(&#160;)</B>
recovers it. But for any of the reading methods to work correctly, you must know
the exact placement of the data item in the stream, since it would be equally
possible to read the stored <B>double</B> as a simple sequence of bytes, or as a
<B>char</B>, etc. So you must either have a fixed format for the data in the
file or extra information must be stored in the file that you parse to determine
where the data is located.</FONT><BR></P></DIV>
<A NAME="Heading323"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
6. Reading and writing random access files</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As previously noted, the
<B>RandomAccessFile</B> is almost totally isolated from the rest of the IO
hierarchy, save for the fact that it implements the <B>DataInput</B> and
<B>DataOutput</B> interfaces. So you cannot combine it with any of the aspects
of the <B>InputStream</B> and <B>OutputStream</B> subclasses. Even though it
might make sense to treat a <B>ByteArrayInputStream</B> as a random access
element, you can use <B>RandomAccessFile</B> to only open a file. You must
assume a <B>RandomAccessFile</B> is properly buffered since you cannot add
that.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The one option you have is in the
second constructor argument: you can open a <B>RandomAccessFile</B> to read
(<B>&#8220;r&#8221;</B>) or read and write
(<B>&#8220;rw&#8221;</B>).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Using a <B>RandomAccessFile</B> is
like using a combined <B>DataInputStream</B> and <B>DataOutputStream</B>
(because it implements the equivalent interfaces). In addition, you can see that
<A NAME="Index1141"></A><A NAME="Index1142"></A><B>seek(&#160;)</B> is used to
move about in the file and change one of the
values.</FONT><A NAME="_Toc375545396"></A><A NAME="_Toc408018623"></A><BR></P></DIV>
<A NAME="Heading324"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Shorthand for file manipulation</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since there are certain canonical
forms that you&#8217;ll be using regularly with files, you may wonder why you
have to do all of that typing &#8211; this is one of the drawbacks of the
decorator pattern. This portion shows the creation and use of shorthand versions
of typical file reading and writing configurations. These shorthands are placed
in the <B>package</B> <B>com.bruceeckel.tools</B> that was begun in Chapter 5
(See page 196). To add each class to the library, simply place it in the
appropriate directory and add the <B>package</B> statement.</FONT><BR></P></DIV>
<A NAME="Heading325"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
7. File input
shorthand<BR><A NAME="Index1143"></A><A NAME="Index1144"></A><A NAME="Index1145"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The creation of an object that
reads a file from a buffered <B>DataInputStream</B> can be encapsulated into a
class called <B>InFile</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: InFile.java</font>
<font color=#009900>// Shorthand class for opening an input file</font>
<font color=#0000ff>package</font> com.bruceeckel.tools;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> InFile <font color=#0000ff>extends</font> DataInputStream {
  <font color=#0000ff>public</font> InFile(String filename)
    <font color=#0000ff>throws</font> FileNotFoundException {
    <font color=#0000ff>super</font>(
      <font color=#0000ff>new</font> BufferedInputStream(
        <font color=#0000ff>new</font> FileInputStream(filename)));
  }
  <font color=#0000ff>public</font> InFile(File file)
    <font color=#0000ff>throws</font> FileNotFoundException {
    <font color=#0000ff>this</font>(file.getPath());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both the <B>String</B> versions of
the constructor and the <B>File</B> versions are included, to parallel the
creation of a <B>FileInputStream</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now you can reduce your chances of
repetitive stress syndrome while creating files, as seen in the
example.</FONT><BR></P></DIV>
<A NAME="Heading326"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
8. Formatted file output
shorthand<BR><A NAME="Index1146"></A><A NAME="Index1147"></A><A NAME="Index1148"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The same kind of approach can be
taken to create a <B>PrintStream</B> that writes to a buffered file.
Here&#8217;s the extension to <B>com.bruceeckel.tools</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PrintFile.java</font>
<font color=#009900>// Shorthand class for opening an output file</font>
<font color=#009900>// for human-readable output.</font>
<font color=#0000ff>package</font> com.bruceeckel.tools;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrintFile <font color=#0000ff>extends</font> PrintStream {
  <font color=#0000ff>public</font> PrintFile(String filename)
    <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>super</font>(
      <font color=#0000ff>new</font> BufferedOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(filename)));
  }
  <font color=#0000ff>public</font> PrintFile(File file)
    <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>this</font>(file.getPath());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that it is not possible for a
constructor to catch an exception that&#8217;s thrown by a base-class
constructor.</FONT><BR></P></DIV>
<A NAME="Heading327"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
9. Data file output
shorthand<BR><A NAME="Index1149"></A><A NAME="Index1150"></A><A NAME="Index1151"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, the same kind of shorthand
can create a buffered output file for data storage (as opposed to human-readable
storage):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: OutFile.java</font>
<font color=#009900>// Shorthand class for opening an output file</font>
<font color=#009900>// for data storage.</font>
<font color=#0000ff>package</font> com.bruceeckel.tools;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> OutFile <font color=#0000ff>extends</font> DataOutputStream {
  <font color=#0000ff>public</font> OutFile(String filename)
    <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>super</font>(
      <font color=#0000ff>new</font> BufferedOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(filename)));
  }
  <font color=#0000ff>public</font> OutFile(File file)
    <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>this</font>(file.getPath());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is curious (and unfortunate)
that the Java library designers didn&#8217;t think to provide these conveniences
as part of their
standard.</FONT><A NAME="_Toc375545397"></A><A NAME="_Toc408018624"></A><BR></P></DIV>
<A NAME="Heading328"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Reading from standard
input<BR><A NAME="Index1152"></A><A NAME="Index1153"></A><A NAME="Index1154"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Following the approach pioneered in
Unix of &#8220;standard input,&#8221; &#8220;standard output,&#8221; and
&#8220;standard error output,&#8221; Java has
<A NAME="Index1155"></A><A NAME="Index1156"></A><B>System.in</B>,
<A NAME="Index1157"></A><A NAME="Index1158"></A><B>System.out,</B> and
<A NAME="Index1159"></A><A NAME="Index1160"></A><B>System.err</B>. Throughout
the book you&#8217;ve seen how to write to standard output using
<B>System.out,</B> which is already pre-wrapped as a <B>PrintStream</B> object.
<B>System.err</B> is likewise a <B>PrintStream</B>, but <B>System.in</B> is a
raw <B>InputStream</B>, with no wrapping. This means that while you can use
<B>System.out</B> and <B>System.err</B> right away, <B>System.in</B> must be
wrapped before you can read from it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Typically, you&#8217;ll want to
read input a line at a time using <B>readLine(&#160;)</B>, so you&#8217;ll want
to wrap <B>System.in</B> in a <B>DataInputStream</B>. This is the
&#8220;old&#8221; Java 1.0<A NAME="Index1161"></A> way to do line input. A bit
later in the chapter you&#8217;ll see the Java 1.1<A NAME="Index1162"></A>
solution. Here&#8217;s an example that simply echoes each line that you type
in:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Echo.java</font>
<font color=#009900>// How to read from standard input</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Echo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    DataInputStream in =
      <font color=#0000ff>new</font> DataInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(System.in));
    String s;
    <font color=#0000ff>try</font> {
      <font color=#0000ff>while</font>((s = in.readLine()).length() != 0)
        System.out.println(s);
      <font color=#009900>// An empty line terminates the program</font>
    } <font color=#0000ff>catch</font>(IOException e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The reason for the <B>try</B> block
is that <A NAME="Index1163"></A><A NAME="Index1164"></A><B>readLine(&#160;)</B>
can throw an <B>IOException</B>. Note that <B>System.in</B> should also be
buffered, as with most streams</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s a bit inconvenient that
you&#8217;re forced to wrap <B>System.in</B> in a <B>DataInputStream</B> in each
program, but perhaps it was designed this way to allow maximum
flexibility.</FONT><A NAME="_Toc408018625"></A><BR></P></DIV>
<A NAME="Heading329"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Piped streams</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1165"></A><A NAME="Index1166"></A><B>PipedInputStream</B> and
<A NAME="Index1167"></A><A NAME="Index1168"></A><B>PipedOutputStream</B> have
been mentioned only briefly in this chapter. This is not to suggest that they
aren&#8217;t useful, but their value is not apparent until you begin to
understand multithreading, since the piped streams are used to communicate
between threads. This is covered along with an example in Chapter
14.</FONT><A NAME="_Toc375545398"></A><A NAME="_Toc408018626"></A><BR></P></DIV>
<A NAME="Heading330"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
StreamTokenizer</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although
<A NAME="Index1169"></A><A NAME="Index1170"></A><B>StreamTokenizer</B> is not
derived from <B>InputStream</B> or <B>OutputStream</B>, it works only with
<B>InputStream</B> objects, so it rightfully belongs in the IO portion of the
library.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>StreamTokenizer</B> class is
used to break any <B>InputStream</B> into a sequence of<A NAME="Index1171"></A>
&#8220;tokens,&#8221; which are bits of text delimited by whatever you choose.
For example, your tokens could be words, and then they would be delimited by
white space and punctuation. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider a program to count the
occurrence of words in a text file:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SortedWordCount.java</font>
<font color=#009900>// Counts words in a file, outputs</font>
<font color=#009900>// results in sorted form.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> c08.*; <font color=#009900>// Contains StrSortVector</font>

<font color=#0000ff>class</font> Counter {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 1;
  <font color=#0000ff>int</font> read() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>void</font> increment() { i++; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SortedWordCount {
  <font color=#0000ff>private</font> FileInputStream file;
  <font color=#0000ff>private</font> StreamTokenizer st;
  <font color=#0000ff>private</font> Hashtable counts = <font color=#0000ff>new</font> Hashtable();
  SortedWordCount(String filename)
    <font color=#0000ff>throws</font> FileNotFoundException {
    <font color=#0000ff>try</font> {
      file = <font color=#0000ff>new</font> FileInputStream(filename);
      st = <font color=#0000ff>new</font> StreamTokenizer(file);
      st.ordinaryChar('.');
      st.ordinaryChar('-');
    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.out.println(
        <font color=#004488>"Could not open "</font> + filename);
      <font color=#0000ff>throw</font> e;
    }
  }
  <font color=#0000ff>void</font> cleanup() {
    <font color=#0000ff>try</font> {
      file.close();
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(
        <font color=#004488>"file.close() unsuccessful"</font>);
    }
  }
  <font color=#0000ff>void</font> countWords() {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>while</font>(st.nextToken() !=
        StreamTokenizer.TT_EOF) {
        String s;
        <font color=#0000ff>switch</font>(st.ttype) {
          <font color=#0000ff>case</font> StreamTokenizer.TT_EOL:
            s = <font color=#0000ff>new</font> String(<font color=#004488>"EOL"</font>);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_NUMBER:
            s = Double.toString(st.nval);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_WORD:
            s = st.sval; <font color=#009900>// Already a String</font>
            <font color=#0000ff>break</font>;
          <font color=#0000ff>default</font>: <font color=#009900>// single character in ttype</font>
            s = String.valueOf((<font color=#0000ff>char</font>)st.ttype);
        }
        <font color=#0000ff>if</font>(counts.containsKey(s))
          ((Counter)counts.get(s)).increment();
        <font color=#0000ff>else</font>
          counts.put(s, <font color=#0000ff>new</font> Counter());
      }
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(
        <font color=#004488>"st.nextToken() unsuccessful"</font>);
    }
  }
  Enumeration values() {
    <font color=#0000ff>return</font> counts.elements();
  }
  Enumeration keys() { <font color=#0000ff>return</font> counts.keys(); }
  Counter getCounter(String s) {
    <font color=#0000ff>return</font> (Counter)counts.get(s);
  }
  Enumeration sortedKeys() {
    Enumeration e = counts.keys();
    StrSortVector sv = <font color=#0000ff>new</font> StrSortVector();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      sv.addElement((String)e.nextElement());
    <font color=#009900>// This call forces a sort:</font>
    <font color=#0000ff>return</font> sv.elements();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      SortedWordCount wc =
        <font color=#0000ff>new</font> SortedWordCount(args[0]);
      wc.countWords();
      Enumeration keys = wc.sortedKeys();
      <font color=#0000ff>while</font>(keys.hasMoreElements()) {
        String key = (String)keys.nextElement();
        System.out.println(key + <font color=#004488>": "</font>
                 + wc.getCounter(key).read());
      }
      wc.cleanup();
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It makes sense to present these in
a sorted form, but since Java 1.0<A NAME="Index1172"></A> and Java
1.1<A NAME="Index1173"></A> don&#8217;t have any sorting methods, that will have
to be mixed in. This is easy enough to do with a <B>StrSortVector.</B> (This was
created in Chapter 8, and is part of the package created in that chapter.
Remember that the starting directory for all the subdirectories in this book
must be in your class path for the program to compile
successfully.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To open the file, a
<B>FileInputStream</B> is used, and to turn the file into words a
<B>StreamTokenizer</B> is created from the <B>FileInputStream</B>. In
<B>StreamTokenizer</B>, there is a default list of separators, and you can add
more with a set of methods. Here, <B>ordinaryChar(&#160;)</B> is used to say
&#8220;This character has no significance that I&#8217;m interested in,&#8221;
so the parser doesn&#8217;t include it as part of any of the words that it
creates. For example, saying <B>st.ordinaryChar('.')</B> means that periods will
not be included as parts of the words that are parsed. You can find more
information in the online documentation that comes with Java.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>countWords(&#160;)</B>, the
tokens are pulled one at a time from the stream, and the <B>ttype</B>
information is used to determine what to do with each token, since a token can
be an end-of-line, a number, a string, or a single character.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once a token is found, the
<A NAME="Index1174"></A><B>Hashtable counts</B> is queried to see if it already
contains the token as a key. If it does, the corresponding <B>Counter</B> object
is incremented to indicate that another instance of this word has been found. If
not, a new <B>Counter</B> is created &#8211; since the <B>Counter</B>
constructor initializes its value to one, this also acts to count the
word.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SortedWordCount</B> is not a
type of <B>Hashtable</B>, so it wasn&#8217;t inherited. It performs a specific
type of functionality, so even though the <B>keys(&#160;)</B> and
<B>values(&#160;)</B> methods must be re-exposed, that still doesn&#8217;t mean
that <A NAME="Index1175"></A><A NAME="Index1176"></A>inheritance should be used
since a number of <B>Hashtable</B> methods are inappropriate here. In addition,
other methods like <B>getCounter(&#160;)</B>, which get the <B>Counter</B> for a
particular <B>String</B>, and <B>sortedKeys(&#160;)</B>, which produces an
<B>Enumeration</B>, finish the change in the shape of
<B>SortedWordCount</B>&#8217;s interface.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B> you can see
the use of a <B>SortedWordCount</B> to open and count the words in a file
&#8211; it just takes two lines of code. Then an enumeration to a sorted list of
keys (words) is extracted, and this is used to pull out each key and associated
<B>Count</B>. Note that the call to <B>cleanup(&#160;)</B> is necessary to
ensure that the file is closed.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A second example using
<B>StreamTokenizer</B> can be found in Chapter
17.</FONT><A NAME="_Toc375545399"></A><A NAME="_Toc408018627"></A><BR></P></DIV>
<A NAME="Heading331"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
StringTokenizer</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although it isn&#8217;t part of the
IO library, the <B>StringTokenizer</B> has sufficiently similar functionality to
<B>StreamTokenizer</B> that it will be described here.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1177"></A><B>StringTokenizer</B> returns the tokens within a
string one at a time. These tokens are consecutive characters delimited by tabs,
spaces, and newlines. Thus, the tokens of the string &#8220;Where is my
cat?&#8221; are &#8220;Where&#8221;, &#8220;is&#8221;, &#8220;my&#8221;, and
&#8220;cat?&#8221; Like the <B>StreamTokenizer</B>,<B> </B>you can tell the
<B>StringTokenizer</B> to break up the input in any way that you want, but with
<B>StringTokenizer </B>you do this by passing a second argument to the
constructor, which is a <B>String </B>of the delimiters you wish to use. In
general, if you need more sophistication, use a
<B>StreamTokenizer</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You ask a <B>StringTokenizer</B>
object for the next token in the string using the <B>nextToken(&#160;)</B>
method, which either returns the token or an empty string to indicate that no
tokens remain. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example, the following
program performs a limited analysis of a sentence, looking for key phrase
sequences to indicate whether happiness or sadness is implied. </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: AnalyzeSentence.java</font>
<font color=#009900>// Look for particular sequences</font>
<font color=#009900>// within sentences.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AnalyzeSentence {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    analyze(<font color=#004488>"I am happy about this"</font>);
    analyze(<font color=#004488>"I am not happy about this"</font>);
    analyze(<font color=#004488>"I am not! I am happy"</font>);
    analyze(<font color=#004488>"I am sad about this"</font>);
    analyze(<font color=#004488>"I am not sad about this"</font>);
    analyze(<font color=#004488>"I am not! I am sad"</font>);
    analyze(<font color=#004488>"Are you happy about this?"</font>);
    analyze(<font color=#004488>"Are you sad about this?"</font>);
    analyze(<font color=#004488>"It's you! I am happy"</font>);
    analyze(<font color=#004488>"It's you! I am sad"</font>);
  }
  <font color=#0000ff>static</font> StringTokenizer st;
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> analyze(String s) {
    prt(<font color=#004488>"\nnew sentence &gt;&gt; "</font> + s);
    <font color=#0000ff>boolean</font> sad = <font color=#0000ff>false</font>;
    st = <font color=#0000ff>new</font> StringTokenizer(s);
    <font color=#0000ff>while</font> (st.hasMoreTokens()) {
      String token = next();
      <font color=#009900>// Look until you find one of the</font>
      <font color=#009900>// two starting tokens:</font>
      <font color=#0000ff>if</font>(!token.equals(<font color=#004488>"I"</font>) &amp;&amp;
         !token.equals(<font color=#004488>"Are"</font>))
        <font color=#0000ff>continue</font>; <font color=#009900>// Top of while loop</font>
      <font color=#0000ff>if</font>(token.equals(<font color=#004488>"I"</font>)) {
        String tk2 = next();
        <font color=#0000ff>if</font>(!tk2.equals(<font color=#004488>"am"</font>)) <font color=#009900>// Must be after I</font>
          <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
        <font color=#0000ff>else</font> {
          String tk3 = next();
          <font color=#0000ff>if</font>(tk3.equals(<font color=#004488>"sad"</font>)) {
            sad = <font color=#0000ff>true</font>;
            <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
          }
          <font color=#0000ff>if</font> (tk3.equals(<font color=#004488>"not"</font>)) {
            String tk4 = next();
            <font color=#0000ff>if</font>(tk4.equals(<font color=#004488>"sad"</font>))
              <font color=#0000ff>break</font>; <font color=#009900>// Leave sad false</font>
            <font color=#0000ff>if</font>(tk4.equals(<font color=#004488>"happy"</font>)) {
              sad = <font color=#0000ff>true</font>;
              <font color=#0000ff>break</font>;
            }
          }
        }
      }
      <font color=#0000ff>if</font>(token.equals(<font color=#004488>"Are"</font>)) {
        String tk2 = next();
        <font color=#0000ff>if</font>(!tk2.equals(<font color=#004488>"you"</font>))
          <font color=#0000ff>break</font>; <font color=#009900>// Must be after Are</font>
        String tk3 = next();
        <font color=#0000ff>if</font>(tk3.equals(<font color=#004488>"sad"</font>))
          sad = <font color=#0000ff>true</font>;
        <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
      }
    }
    <font color=#0000ff>if</font>(sad) prt(<font color=#004488>"Sad detected"</font>);
  }
  <font color=#0000ff>static</font> String next() {
    <font color=#0000ff>if</font>(st.hasMoreTokens()) {
      String s = st.nextToken();
      prt(s);
      <font color=#0000ff>return</font> s;
    } 
    <font color=#0000ff>else</font>
      <font color=#0000ff>return</font> <font color=#004488>""</font>;
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) {
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For each string being analyzed, a
<B>while</B> loop is entered and tokens are pulled off the string. Notice the
first <B>if</B> statement, which says to <B>continue</B> (go back to the
beginning of the loop and start again) if the token is neither an
&#8220;I&#8221; nor an &#8220;Are.&#8221; </FONT><FONT FACE="Georgia">This
means that it will get tokens until an &#8220;I&#8221; or an &#8220;Are&#8221;
is found. You might think to use the <B>==</B> instead of the
<A NAME="Index1178"></A><A NAME="Index1179"></A><B>equals(&#160;)</B> method,
but that won&#8217;t work correctly, since <B>==</B> compares handle values
while <B>equals(&#160;)</B> compares contents.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The logic of the rest of the
<B>analyze(&#160;)</B> method is that the pattern that&#8217;s being searched
for is &#8220;I am sad,&#8221; &#8220;I am not happy,&#8221; or &#8220;Are you
sad?&#8221; Without the <B>break</B> statement, the code for this would be even
messier than it is. You should be aware that a typical parser (this is a
primitive example of one) normally has a table of these tokens and a piece of
code that moves through the states in the table as new tokens are
read.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You should think of the
<B>StringTokenizer</B> only as shorthand for a simple and specific kind of
<B>StreamTokenizer</B>. However, if you have a <B>String</B> that you want to
tokenize and <B>StringTokenizer</B> is too limited, all you have to do is turn
it into a stream with <B>StringBufferInputStream</B> and then use that to create
a much more powerful
<B>StreamTokenizer</B>.</FONT><A NAME="_Toc375545400"></A><A NAME="_Toc408018628"></A><BR></P></DIV>
<A NAME="Heading332"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Java 1.1 IO streams<BR><A NAME="Index1180"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point you might be
scratching your head, wondering if there is another design for IO streams that
could require <I>more</I> typing. Could someone have come up with an odder
design?&#8221; Prepare yourself: Java 1.1 makes some significant modifications
to the IO stream library. When you see the
<A NAME="Index1181"></A><A NAME="Index1182"></A><B>Reader</B> and
<A NAME="Index1183"></A><A NAME="Index1184"></A><B>Writer</B> classes your first
thought (like mine) might be that these were meant to replace the
<B>InputStream</B> and <B>OutputStream</B> classes. But that&#8217;s not the
case. Although some aspects of the original streams library are deprecated (if
you use them you will receive a warning from the compiler), the old streams have
been left in for backwards compatibility and:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	New classes have been put into the old
hierarchy, so it&#8217;s obvious that Sun is not abandoning the old
streams.</FONT><LI><FONT FACE="Georgia">	There are times when you&#8217;re
supposed to use classes in the old hierarchy <I>in combination</I> with classes
in the new hierarchy and to accomplish this there are &#8220;bridge&#8221;
classes:
<A NAME="Index1185"></A><A NAME="Index1186"></A><B>InputStreamReader</B>
converts an <B>InputStream </B>to a <B>Reader </B>and
<A NAME="Index1187"></A><A NAME="Index1188"></A><B>OutputStreamWriter</B>
converts an <B>OutputStream</B> to a
<B>Writer</B>.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a
result there are situations in which you have <I>more</I> layers of wrapping
with the new IO stream library than with the old. Again, this is a drawback of
the decorator pattern &#8211; the price you pay for added
flexibility.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most important reason for
adding the <B>Reader</B> and <B>Writer</B> hierarchies in Java
1.1<A NAME="Index1189"></A> is for
<A NAME="Index1190"></A><A NAME="Index1191"></A>internationalization. The old IO
stream hierarchy supports only 8-bit byte streams and doesn&#8217;t handle the
16-bit Unicode characters well. Since Unicode is used for internationalization
(and Java&#8217;s native <B>char </B>is 16-bit
<A NAME="Index1192"></A><A NAME="Index1193"></A>Unicode), the <B>Reader</B> and
<B>Writer</B> hierarchies were added to support Unicode in all IO operations. In
addition, the new libraries are designed for faster operations than the
old.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As is the practice in this book, I
will attempt to provide an overview of the classes but assume that you will use
online documentation to determine all the details, such as the exhaustive list
of methods.</FONT><A NAME="_Toc408018629"></A><BR></P></DIV>
<A NAME="Heading333"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Sources and sinks of data</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Almost all of the Java
1.0<A NAME="Index1194"></A> IO stream classes have corresponding Java
1.1<A NAME="Index1195"></A> classes to provide native Unicode manipulation. It
would be easiest to say &#8220;Always use the new classes, never use the old
ones,&#8221; but things are not that simple. Sometimes you are forced into using
the Java 1.0 IO stream classes because of the library design; in particular, the
<B>java.util.zip</B> libraries are new additions to the old stream library and
they rely on old stream components. So the most sensible approach to take is to
<I>try</I> to use the <B>Reader</B> and <B>Writer</B> classes whenever you can,
and you&#8217;ll discover the situations when you have to drop back into the old
libraries because your code won&#8217;t compile.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here is a table that shows the
correspondence between the sources and sinks of information (that is, where the
data physically comes from or goes to) in the old and new libraries.
<A NAME="Index1196"></A><A NAME="Index1197"></A><A NAME="Index1198"></A><A NAME="Index1199"></A><A NAME="Index1200"></A><A NAME="Index1201"></A><A NAME="Index1202"></A><A NAME="Index1203"></A><A NAME="Index1204"></A><A NAME="Index1205"></A><A NAME="Index1206"></A><A NAME="Index1207"></A><A NAME="Index1208"></A><A NAME="Index1209"></A><A NAME="Index1210"></A><A NAME="Index1211"></A><A NAME="Index1212"></A><A NAME="Index1213"></A><A NAME="Index1214"></A><A NAME="Index1215"></A><A NAME="Index1216"></A><A NAME="Index1217"></A><A NAME="Index1218"></A><A NAME="Index1219"></A><A NAME="Index1220"></A><A NAME="Index1221"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sources &amp;
Sinks:</FONT><BR><FONT FACE="Georgia">Java 1.0 class</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Corresponding Java 1.1
class</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Reader</B>
</FONT><BR><FONT FACE="Georgia">converter:
<B>InputStreamReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Writer</B>
</FONT><BR><FONT FACE="Georgia">converter:
<B>OutputStreamWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringBufferInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(no corresponding
class)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArrayInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CharArrayReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArrayOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CharArrayWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, you&#8217;ll find that
the interfaces in the old library components and the new ones are similar if not
identical.</FONT><A NAME="_Toc408018630"></A><BR></P></DIV>
<A NAME="Heading334"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Modifying stream behavior</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Java
1.0<A NAME="Index1222"></A>, streams were adapted for particular needs using
&#8220;decorator&#8221; subclasses of <B>FilterInputStream</B> and
<B>FilterOutputStream.</B> Java 1.1<A NAME="Index1223"></A> IO streams continues
the use of this idea, but the model of deriving all of the decorators from the
same &#8220;filter&#8221; base class is not followed. This can make it a bit
confusing if you&#8217;re trying to understand it by looking at the class
hierarchy.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the following table, the
correspondence is a rougher approximation than in the previous table. The
difference is because of the class organization: while
<B>BufferedOutputStream</B> is a subclass of <B>FilterOutputStream</B>,
<B>BufferedWriter</B> is <I>not</I> a subclass of <B>FilterWriter</B> (which,
even though it is <B>abstract</B>, has no subclasses and so appears to have been
put in either as a placeholder or simply so you wouldn&#8217;t wonder where it
was). However, the interfaces to the classes are quite a close match and
it&#8217;s apparent that you&#8217;re supposed to use the new versions instead
of the old whenever possible (that is, except in cases where you&#8217;re forced
to produce a <B>Stream</B> instead of a <B>Reader</B> or <B>Writer</B>).
<A NAME="Index1224"></A><A NAME="Index1225"></A><A NAME="Index1226"></A><A NAME="Index1227"></A><A NAME="Index1228"></A><A NAME="Index1229"></A><A NAME="Index1230"></A><A NAME="Index1231"></A><A NAME="Index1232"></A><A NAME="Index1233"></A><A NAME="Index1234"></A><A NAME="Index1235"></A><A NAME="Index1236"></A><A NAME="Index1237"></A><A NAME="Index1238"></A><A NAME="Index1239"></A><A NAME="Index1240"></A><A NAME="Index1241"></A><A NAME="Index1242"></A><A NAME="Index1243"></A><A NAME="Index1244"></A><A NAME="Index1245"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=139 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Filters:</FONT><BR><FONT FACE="Georgia">Java
1.0 class</FONT><BR></P></DIV>
</TH>
<TH WIDTH=198 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Corresponding Java 1.1
class</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterWriter</B>
(<B>abstract</B> class with no subclasses)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedReader</B></FONT><BR><FONT FACE="Georgia">(also
has <B>readLine(&#160;)</B>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DataInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">use
<B>DataInputStream</B></FONT><BR><FONT FACE="Georgia">(Except when you
need to use <B>readLine(&#160;)</B>, when you should use a
<B>BufferedReader</B>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LineNumberInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LineNumberReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StreamTokenizer</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StreamTokenizer</B></FONT><BR><FONT FACE="Georgia">(use
constructor that takes a <B>Reader</B> instead)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PushBackInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PushBackReader</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s one direction
that&#8217;s quite clear: Whenever you want to use <B>readLine(&#160;)</B>, you
shouldn&#8217;t do it with a <B>DataInputStream</B> any more (this is met with a
deprecation message at compile time), but instead use a <B>BufferedReader</B>.
Other than this, <B>DataInputStream</B> is still a &#8220;preferred&#8221;
member of the Java 1.1 IO library.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make the transition to using a
<B>PrintWriter</B> easier, it has constructors that take any <B>OutputStream</B>
object. However, <B>PrintWriter</B> has no more support for formatting than
<B>PrintStream</B> does; the interfaces are virtually the
same.</FONT><A NAME="_Toc408018631"></A><BR></P></DIV>
<A NAME="Heading335"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Unchanged Classes</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Apparently, the Java library
designers felt that they got some of the classes right the first time so there
were no changes to these and you can go on using them as they are:
<A NAME="Index1246"></A><A NAME="Index1247"></A><A NAME="Index1248"></A><A NAME="Index1249"></A><A NAME="Index1250"></A><A NAME="Index1251"></A><A NAME="Index1252"></A><A NAME="Index1253"></A><A NAME="Index1254"></A><A NAME="Index1255"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=166 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.0 classes without
corresponding Java 1.1 classes</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DataOutputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>File</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>RandomAccessFile</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SequenceInputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>DataOutputStream</B>, in
particular, is used without change, so for storing and retrieving data in a
transportable format you&#8217;re forced to stay in the <B>InputStream</B> and
<B>OutputStream</B> hierarchies.</FONT><A NAME="_Toc408018632"></A><BR></P></DIV>
<A NAME="Heading336"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
An example</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To see the effect of the new
classes, let&#8217;s look at the appropriate portion of the
<B>IOStreamDemo.java</B> example modified to use the <B>Reader</B> and
<B>Writer</B> classes:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: NewIODemo.java</font>
<font color=#009900>// Java 1.1 IO typical usage</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> NewIODemo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#009900>// 1. Reading input by lines:</font>
      BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(args[0]));
      String s, s2 = <font color=#0000ff>new</font> String();
      <font color=#0000ff>while</font>((s = in.readLine())!= <font color=#0000ff>null</font>)
        s2 += s + <font color=#004488>"\n"</font>;
      in.close();

      <font color=#009900>// 1b. Reading standard input:</font>
      BufferedReader stdin =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(System.in));      
      System.out.print(<font color=#004488>"Enter a line:"</font>);
      System.out.println(stdin.readLine());

      <font color=#009900>// 2. Input from memory</font>
      StringReader in2 = <font color=#0000ff>new</font> StringReader(s2);
      <font color=#0000ff>int</font> c;
      <font color=#0000ff>while</font>((c = in2.read()) != -1)
        System.out.print((<font color=#0000ff>char</font>)c);

      <font color=#009900>// 3. Formatted memory input</font>
      <font color=#0000ff>try</font> {
        DataInputStream in3 =
          <font color=#0000ff>new</font> DataInputStream(
            <font color=#009900>// Oops: must use deprecated class:</font>
            <font color=#0000ff>new</font> StringBufferInputStream(s2));
        <font color=#0000ff>while</font>(<font color=#0000ff>true</font>)
          System.out.print((<font color=#0000ff>char</font>)in3.readByte());
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(<font color=#004488>"End of stream"</font>);
      }

      <font color=#009900>// 4. Line numbering &amp; file output</font>
      <font color=#0000ff>try</font> {
        LineNumberReader li =
          <font color=#0000ff>new</font> LineNumberReader(
            <font color=#0000ff>new</font> StringReader(s2));
        BufferedReader in4 =
          <font color=#0000ff>new</font> BufferedReader(li);
        PrintWriter out1 =
          <font color=#0000ff>new</font> PrintWriter(
            <font color=#0000ff>new</font> BufferedWriter(
              <font color=#0000ff>new</font> FileWriter(<font color=#004488>"IODemo.out"</font>)));
        <font color=#0000ff>while</font>((s = in4.readLine()) != <font color=#0000ff>null</font> )
          out1.println(
            <font color=#004488>"Line "</font> + li.getLineNumber() + s);
        out1.close();
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(<font color=#004488>"End of stream"</font>);
      }

      <font color=#009900>// 5. Storing &amp; recovering data</font>
      <font color=#0000ff>try</font> {
        DataOutputStream out2 =
          <font color=#0000ff>new</font> DataOutputStream(
            <font color=#0000ff>new</font> BufferedOutputStream(
              <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
        out2.writeDouble(3.14159);
        out2.writeBytes(<font color=#004488>"That was pi"</font>);
        out2.close();
        DataInputStream in5 =
          <font color=#0000ff>new</font> DataInputStream(
            <font color=#0000ff>new</font> BufferedInputStream(
              <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
        BufferedReader in5br =
          <font color=#0000ff>new</font> BufferedReader(
            <font color=#0000ff>new</font> InputStreamReader(in5));
        <font color=#009900>// Must use DataInputStream for data:</font>
        System.out.println(in5.readDouble());
        <font color=#009900>// Can now use the "proper" readLine():</font>
        System.out.println(in5br.readLine());
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(<font color=#004488>"End of stream"</font>);
      }

      <font color=#009900>// 6. Reading and writing random access</font>
      <font color=#009900>// files is the same as before.</font>
      <font color=#009900>// (not repeated here)</font>

    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.out.println(
        <font color=#004488>"File Not Found:"</font> + args[1]);
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(<font color=#004488>"IO Exception"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, you&#8217;ll see that
the conversion is fairly straightforward and the code looks quite similar. There
are some important differences, though. First of all, since random access files
have not changed, section 6 is not repeated.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Section 1 shrinks a bit because if
all you&#8217;re doing is reading line input you need only to wrap a
<B>BufferedReader</B> around a <B>FileReader</B>. Section 1b shows the new way
to wrap <A NAME="Index1256"></A><A NAME="Index1257"></A><B>System.in</B> for
reading
<A NAME="Index1258"></A><A NAME="Index1259"></A><A NAME="Index1260"></A>console
input, and this expands because <B>System.in</B> is a <B>DataInputStream</B> and
<B>BufferedReader</B> needs a <B>Reader</B> argument, so
<B>InputStreamReader</B> is brought in to perform the
translation.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In section 2 you can see that if
you have a <B>String</B> and want to read from it you just use a
<B>StringReader</B> instead of a <B>StringBufferInputStream</B> and the rest of
the code is identical.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Section 3 shows a bug in the design
of the new IO stream library. If you have a <B>String</B> and you want to read
from it, you&#8217;re <I>not</I> supposed to use a
<B>StringBufferInputStream</B> any more. When you compile code involving a
<B>StringBufferInputStream</B> constructor, you get a deprecation message
telling you to not use it. Instead, you&#8217;re supposed to use a
<B>StringReader</B>. However, if you want to do formatted memory input as in
section 3, you&#8217;re forced to use a <B>DataInputStream</B> &#8211; there is
no &#8220;DataReader&#8221; to replace it &#8211; and a <B>DataInputStream</B>
constructor requires an <B>InputStream</B> argument. So you have no choice but
to use the deprecated <B>StringBufferInputStream</B> class. The compiler will
give you a deprecation message but there&#8217;s nothing you can do about
it.</FONT><A NAME="fnB45" HREF="#fn45">[45]</A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Section 4 is a reasonably
straightforward translation from the old streams to the new, with no surprises.
In section 5, you&#8217;re forced to use all the old streams classes because
<B>DataOutputStream</B> and <B>DataInputStream</B> require them and there are no
alternatives. However, you don&#8217;t get any deprecation messages at compile
time. If a stream is deprecated, typically its constructor produces a
deprecation message to prevent you from using the entire class, but in the case
of <B>DataInputStream</B> only the <B>readLine(&#160;)</B> method is deprecated
since you&#8217;re supposed to use a <B>BufferedReader</B> for
<B>readLine(&#160;)</B> (but a <B>DataInputStream</B> for all other formatted
input).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you compare section 5 with that
section in <B>IOStreamDemo.java</B>, you&#8217;ll notice that in <I>this</I>
version, the data is written <I>before</I> the text. That&#8217;s because a bug
was introduced in Java 1.1<A NAME="Index1261"></A>, which is shown in the
following code:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: IOBug.java</font>
<font color=#009900>// Java 1.1 (and higher?) IO Bug</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IOBug {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> Exception {
    DataOutputStream out =
      <font color=#0000ff>new</font> DataOutputStream(
        <font color=#0000ff>new</font> BufferedOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
    out.writeDouble(3.14159);
    out.writeBytes(<font color=#004488>"That was the value of pi\n"</font>);
    out.writeBytes(<font color=#004488>"This is pi</font><font color=#004488>/2:\n"</font>);
    out.writeDouble(3.14159/2);
    out.close();

    DataInputStream in =
      <font color=#0000ff>new</font> DataInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
    BufferedReader inbr =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(in));
    <font color=#009900>// The doubles written BEFORE the line of text</font>
    <font color=#009900>// read back correctly:</font>
    System.out.println(in.readDouble());
    <font color=#009900>// Read the lines of text:</font>
    System.out.println(inbr.readLine());
    System.out.println(inbr.readLine());
    <font color=#009900>// Trying to read the doubles after the line</font>
    <font color=#009900>// produces an end-of-file exception:</font>
    System.out.println(in.readDouble());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It appears that anything you write
after a call to <B>writeBytes(&#160;)</B> is not recoverable. This is a rather
limiting bug, and we can hope that it will be fixed by the time you read this.
You should run the above program to test it; if you don&#8217;t get an exception
and the values print correctly then you&#8217;re out of the
woods.</FONT><A NAME="_Toc408018633"></A><BR></P></DIV>
<A NAME="Heading337"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Redirecting standard IO<BR><A NAME="Index1262"></A><A NAME="Index1263"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1<A NAME="Index1264"></A>
has added methods in class <B>System</B> that allow you to redirect the standard
input, output, and error IO streams using simple static method
calls:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index1265"></A><A NAME="Index1266"></A><FONT FACE="Georgia"><B>setIn(InputStream)
</B></FONT><BR><A NAME="Index1267"></A><A NAME="Index1268"></A><FONT FACE="Georgia"><B>setOut(PrintStream)</B></FONT><BR><A NAME="Index1269"></A><A NAME="Index1270"></A><FONT FACE="Georgia"><B>setErr(PrintStream)
</B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Redirecting output is especially
useful if you suddenly start creating a large amount of output on your screen
and it&#8217;s scrolling past faster than you can read it. Redirecting input is
valuable for a command-line program in which you want to test a particular
user-input sequence repeatedly. Here&#8217;s a simple example that shows the use
of these methods:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Redirecting.java</font>
<font color=#009900>// Demonstrates the use of redirection for </font>
<font color=#009900>// standard IO in Java 1.1</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> Redirecting {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      BufferedInputStream in = 
        <font color=#0000ff>new</font> BufferedInputStream(
          <font color=#0000ff>new</font> FileInputStream(
            <font color=#004488>"Redirecting.java"</font>));
      <font color=#009900>// Produces deprecation message:</font>
      PrintStream out =
        <font color=#0000ff>new</font> PrintStream(
          <font color=#0000ff>new</font> BufferedOutputStream(
            <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.out"</font>)));
      System.setIn(in);
      System.setOut(out);
      System.setErr(out);

      BufferedReader br = 
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(System.in));
      String s;
      <font color=#0000ff>while</font>((s = br.readLine()) != <font color=#0000ff>null</font>)
        System.out.println(s);
      out.close(); <font color=#009900>// Remember this!</font>
    } <font color=#0000ff>catch</font>(IOException e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program attaches standard
input to a file, and redirects standard output and standard error to another
file.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is another example in which a
deprecation message is inevitable. The message you can get when compiling with
the <B>-deprecation </B>flag is: </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><I>Note: The constructor
java.io.PrintStream(java.io.OutputStream)
</I></FONT><BR><FONT FACE="Georgia"><I>has been
deprecated.</I></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, both
<B>System.setOut(&#160;)</B> and <B>System.setErr(&#160;)</B> require a
<B>PrintStream</B> object as an argument, so you are forced to call the
<B>PrintStream</B> constructor. You might wonder, if Java
1.1<A NAME="Index1271"></A> deprecates the entire <B>PrintStream</B> class by
deprecating the constructor, why the library designers, at the same time as they
added this deprecation, also add new methods to <B>System</B> that required a
<B>PrintStream</B> rather than a <B>PrintWriter,</B> which is the new and
preferred replacement. It&#8217;s a
mystery.</FONT><A NAME="_Toc408018634"></A><BR></P></DIV>
<A NAME="Heading338"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Compression<BR><A NAME="Index1272"></A><A NAME="Index1273"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1<A NAME="Index1274"></A>
has also added some classes to support reading and writing streams in a
compressed format. These are wrapped around existing IO classes to provide
compression functionality.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One aspect of these Java 1.1
classes stands out: They are not derived from the new <B>Reader</B> and
<B>Writer</B> classes, but instead are part of the <B>InputStream</B> and
<B>OutputStream</B> hierarchies. So you might be forced to mix the two types of
streams. (Remember that you can use <B>InputStreamReader</B> and
<B>OutputStreamWriter</B> to provide easy conversion between one type and
another.)
<A NAME="Index1275"></A><A NAME="Index1276"></A><A NAME="Index1277"></A><A NAME="Index1278"></A><A NAME="Index1279"></A><A NAME="Index1280"></A><A NAME="Index1281"></A><A NAME="Index1282"></A><A NAME="Index1283"></A><A NAME="Index1284"></A><A NAME="Index1285"></A><A NAME="Index1286"></A><A NAME="Index1287"></A><A NAME="Index1288"></A><A NAME="Index1289"></A><A NAME="Index1290"></A><A NAME="Index1291"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=126 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1 Compression
class</FONT><BR></P></DIV>
</TH>
<TH WIDTH=211 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Function</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CheckedInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>GetCheckSum(&#160;)</B> produces
checksum for any <B>InputStream</B> (not just decompression)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CheckedOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>GetCheckSum(&#160;)</B> produces
checksum for any <B>OutputStream</B> (not just compression)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DeflaterOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Base class for compression
classes</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ZipOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>DeflaterOutputStream </B>that
compresses data into the Zip file format</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>GZIPOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>DeflaterOutputStream </B>that
compresses data into the GZIP file format</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InflaterInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Base class for decompression
classes</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ZipInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>DeflaterInputStream </B>that
Decompresses data that has been stored in the Zip file format</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>GZIPInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>DeflaterInputStream </B>that
decompresses data that has been stored in the GZIP file format</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although there are many compression
algorithms, Zip and GZIP are possibly the most commonly used. Thus you can
easily manipulate your compressed data with the many tools available for reading
and writing these formats.</FONT><A NAME="_Toc408018635"></A><BR></P></DIV>
<A NAME="Heading339"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Simple compression with GZIP</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The GZIP interface is simple and
thus is probably more appropriate when you have a single stream of data that you
want to compress (rather than a collection of dissimilar pieces of data).
Here&#8217;s an example that compresses a single file:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: GZIPcompress.java</font>
<font color=#009900>// Uses Java 1.1 GZIP compression to compress</font>
<font color=#009900>// a file whose name is passed on the command</font>
<font color=#009900>// line.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GZIPcompress {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(args[0]));
      BufferedOutputStream out =
        <font color=#0000ff>new</font> BufferedOutputStream(
          <font color=#0000ff>new</font> GZIPOutputStream(
            <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.gz"</font>)));
      System.out.println(<font color=#004488>"Writing file"</font>);
      <font color=#0000ff>int</font> c;
      <font color=#0000ff>while</font>((c = in.read()) != -1)
        out.write(c);
      in.close();
      out.close();
      System.out.println(<font color=#004488>"Reading file"</font>);
      BufferedReader in2 =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(
            <font color=#0000ff>new</font> GZIPInputStream(
              <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.gz"</font>))));
      String s;
      <font color=#0000ff>while</font>((s = in2.readLine()) != <font color=#0000ff>null</font>)
        System.out.println(s);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of the compression classes
is straightforward &#8211; you simply wrap your output stream in a
<B>GZIPOutputStream</B> or <B>ZipOutputStream</B> and your input stream in a
<B>GZIPInputStream</B> or <B>ZipInputStream</B>. All else is ordinary IO reading
and writing. This is, however, a good example of when you&#8217;re forced to mix
the old IO streams with the new: <B>in</B> uses the <B>Reader</B> classes,
whereas <B>GZIPOutputStream</B>&#8217;s constructor can accept only an
<B>OutputStream</B> object, not a <B>Writer</B>
object.</FONT><A NAME="_Toc408018636"></A><BR></P></DIV>
<A NAME="Heading340"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Multi-file storage with Zip</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java
1.1<A NAME="Index1292"></A> library that supports the Zip format is much more
extensive. With it you can easily store multiple files, and there&#8217;s even a
separate class to make the process of reading a Zip file easy. The library uses
the standard Zip format so that it works seamlessly with all the tools currently
downloadable on the Internet. The following example has the same form as the
previous example, but it handles as many command-line arguments as you want. In
addition, it shows the use of the <A NAME="Index1293"></A><B>Checksum</B>
classes to calculate and verify the checksum for the file. There are two
<B>Checksum</B> types: <A NAME="Index1294"></A><B>Adler32</B> (which is faster)
and <A NAME="Index1295"></A><B>CRC32</B> (which is slower but slightly more
accurate).</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ZipCompress.java</font>
<font color=#009900>// Uses Java 1.1 Zip compression to compress</font>
<font color=#009900>// any number of files whose names are passed</font>
<font color=#009900>// on the command line.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ZipCompress {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      FileOutputStream f =
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.zip"</font>);
      CheckedOutputStream csum =
        <font color=#0000ff>new</font> CheckedOutputStream(
          f, <font color=#0000ff>new</font> Adler32());
      ZipOutputStream out =
        <font color=#0000ff>new</font> ZipOutputStream(
          <font color=#0000ff>new</font> BufferedOutputStream(csum));
      out.setComment(<font color=#004488>"A test of Java Zipping"</font>);
      <font color=#009900>// Can't read the above comment, though</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; args.length; i++) {
        System.out.println(
          <font color=#004488>"Writing file "</font> + args[i]);
        BufferedReader in =
          <font color=#0000ff>new</font> BufferedReader(
            <font color=#0000ff>new</font> FileReader(args[i]));
        out.putNextEntry(<font color=#0000ff>new</font> ZipEntry(args[i]));
        <font color=#0000ff>int</font> c;
        <font color=#0000ff>while</font>((c = in.read()) != -1)
          out.write(c);
        in.close();
      }
      out.close();
      <font color=#009900>// Checksum valid only after the file</font>
      <font color=#009900>// has been closed!</font>
      System.out.println(<font color=#004488>"Checksum: "</font> +
        csum.getChecksum().getValue());
      <font color=#009900>// Now extract the files:</font>
      System.out.println(<font color=#004488>"Reading file"</font>);
      FileInputStream fi =
         <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.zip"</font>);
      CheckedInputStream csumi =
        <font color=#0000ff>new</font> CheckedInputStream(
          fi, <font color=#0000ff>new</font> Adler32());
      ZipInputStream in2 =
        <font color=#0000ff>new</font> ZipInputStream(
          <font color=#0000ff>new</font> BufferedInputStream(csumi));
      ZipEntry ze;
      System.out.println(<font color=#004488>"Checksum: "</font> +
        csumi.getChecksum().getValue());
      <font color=#0000ff>while</font>((ze = in2.getNextEntry()) != <font color=#0000ff>null</font>) {
        System.out.println(<font color=#004488>"Reading file "</font> + ze);
        <font color=#0000ff>int</font> x;
        <font color=#0000ff>while</font>((x = in2.read()) != -1)
          System.out.write(x);
      }
      in2.close();
      <font color=#009900>// Alternative way to open and read</font>
      <font color=#009900>// zip files:</font>
      ZipFile zf = <font color=#0000ff>new</font> ZipFile(<font color=#004488>"test.zip"</font>);
      Enumeration e = zf.entries();
      <font color=#0000ff>while</font>(e.hasMoreElements()) {
        ZipEntry ze2 = (ZipEntry)e.nextElement();
        System.out.println(<font color=#004488>"File: "</font> + ze2);
        <font color=#009900>// ... and extract the data as before</font>
      }
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For each file to add to the
archive, you must call <B>putNextEntry(&#160;) </B>and pass it a
<A NAME="Index1296"></A><A NAME="Index1297"></A><B>ZipEntry </B>object. The
<B>ZipEntry</B> object contains an extensive interface that allows you to get
and set all the data available on that particular entry in your Zip file: name,
compressed and uncompressed sizes, date, CRC checksum, extra field data,
comment, compression method, and whether it&#8217;s a directory entry. However,
even though the Zip format has a way to set a password, this is not supported in
Java&#8217;s Zip library. And although <B>CheckedInputStream</B> and
<B>CheckedOutputStream</B> support both <B>Adler32</B> and <B>CRC32</B>
checksums, the <B>ZipEntry</B> class supports only an interface for CRC. This is
a restriction of the underlying Zip format, but it might limit you from using
the faster <B>Adler32</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To extract files,
<B>ZipInputStream</B> has a <B>getNextEntry(&#160;)</B> method that returns the
next <B>ZipEntry</B> if there is one. As a more succinct alternative, you can
read the file using a <B>ZipFile</B> object, which has a method
<B>entries(&#160;) </B>to return an <B>Enumeration</B> to the
<B>ZipEntries</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In order to read the checksum you
must somehow have access to the associated <B>Checksum</B> object. Here, a
handle to the <B>CheckedOutputStream</B> and <B>CheckedInputStream</B> objects
is retained, but you could also just hold onto a handle to the <B>Checksum</B>
object.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A baffling method in Zip streams is
<B>setComment(&#160;)</B>. As shown above, you can set a comment when
you&#8217;re writing a file, but there&#8217;s no way to recover the comment in
the <B>ZipInputStream</B>. Comments appear to be supported fully on an
entry-by-entry basis only via <B>ZipEntry</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, you are not limited to
files when using the <B>GZIP</B> or <B>Zip</B> libraries &#8211; you can
compress anything, including data to be sent through a network
connection.</FONT><A NAME="_Toc408018637"></A><BR></P></DIV>
<A NAME="Heading341"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The Java archive (jar) utility</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Zip format is also used in the
<A NAME="Index1298"></A><A NAME="Index1299"></A>Java 1.1 JAR (Java ARchive) file
format, which is a way to collect a group of files into a single compressed
file, just like Zip. However, like everything else in Java, JAR files are
cross-platform so you don&#8217;t need to worry about platform issues. You can
also include audio and image files as well as class files. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">JAR files are particularly helpful
when you deal with the Internet. Before JAR files, your Web browser would have
to make repeated requests of a Web server in order to download all of the files
that make up an applet. In addition, each of these files was uncompressed. By
combining all of the files for a particular applet into a single JAR file, only
one server request is necessary and the transfer is faster because of
compression. And each entry in a JAR file can be digitally signed for security
(refer to the Java documentation for details).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A JAR file consists of a single
file containing a collection of zipped files along with a
&#8220;<A NAME="Index1300"></A>manifest&#8221; that describes them. (You can
create your own manifest file; otherwise the <B>jar </B>program will do it for
you.) You can find out more about JAR manifests in the online
documentation.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>jar</B> utility that comes
with Sun&#8217;s JDK automatically compresses the files of your choice. You
invoke it on the command line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar [options] destination [manifest] inputfile(s)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The options are simply a collection
of letters (no hyphen or any other indicator is necessary). These
are:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>c</B> </FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Creates a new or empty archive.
</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>t</B> </FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Lists the table of contents.
</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>x</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Extracts all files</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>x file</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Extracts the named file
</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>f</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Says: &#8220;I&#8217;m going to
give you the name of the file.&#8221; If you don&#8217;t use this, <B>jar
</B>assumes that its input will come from standard input, or, if it is creating
a file, its output will go to standard output.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>m</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Says that the first argument will
be the name of the user-created manifest file</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>v</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Generates verbose output describing
what <B>jar</B> is doing</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>O</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Only store the files; doesn&#8217;t
compress the files (use to create a JAR file that you can put in your
classpath)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>M</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Don&#8217;t automatically create a
manifest file</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If a subdirectory is included in
the files to be put into the JAR file, that subdirectory is automatically added,
including all of its subdirectories, etc. Path information is also
preserved.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here are some typical ways to
invoke <B>jar</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cf myJarFile.jar *.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This creates a JAR file called
<B>myJarFile.jar</B> that contains all of the class files in the current
directory, along with an automatically-generated manifest file.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cmf myJarFile.jar myManifestFile.mf *.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like the previous example, but
adding a user-created manifest file called
<B>myManifestFile.mf</B>.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar tf myJarFile.jar</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces a table of contents of the
files in <B>myJarFile.jar</B>.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar tvf myJarFile.jar</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Adds the &#8220;verbose&#8221; flag
to give more detailed information about the files in
<B>myJarFile.jar</B>.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cvf myApp.jar audio classes image</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Assuming <B>audio</B>,
<B>classes,</B> and <B>image</B> are subdirectories, this combines all of the
subdirectories into the file <B>myApp.jar</B>. The &#8220;verbose&#8221; flag is
also included to give extra feedback while the <B>jar</B> program is
working.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you create a JAR file using the
<B>O</B> option, that file can be placed in your CLASSPATH:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CLASSPATH=<font color=#004488>"lib1.jar;lib2.jar;"</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Then Java can search
<B>lib1.jar</B> and <B>lib2.jar</B> for class files.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>jar</B> tool isn&#8217;t as
useful as a <B>zip</B> utility. For example, you can&#8217;t add or update files
to an existing JAR file; you can create JAR files only from scratch. Also, you
can&#8217;t move files into a JAR file, erasing them as they are moved. However,
a JAR file created on one platform will be transparently readable by the
<B>jar</B> tool on any other platform (a problem that sometimes plagues
<B>zip</B> utilities).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you will see in Chapter 13, JAR
files are also used to package Java
Beans.</FONT><A NAME="_Toc408018638"></A><BR></P></DIV>
<A NAME="Heading342"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Object serialization</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1<A NAME="Index1301"></A>
has added an interesting feature called
<A NAME="Index1302"></A><A NAME="Index1303"></A><I>object serialization</I> that
allows you to take any object that implements the
<A NAME="Index1304"></A><B>Serializable</B> interface and turn it into a
sequence of bytes that can later be restored fully into the original object.
This is even true across a network, which means that the serialization mechanism
automatically compensates for differences in operating systems. That is, you can
create an object on a Windows machine, serialize it, and send it across the
network to a Unix machine where it will be correctly reconstructed. You
don&#8217;t have to worry about the data representations on the different
machines, the byte ordering, or any other details.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By itself, object serialization is
interesting because it allows you to implement
<A NAME="Index1305"></A><A NAME="Index1306"></A><A NAME="Index1307"></A><I>lightweight
persistence</I>. Remember that persistence means an object&#8217;s lifetime is
not determined by whether a program is executing &#8211; the object lives
<I>in</I> <I>between</I> invocations of the program. By taking a serializable
object and writing it to disk, then restoring that object when the program is
re-invoked, you&#8217;re able to produce the effect of persistence. The reason
it&#8217;s called &#8220;lightweight&#8221; is that you can&#8217;t simply
define an object using some kind of &#8220;persistent&#8221; keyword and let the
system take care of the details (although this might happen in the future).
Instead, you must explicitly serialize and de-serialize the objects in your
program.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Object serialization was added to
the language to support two major features. Java
1.1<A NAME="Index1308"></A>&#8217;s <I>remote method invocation</I> (RMI) allows
objects that live on other machines to behave as if they live on your machine.
When sending messages to remote objects, object serialization is necessary to
transport the arguments and return values. RMI is discussed in Chapter
15.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Object serialization is also
necessary for Java Beans, introduced in Java 1.1<A NAME="Index1309"></A>. When a
Bean is used, its state information is generally configured at design time. This
state information must be stored and later recovered when the program is
started; object serialization performs this task.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Serializing an object is quite
simple, as long as the object implements the <B>Serializable</B> interface (this
interface is just a flag and has no methods). In Java
1.1<A NAME="Index1310"></A>, many standard library classes have been changed so
they&#8217;re serializable, including all of the wrappers for the primitive
types, all of the collection classes, and many others. Even <B>Class</B> objects
can be serialized. (See Chapter 11 for the implications of
this.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To serialize an object, you create
some sort of <B>OutputStream</B> object and then wrap it inside an
<A NAME="Index1311"></A><A NAME="Index1312"></A><B>ObjectOutputStream</B>
object. At this point you need only call
<A NAME="Index1313"></A><A NAME="Index1314"></A><B>writeObject(&#160;)</B> and
your object is serialized and sent to the <B>OutputStream</B>. To reverse the
process, you wrap an <B>InputStream</B> inside an <B>ObjectInputStream</B> and
call <A NAME="Index1315"></A><A NAME="Index1316"></A><B>readObject(&#160;)</B>.
What comes back is, as usual, a handle to an upcast <B>Object</B>, so you must
downcast to set things straight.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A particularly clever aspect of
object serialization is that it not only saves an image of your object but it
also follows all the handles contained in your object and saves <I>those
</I>objects, and follows all the handles in each of those objects, etc. This is
sometimes referred to as the
&#8220;<A NAME="Index1317"></A><A NAME="Index1318"></A>web of objects&#8221;
that a single object can be connected to, and it includes arrays of handles to
objects as well as member objects. If you had to maintain your own object
serialization scheme, maintaining the code to follow all these links would be a
bit mind&#8211;boggling. However, Java object serialization seems to pull it off
flawlessly, no doubt using an optimized algorithm that traverses the web of
objects. The following example tests the serialization mechanism by making a
&#8220;worm&#8221; of linked objects, each of which has a link to the next
segment in the worm as well as an array of handles to objects of a different
class, <B>Data</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Worm.java</font>
<font color=#009900>// Demonstrates object serialization in Java 1.1</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> Data <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  Data(<font color=#0000ff>int</font> x) { i = x; }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> Integer.toString(i);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Worm <font color=#0000ff>implements</font> Serializable {
  <font color=#009900>// Generate a random int value:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> r() {
    <font color=#0000ff>return</font> (<font color=#0000ff>int</font>)(Math.random() * 10);
  }
  <font color=#0000ff>private</font> Data[] d = {
    <font color=#0000ff>new</font> Data(r()), <font color=#0000ff>new</font> Data(r()), <font color=#0000ff>new</font> Data(r())
  };
  <font color=#0000ff>private</font> Worm next;
  <font color=#0000ff>private</font> <font color=#0000ff>char</font> c;
  <font color=#009900>// Value of i == number of segments</font>
  Worm(<font color=#0000ff>int</font> i, <font color=#0000ff>char</font> x) {
    System.out.println(<font color=#004488>" Worm constructor: "</font> + i);
    c = x;
    <font color=#0000ff>if</font>(--i &gt; 0)
      next = <font color=#0000ff>new</font> Worm(i, (<font color=#0000ff>char</font>)(x + 1));
  }
  Worm() {
    System.out.println(<font color=#004488>"Default constructor"</font>);
  }
  <font color=#0000ff>public</font> String toString() {
    String s = <font color=#004488>":"</font> + c + <font color=#004488>"("</font>;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; d.length; i++)
      s += d[i].toString();
    s += <font color=#004488>")"</font>;
    <font color=#0000ff>if</font>(next != <font color=#0000ff>null</font>)
      s += next.toString();
    <font color=#0000ff>return</font> s;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Worm w = <font color=#0000ff>new</font> Worm(6, 'a');
    System.out.println(<font color=#004488>"w = "</font> + w);
    <font color=#0000ff>try</font> {
      ObjectOutputStream out =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"worm.out"</font>));
      out.writeObject(<font color=#004488>"Worm storage"</font>);
      out.writeObject(w);
      out.close(); <font color=#009900>// Also flushes output</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"worm.out"</font>));
      String s = (String)in.readObject();
      Worm w2 = (Worm)in.readObject();
      System.out.println(s + <font color=#004488>", w2 = "</font> + w2);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
    <font color=#0000ff>try</font> {
      ByteArrayOutputStream bout =
        <font color=#0000ff>new</font> ByteArrayOutputStream();
      ObjectOutputStream out =
        <font color=#0000ff>new</font> ObjectOutputStream(bout);
      out.writeObject(<font color=#004488>"Worm storage"</font>);
      out.writeObject(w);
      out.flush();
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(
            bout.toByteArray()));
      String s = (String)in.readObject();
      Worm w3 = (Worm)in.readObject();
      System.out.println(s + <font color=#004488>", w3 = "</font> + w3);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make things interesting, the
array of <B>Data</B> objects inside <B>Worm</B> are initialized with random
numbers. (This way you don&#8217;t suspect the compiler of keeping some kind of
meta-information.) Each <B>Worm</B> segment is labeled with a <B>char</B>
that&#8217;s automatically generated in the process of recursively generating
the linked list of <B>Worm</B>s. When you create a <B>Worm</B>, you tell the
constructor how long you want it to be. To make the <B>next</B> handle it calls
the <B>Worm</B> constructor with a length of one less, etc. The final
<B>next</B> handle is left as <B>null</B>, indicating the end of the
<B>Worm</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The point of all this was to make
something reasonably complex that couldn&#8217;t easily be serialized. The act
of serializing, however, is quite simple. Once the <B>ObjectOutputStream</B> is
created from some other stream, <B>writeObject(&#160;)</B> serializes the
object. Notice the call to <B>writeObject(&#160;)</B> for a <B>String</B>, as
well. You can also write all the primitive data types using the same methods as
<B>DataOutputStream</B> (they share the same interface).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are two separate <B>try</B>
blocks that look similar. The first writes and reads a file and the second, for
variety, writes and reads a <B>ByteArray</B>. You can read and write an object
using serialization to any <B>DataInputStream</B> or <B>DataOutputStream</B>
including, as you will see in the networking chapter, a network. The output from
one run was:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w = :a(262):b(100):c(396):d(480):e(316):f(398)
Worm storage, w2 = :a(262):b(100):c(396):d(480):e(316):f(398)
Worm storage, w3 = :a(262):b(100):c(396):d(480):e(316):f(398)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the deserialized
object really does contain all of the links that were in the original
object.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that no constructor, not even
the default constructor, is called in the process of deserializing a
<B>Serializable</B> object. The entire object is restored by recovering data
from the <B>InputStream</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Object serialization is another
Java 1.1<A NAME="Index1319"></A> feature that is not part of the new
<B>Reader</B> and <B>Writer</B> hierarchies, but instead uses the old
<B>InputStream</B> and <B>OutputStream</B> hierarchies. Thus you might encounter
situations in which you&#8217;re forced to mix the two
hierarchies.</FONT><A NAME="_Toc408018639"></A><BR></P></DIV>
<A NAME="Heading343"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Finding the class</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might wonder what&#8217;s
necessary for an object to be recovered from its serialized state. For example,
suppose you serialize an object and send it as a file or through a network to
another machine. Could a program on the other machine reconstruct the object
using only the contents of the file?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The best way to answer this
question is (as usual) by performing an experiment. The following file goes in
the subdirectory for this chapter:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Alien.java</font>
<font color=#009900>// A serializable class</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Alien <font color=#0000ff>implements</font> Serializable {
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The file that creates and
serializes an <B>Alien </B>object goes in the same directory:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: FreezeAlien.java</font>
<font color=#009900>// Create a serialized output file</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FreezeAlien {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> Exception {
    ObjectOutput out = 
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"file.x"</font>));
    Alien zorcon = <font color=#0000ff>new</font> Alien();
    out.writeObject(zorcon); 
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Rather than catching and handling
exceptions, this program takes the quick and dirty approach of passing the
exceptions out of <B>main(&#160;)</B>, so they&#8217;ll be reported on the
command line.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the program is compiled and
run, copy the resulting <B>file.x</B> to a subdirectory called <B>xfiles</B>,
where the following code goes:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ThawAlien.java</font>
<font color=#009900>// Try to recover a serialized file without the </font>
<font color=#009900>// class of object that's stored in that file.</font>
<font color=#0000ff>package</font> c10.xfiles;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ThawAlien {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> Exception {
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"file.x"</font>));
    Object mystery = in.readObject();
    System.out.println(
      mystery.getClass().toString());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program opens the file and
reads in the object <B>mystery</B> successfully. However, as soon as you try to
find out anything about the object &#8211; which requires the <B>Class</B>
object for <B>Alien</B> &#8211; the Java Virtual Machine (JVM) cannot find
<B>Alien.class</B> (unless it happens to be in the Classpath, which it
shouldn&#8217;t be in this example). You&#8217;ll get a
<B>ClassNotFoundException.</B> (Once again, all evidence of alien life vanishes
before proof of its existence can be verified!)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you expect to do much after
you&#8217;ve recovered an object that has been serialized, you must make sure
that the JVM can find the associated <B>.class</B> file either in the local
class path or somewhere on the
Internet.</FONT><A NAME="_Toc408018640"></A><BR></P></DIV>
<A NAME="Heading344"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Controlling serialization</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you can see, the default
serialization mechanism is trivial to use. But what if you have special needs?
Perhaps you have special security issues and you don&#8217;t want to serialize
portions of your object, or perhaps it just doesn&#8217;t make sense for one
sub-object to be serialized if that part needs to be created anew when the
object is recovered.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can
<A NAME="Index1320"></A><A NAME="Index1321"></A>control the process of
serialization by implementing the
<A NAME="Index1322"></A><A NAME="Index1323"></A><B>Externalizable</B> interface
instead of the
<A NAME="Index1324"></A><A NAME="Index1325"></A><B>Serializable</B> interface.
The <B>Externalizable</B> interface extends the <B>Serializable</B> interface
and adds two methods,
<A NAME="Index1326"></A><A NAME="Index1327"></A><B>writeExternal(&#160;)</B> and
<A NAME="Index1328"></A><A NAME="Index1329"></A><B>readExternal(&#160;),</B>
that are automatically called for your object during serialization and
deserialization so that you can perform your special
operations.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example shows simple
implementations of the <B>Externalizable</B> interface methods. Note that
<B>Blip1</B> and <B>Blip2</B> are nearly identical except for a subtle
difference (see if you can discover it by looking at the code):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Blips.java</font>
<font color=#009900>// Simple use of Externalizable &amp; a pitfall</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Blip1 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>public</font> Blip1() {
    System.out.println(<font color=#004488>"Blip1 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip1.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip1.readExternal"</font>);
  }
}

<font color=#0000ff>class</font> Blip2 <font color=#0000ff>implements</font> Externalizable {
  Blip2() {
    System.out.println(<font color=#004488>"Blip2 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip2.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip2.readExternal"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Blips {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip1 b1 = <font color=#0000ff>new</font> Blip1();
    Blip2 b2 = <font color=#0000ff>new</font> Blip2();
    <font color=#0000ff>try</font> {
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blips.out"</font>));
      System.out.println(<font color=#004488>"Saving objects:"</font>);
      o.writeObject(b1);
      o.writeObject(b2);
      o.close();
      <font color=#009900>// Now get them back:</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blips.out"</font>));
      System.out.println(<font color=#004488>"Recovering b1:"</font>);
      b1 = (Blip1)in.readObject();
      <font color=#009900>// OOPS! Throws an exception:</font>
<font color=#009900>//!   System.out.println("Recovering b2:");</font>
<font color=#009900>//!   b2 = (Blip2)in.readObject();</font>
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output for this program
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Constructing objects:
Blip1 Constructor
Blip2 Constructor
Saving objects:
Blip1.writeExternal
Blip2.writeExternal
Recovering b1:
Blip1 Constructor
Blip1.readExternal</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The reason that the <B>Blip2</B>
object is not recovered is that trying to do so causes an exception. Can you see
the difference between <B>Blip1</B> and <B>Blip2</B>? The constructor for
<B>Blip1</B> is <B>public</B>, while the constructor for <B>Blip2</B> is not,
and that causes the exception upon recovery. Try making <B>Blip2</B>&#8217;s
constructor <B>public </B>and removing the <B>//! </B>comments to see the
correct results.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When <B>b1</B> is recovered, the
<B>Blip1</B> default constructor is called. This is different from recovering a
<B>Serializable</B> object, in which the object is constructed entirely from its
stored bits, with no constructor calls. With an <B>Externalizable</B> object,
all the normal default construction behavior occurs (including the
initializations at the point of field definition), and <I>then</I>
<B>readExternal(&#160;)</B> is called. You need to be aware of this &#8211; in
particular the fact that all the default construction always takes place &#8211;
to produce the correct behavior in your <B>Externalizable</B>
objects.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that shows
what you must do to fully store and retrieve an <B>Externalizable</B>
object:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Blip3.java</font>
<font color=#009900>// Reconstructing an externalizable object</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Blip3 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>int</font> i;
  String s; <font color=#009900>// No initialization</font>
  <font color=#0000ff>public</font> Blip3() {
    System.out.println(<font color=#004488>"Blip3 Constructor"</font>);
    <font color=#009900>// s, i not initialized</font>
  }
  <font color=#0000ff>public</font> Blip3(String x, <font color=#0000ff>int</font> a) {
    System.out.println(<font color=#004488>"Blip3(String x, int a)"</font>);
    s = x;
    i = a;
    <font color=#009900>// s &amp; i initialized only in non-default</font>
    <font color=#009900>// constructor.</font>
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> s + i; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip3.writeExternal"</font>);
    <font color=#009900>// You must do this:</font>
    out.writeObject(s); out.writeInt(i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip3.readExternal"</font>);
    <font color=#009900>// You must do this:</font>
    s = (String)in.readObject(); 
    i =in.readInt();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip3 b3 = <font color=#0000ff>new</font> Blip3(<font color=#004488>"A String "</font>, 47);
    System.out.println(b3.toString());
    <font color=#0000ff>try</font> {
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blip3.out"</font>));
      System.out.println(<font color=#004488>"Saving object:"</font>);
      o.writeObject(b3);
      o.close();
      <font color=#009900>// Now get it back:</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blip3.out"</font>));
      System.out.println(<font color=#004488>"Recovering b3:"</font>);
      b3 = (Blip3)in.readObject();
      System.out.println(b3.toString());
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fields <B>s</B> and <B>i
</B>are initialized only in the second constructor, but not in the default
constructor. This means that if you don&#8217;t initialize <B>s</B> and <B>i
</B>in <B>readExternal</B>, it will be <B>null</B> (since the storage for the
object gets wiped to zero in the first step of object creation). If you comment
out the two lines of code following the phrases &#8220;You must do this&#8221;
and run the program, you&#8217;ll see that when the object is recovered,
<B>s</B> is <B>null</B> and <B>i</B> is zero.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you are inheriting from an
<B>Externalizable</B> object, you&#8217;ll typically call the base-class
versions of <B>writeExternal(&#160;) </B>and <B>readExternal(&#160;)</B> to
provide proper storage and retrieval of the base-class
components.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So to make things work correctly
you must not only write the important data from the object during the
<B>writeExternal(&#160;) </B>method (there is no default behavior that writes
any of the member objects for an <B>Externalizable</B> object), but you must
also recover that data in the <B>readExternal(&#160;)</B> method. This can be a
bit confusing at first because the default construction behavior for an
<B>Externalizable</B> object can make it seem like some kind of storage and
retrieval takes place automatically. It does not.</FONT><BR></P></DIV>
<A NAME="Heading345"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The transient keyword</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you&#8217;re controlling
serialization, there might be a particular subobject that you don&#8217;t want
Java&#8217;s serialization mechanism to automatically save and restore. This is
commonly the case if that subobject represents sensitive information that you
don&#8217;t want to serialize, such as a password. Even if that information is
<B>private </B>in the object, once it&#8217;s serialized it&#8217;s possible for
someone to access it by reading a file or intercepting a network
transmission.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One way to prevent sensitive parts
of your object from being serialized is to implement your class as
<B>Externalizable</B>, as shown previously. Then nothing is automatically
serialized and you can explicitly serialize only the necessary parts inside
<B>writeExternal(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re working with a
<B>Serializable </B>object, however, all serialization happens automatically. To
control this, you can turn off serialization on a field-by-field basis using the
<A NAME="Index1330"></A><A NAME="Index1331"></A><A NAME="Index1332"></A><B>transient</B>
keyword, which says &#8220;Don&#8217;t bother saving or restoring this &#8211;
I&#8217;ll take care of it.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For example, consider a <B>Login
</B>object that keeps information about a particular login session. Suppose
that, once you verify the login, you want to store the data, but without the
password. The easiest way to do this is by implementing
<A NAME="Index1333"></A><B>Serializable</B> and marking the <B>password</B>
field as <B>transient</B>. Here&#8217;s what it looks like:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Logon.java</font>
<font color=#009900>// Demonstrates the "transient" keyword</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Logon <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> Date date = <font color=#0000ff>new</font> Date();
  <font color=#0000ff>private</font> String username;
  <font color=#0000ff>private</font> <font color=#0000ff>transient</font> String password;
  Logon(String name, String pwd) {
    username = name;
    password = pwd;
  }
  <font color=#0000ff>public</font> String toString() {
    String pwd =
      (password == <font color=#0000ff>null</font>) ? <font color=#004488>"(n</font><font color=#004488>/a)"</font> : password;
    <font color=#0000ff>return</font> <font color=#004488>"logon info: \n   "</font> +
      <font color=#004488>"username: "</font> + username +
      <font color=#004488>"\n   date: "</font> + date.toString() +
      <font color=#004488>"\n   password: "</font> + pwd;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Logon a = <font color=#0000ff>new</font> Logon(<font color=#004488>"Hulk"</font>, <font color=#004488>"myLittlePony"</font>);
    System.out.println( <font color=#004488>"logon a = "</font> + a);
    <font color=#0000ff>try</font> {
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Logon.out"</font>));
      o.writeObject(a);
      o.close();
      <font color=#009900>// Delay:</font>
      <font color=#0000ff>int</font> seconds = 5;
      <font color=#0000ff>long</font> t = System.currentTimeMillis()
             + seconds * 1000;
      <font color=#0000ff>while</font>(System.currentTimeMillis() &lt; t)
        ;
      <font color=#009900>// Now get them back:</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Logon.out"</font>));
      System.out.println(
        <font color=#004488>"Recovering object at "</font> + <font color=#0000ff>new</font> Date());
      a = (Logon)in.readObject();
      System.out.println( <font color=#004488>"logon a = "</font> + a);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the <B>date</B>
and <B>username</B> fields are ordinary (not <B>transient</B>), and thus are
automatically serialized. However, the <B>password</B> is <B>transient</B>, and
so is not stored to disk; also the serialization mechanism makes no attempt to
recover it. The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>logon a = logon info:
   username: Hulk
   date: Sun Mar 23 18:25:53 PST 1997
   password: myLittlePony
Recovering object at Sun Mar 23 18:25:59 PST 1997
logon a = logon info:
   username: Hulk
   date: Sun Mar 23 18:25:53 PST 1997
   password: (n/a)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the object is recovered, the
<B>password</B> field is <B>null</B>. Note that <B>toString(&#160;)</B> must
check for a <B>null</B> value of <B>password </B>because if you try to assemble
a <B>String</B> object using the overloaded &#8216;<B>+</B>&#8217; operator, and
that operator encounters a <B>null</B> handle, you&#8217;ll get a
<B>NullPointerException.</B> (Newer versions of Java might contain code to avoid
this problem.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also see that the
<B>date</B> field is stored to and recovered from disk and not generated
anew.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since <B>Externalizable</B> objects
do not store any of their fields by default, the <B>transient</B> keyword is for
use with <B>Serializable</B> objects only.</FONT><BR></P></DIV>
<A NAME="Heading346"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
An alternative to Externalizable</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re not keen on
implementing the <A NAME="Index1334"></A><B>Externalizable </B>interface,
there&#8217;s another approach. You can implement the <B>Serializable</B>
interface and <I>add </I>(notice I say &#8220;add&#8221; and not
&#8220;override&#8221; or &#8220;implement&#8221;) methods called
<A NAME="Index1335"></A><A NAME="Index1336"></A><B>writeObject(&#160;)</B> and
<A NAME="Index1337"></A><A NAME="Index1338"></A><B>readObject(&#160;)</B> that
will automatically be called when the object is serialized and deserialized,
respectively. That is, if you provide these two methods they will be used
instead of the default serialization.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The methods must have these exact
signatures:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>private</font> <font color=#0000ff>void</font> 
  writeObject(ObjectOutputStream stream)
    <font color=#0000ff>throws</font> IOException;

<font color=#0000ff>private</font> <font color=#0000ff>void</font> 
  readObject(ObjectInputStream stream)
    <font color=#0000ff>throws</font> IOException, ClassNotFoundException</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">From a design standpoint, things
get really weird here. First of all, you might think that because these methods
are not part of a base class or the <B>Serializable</B> interface, they ought to
be defined in their own interface(s). But notice that they are defined as
<B>private</B>, which means they are to be called only by other members of this
class. However, you don&#8217;t actually call them from other members of this
class, but instead the <B>writeObject(&#160;)</B> and <B>readObject(&#160;)</B>
methods of the <B>ObjectOutputStream</B> and <B>ObjectInputStream</B> objects
call your object&#8217;s <B>writeObject(&#160;)</B> and
<B>readObject(&#160;)</B> methods. (Notice my tremendous restraint in not
launching into a long diatribe about using the same method names here. In a
word: confusing.) You might wonder how the <B>ObjectOutputStream</B> and
<B>ObjectInputStream</B> objects have access to <B>private</B> methods of your
class. We can only assume that this is part of the serialization
magic.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In any event, anything defined in
an <B>interface</B> is automatically <B>public</B> so if
<B>writeObject(&#160;)</B> and <B>readObject(&#160;)</B> must be <B>private</B>,
then they can&#8217;t be part of an <B>interface</B>. Since you must follow the
signatures exactly, the effect is the same as if you&#8217;re implementing an
<B>interface</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It would appear that when you call
<B>ObjectOutputStream.writeObject(&#160;)</B>, the <B>Serializable</B> object
that you pass it to is interrogated (using reflection, no doubt) to see if it
implements its own <B>writeObject(&#160;)</B>. If so, the normal serialization
process is skipped and the <B>writeObject(&#160;)</B> is called. The same sort
of situation exists for <B>readObject(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s one other twist.
Inside your <B>writeObject(&#160;)</B>, you can choose to perform the default
<B>writeObject(&#160;)</B> action by calling <B>defaultWriteObject(&#160;)</B>.
Likewise, inside <B>readObject(&#160;)</B> you can call
<B>defaultReadObject(&#160;)</B>. Here is a simple example that demonstrates how
you can control the storage and retrieval of a <B>Serializable</B>
object:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SerialCtl.java</font>
<font color=#009900>// Controlling serialization by adding your own</font>
<font color=#009900>// writeObject() and readObject() methods.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SerialCtl <font color=#0000ff>implements</font> Serializable {
  String a;
  <font color=#0000ff>transient</font> String b;
  <font color=#0000ff>public</font> SerialCtl(String aa, String bb) {
    a = <font color=#004488>"Not Transient: "</font> + aa;
    b = <font color=#004488>"Transient: "</font> + bb;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> a + <font color=#004488>"\n"</font> + b;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> 
    writeObject(ObjectOutputStream stream)
      <font color=#0000ff>throws</font> IOException {
    stream.defaultWriteObject();
    stream.writeObject(b);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> 
    readObject(ObjectInputStream stream)
      <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    stream.defaultReadObject();
    b = (String)stream.readObject();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SerialCtl sc = 
      <font color=#0000ff>new</font> SerialCtl(<font color=#004488>"Test1"</font>, <font color=#004488>"Test2"</font>);
    System.out.println(<font color=#004488>"Before:\n"</font> + sc);
    ByteArrayOutputStream buf = 
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    <font color=#0000ff>try</font> {
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(buf);
      o.writeObject(sc);
      <font color=#009900>// Now get it back:</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(
            buf.toByteArray()));
      SerialCtl sc2 = (SerialCtl)in.readObject();
      System.out.println(<font color=#004488>"After:\n"</font> + sc2);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this example, one <B>String</B>
field is ordinary and the other is <B>transient</B>, to prove that the
non-<B>transient</B> field is saved by the
<A NAME="Index1339"></A><A NAME="Index1340"></A><B>defaultWriteObject(&#160;)</B>
method and the <B>transient</B> field is saved and restored explicitly. The
fields are initialized inside the constructor rather than at the point of
definition to prove that they are not being initialized by some automatic
mechanism during deserialization.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you are going to use the default
mechanism to write the non-<B>transient</B> parts of your object, you must call
<B>defaultWriteObject(&#160;)</B> as the first operation in
<B>writeObject(&#160;)</B> and
<A NAME="Index1341"></A><A NAME="Index1342"></A><B>defaultReadObject(&#160;)</B>
as the first operation in <B>readObject(&#160;)</B>. These are strange method
calls. It would appear, for example, that you are calling
<B>defaultWriteObject(&#160;)</B> for an <B>ObjectOutputStream</B> and passing
it no arguments, and yet it somehow turns around and knows the handle to your
object and how to write all the non-<B>transient</B> parts.
Spooky.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The storage and retrieval of the
<B>transient</B> objects uses more familiar code. And yet, think about what
happens here. In <B>main(&#160;)</B>, a <B>SerialCtl</B> object is created, and
then it&#8217;s serialized to an <B>ObjectOutputStream.</B> (Notice in this case
that a buffer is used instead of a file &#8211; it&#8217;s all the same to the
<B>ObjectOutputStream.</B>) The serialization occurs in the
line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>o.writeObject(sc);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>writeObject(&#160;)</B>
method must be examining <B>sc</B> to see if it has its own
<B>writeObject(&#160;)</B> method. (Not by checking the interface &#8211; there
isn&#8217;t one &#8211; or the class type, but by actually hunting for the
method using reflection.) If it does, it uses that. A similar approach holds
true for <B>readObject(&#160;)</B>. Perhaps this was the only practical way that
they could solve the problem, but it&#8217;s certainly strange.</FONT><BR></P></DIV>
<A NAME="Heading347"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Versioning<BR><A NAME="Index1343"></A><A NAME="Index1344"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s possible that you might
want to change the version of a serializable class (objects of the original
class might be stored in a database, for example). This is supported but
you&#8217;ll probably do it only in special cases, and it requires an extra
depth of understanding that we will not attempt to achieve here. The JDK1.1 HTML
documents downloadable from Sun (which might be part of your Java
package&#8217;s online documents) cover this topic quite
thoroughly.</FONT><A NAME="_Toc408018641"></A><BR></P></DIV>
<A NAME="Heading348"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using persistence<BR><A NAME="Index1345"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s quite appealing to use
<A NAME="Index1346"></A>serialization technology to store some of the state of
your program so that you can easily restore the program to the current state
later. But before you can do this, some questions must be answered. What happens
if you serialize two objects that both have a handle to a third object? When you
restore those two objects from their serialized state, do you get only one
occurrence of the third object? What if you serialize your two objects to
separate files and deserialize them in different parts of your
code?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that shows
the problem:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MyWorld.java</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> House <font color=#0000ff>implements</font> Serializable {}

<font color=#0000ff>class</font> Animal <font color=#0000ff>implements</font> Serializable {
  String name;
  House preferredHouse;
  Animal(String nm, House h) { 
    name = nm; 
    preferredHouse = h;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> name + <font color=#004488>"["</font> + <font color=#0000ff>super</font>.toString() + 
      <font color=#004488>"], "</font> + preferredHouse + <font color=#004488>"\n"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MyWorld {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    House house = <font color=#0000ff>new</font> House();
    Vector  animals = <font color=#0000ff>new</font> Vector();
    animals.addElement(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Bosco the dog"</font>, house));
    animals.addElement(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Ralph the hamster"</font>, house));
    animals.addElement(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Fronk the cat"</font>, house));
    System.out.println(<font color=#004488>"animals: "</font> + animals);

    <font color=#0000ff>try</font> {
      ByteArrayOutputStream buf1 = 
        <font color=#0000ff>new</font> ByteArrayOutputStream();
      ObjectOutputStream o1 =
        <font color=#0000ff>new</font> ObjectOutputStream(buf1);
      o1.writeObject(animals);
      o1.writeObject(animals); <font color=#009900>// Write a 2nd set</font>
      <font color=#009900>// Write to a different stream:</font>
      ByteArrayOutputStream buf2 = 
        <font color=#0000ff>new</font> ByteArrayOutputStream();
      ObjectOutputStream o2 =
        <font color=#0000ff>new</font> ObjectOutputStream(buf2);
      o2.writeObject(animals);
      <font color=#009900>// Now get them back:</font>
      ObjectInputStream in1 =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(
            buf1.toByteArray()));
      ObjectInputStream in2 =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(
            buf2.toByteArray()));
      Vector animals1 = (Vector)in1.readObject();
      Vector animals2 = (Vector)in1.readObject();
      Vector animals3 = (Vector)in2.readObject();
      System.out.println(<font color=#004488>"animals1: "</font> + animals1);
      System.out.println(<font color=#004488>"animals2: "</font> + animals2);
      System.out.println(<font color=#004488>"animals3: "</font> + animals3);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One thing that&#8217;s interesting
here is that it&#8217;s possible to use object serialization to and from a byte
array as a way of doing a &#8220;deep copy&#8221; of any object that&#8217;s
<B>Serializable.</B> (A deep copy means that you&#8217;re duplicating the entire
web of objects, rather than just the basic object and its handles.) Copying is
covered in depth in Chapter 12.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Animal</B> objects contain
fields of type <B>House</B>. In <B>main(&#160;)</B>, a <B>Vector</B> of these
<B>Animal</B>s is created and it is serialized twice to one stream and then
again to a separate stream. When these are deserialized and printed, you see the
following results for one run (the objects will be in different memory locations
each run):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>animals: [Bosco the dog[Animal@1cc76c], House@1cc769
, Ralph the hamster[Animal@1cc76d], House@1cc769
, Fronk the cat[Animal@1cc76e], House@1cc769
]
animals1: [Bosco the dog[Animal@1cca0c], House@1cca16
, Ralph the hamster[Animal@1cca17], House@1cca16
, Fronk the cat[Animal@1cca1b], House@1cca16
]
animals2: [Bosco the dog[Animal@1cca0c], House@1cca16
, Ralph the hamster[Animal@1cca17], House@1cca16
, Fronk the cat[Animal@1cca1b], House@1cca16
]
animals3: [Bosco the dog[Animal@1cca52], House@1cca5c
, Ralph the hamster[Animal@1cca5d], House@1cca5c
, Fronk the cat[Animal@1cca61], House@1cca5c
]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course you expect that the
deserialized objects have different addresses from their originals. But notice
that in <B>animals1</B> and <B>animals2</B> the same addresses appear, including
the references to the <B>House </B>object that both share. On the other hand,
when <B>animals3 </B>is recovered the system has no way of knowing that the
objects in this other stream are aliases of the objects in the first stream, so
it makes a completely different web of objects.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As long as you&#8217;re serializing
everything to a single stream, you&#8217;ll be able to recover the same web of
objects that you wrote, with no accidental duplication of objects. Of course,
you can change the state of your objects in between the time you write the first
and the last, but that&#8217;s your responsibility &#8211; the objects will be
written in whatever state they are in (and with whatever connections they have
to other objects) at the time you serialize them.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The safest thing to do if you want
to save the state of a system is to serialize as an &#8220;atomic&#8221;
operation. If you serialize some things, do some other work, and serialize some
more, etc., then you will not be storing the system safely. Instead, put all the
objects that comprise the state of your system in a single collection and simply
write that collection out in one operation. Then you can restore it with a
single method call as well.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example is an
imaginary computer-aided design (CAD) system that demonstrates the approach. In
addition, it throws in the issue of <B>static</B> fields &#8211; if you look at
the documentation you&#8217;ll see that <B>Class</B> is <B>Serializable</B>, so
it should be easy to store the <B>static</B> fields by simply serializing the
<A NAME="Index1347"></A><A NAME="Index1348"></A><B>Class</B> object. That seems
like a sensible approach, anyway.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CADState.java</font>
<font color=#009900>// Saving and restoring the state of a </font>
<font color=#009900>// pretend CAD system.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Shape <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> 
    RED = 1, BLUE = 2, GREEN = 3;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> xPos, yPos, dimension;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> counter = 0;
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor);
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor();
  <font color=#0000ff>public</font> Shape(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    xPos = xVal;
    yPos = yVal;
    dimension = dim;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> getClass().toString() + 
      <font color=#004488>" color["</font> + getColor() +
      <font color=#004488>"] xPos["</font> + xPos +
      <font color=#004488>"] yPos["</font> + yPos +
      <font color=#004488>"] dim["</font> + dimension + <font color=#004488>"]\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Shape randomFactory() {
    <font color=#0000ff>int</font> xVal = r.nextInt() % 100;
    <font color=#0000ff>int</font> yVal = r.nextInt() % 100;
    <font color=#0000ff>int</font> dim = r.nextInt() % 100;
    <font color=#0000ff>switch</font>(counter++ % 3) {
      <font color=#0000ff>default</font>: 
      <font color=#0000ff>case</font> 0: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Circle(xVal, yVal, dim);
      <font color=#0000ff>case</font> 1: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Square(xVal, yVal, dim);
      <font color=#0000ff>case</font> 2: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Line(xVal, yVal, dim);
    }
  }
}

<font color=#0000ff>class</font> Circle <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> Circle(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>class</font> Square <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color;
  <font color=#0000ff>public</font> Square(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
    color = RED;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>class</font> Line <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  serializeStaticState(ObjectOutputStream os)
      <font color=#0000ff>throws</font> IOException {
    os.writeInt(color);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  deserializeStaticState(ObjectInputStream os)
      <font color=#0000ff>throws</font> IOException {
    color = os.readInt();
  }
  <font color=#0000ff>public</font> Line(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CADState {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> Exception {
    Vector shapeTypes, shapes;
    <font color=#0000ff>if</font>(args.length == 0) {
      shapeTypes = <font color=#0000ff>new</font> Vector();
      shapes = <font color=#0000ff>new</font> Vector();
      <font color=#009900>// Add handles to the class objects:</font>
      shapeTypes.addElement(Circle.<font color=#0000ff>class</font>);
      shapeTypes.addElement(Square.<font color=#0000ff>class</font>);
      shapeTypes.addElement(Line.<font color=#0000ff>class</font>);
      <font color=#009900>// Make some shapes:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        shapes.addElement(Shape.randomFactory());
      <font color=#009900>// Set all the static colors to GREEN:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        ((Shape)shapes.elementAt(i))
          .setColor(Shape.GREEN);
      <font color=#009900>// Save the state vector:</font>
      ObjectOutputStream out =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"CADState.out"</font>));
      out.writeObject(shapeTypes);
      Line.serializeStaticState(out);
      out.writeObject(shapes);
    } <font color=#0000ff>else</font> { <font color=#009900>// There's a command-line argument</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(args[0]));
      <font color=#009900>// Read in the same order they were written:</font>
      shapeTypes = (Vector)in.readObject();
      Line.deserializeStaticState(in);
      shapes = (Vector)in.readObject();
    }
    <font color=#009900>// Display the shapes:</font>
    System.out.println(shapes);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Shape</B> class
<B>implements <A NAME="Index1349"></A>Serializable</B>, so anything that is
inherited from <B>Shape</B> is automatically <B>Serializable</B> as well. Each
<B>Shape</B> contains data, and each derived <B>Shape</B> class contains a
<B>static</B> field that determines the color of all of those types of
<B>Shape</B>s. (Placing a <B>static</B> field in the base class would result in
only one field, since <B>static</B> fields are not duplicated in derived
classes.) Methods in the base class can be overridden to set the color for the
various types (<B>static</B> methods are not dynamically bound, so these are
normal methods). The <B>randomFactory(&#160;)</B> method creates a different
<B>Shape</B> each time you call it, using random values for the <B>Shape</B>
data.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Circle</B> and <B>Square</B> are
straightforward extensions of <B>Shape</B>; the only difference is that
<B>Circle</B> initializes <B>color</B> at the point of definition and
<B>Square</B> initializes it in the constructor. We&#8217;ll leave the
discussion of <B>Line</B> for later.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, one
<B>Vector</B> is used to hold the <B>Class</B> objects and the other to hold the
shapes. If you don&#8217;t provide a command line argument the <B>shapeTypes</B>
<B>Vector</B> is created and the <B>Class</B> objects are added, and then the
<B>shapes</B> <B>Vector</B> is created and <B>Shape</B> objects are added. Next,
all the <B>static</B> <B>color</B> values are set to <B>GREEN</B>, and
everything is serialized to the file <B>CADState.out</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you provide a command line
argument (presumably <B>CADState.out</B>), that file is opened and used to
restore the state of the program. In both situations, the resulting
<B>Vector</B> of <B>Shape</B>s is printed out. The results from one run
are:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&gt;java CADState
[<font color=#0000ff>class</font> Circle color[3] xPos[-51] yPos[-99] dim[38]
, <font color=#0000ff>class</font> Square color[3] xPos[2] yPos[61] dim[-46]
, <font color=#0000ff>class</font> Line color[3] xPos[51] yPos[73] dim[64]
, <font color=#0000ff>class</font> Circle color[3] xPos[-70] yPos[1] dim[16]
, <font color=#0000ff>class</font> Square color[3] xPos[3] yPos[94] dim[-36]
, <font color=#0000ff>class</font> Line color[3] xPos[-84] yPos[-21] dim[-35]
, <font color=#0000ff>class</font> Circle color[3] xPos[-75] yPos[-43] dim[22]
, <font color=#0000ff>class</font> Square color[3] xPos[81] yPos[30] dim[-45]
, <font color=#0000ff>class</font> Line color[3] xPos[-29] yPos[92] dim[17]
, <font color=#0000ff>class</font> Circle color[3] xPos[17] yPos[90] dim[-76]
]

&gt;java CADState CADState.out
[<font color=#0000ff>class</font> Circle color[1] xPos[-51] yPos[-99] dim[38]
, <font color=#0000ff>class</font> Square color[0] xPos[2] yPos[61] dim[-46]
, <font color=#0000ff>class</font> Line color[3] xPos[51] yPos[73] dim[64]
, <font color=#0000ff>class</font> Circle color[1] xPos[-70] yPos[1] dim[16]
, <font color=#0000ff>class</font> Square color[0] xPos[3] yPos[94] dim[-36]
, <font color=#0000ff>class</font> Line color[3] xPos[-84] yPos[-21] dim[-35]
, <font color=#0000ff>class</font> Circle color[1] xPos[-75] yPos[-43] dim[22]
, <font color=#0000ff>class</font> Square color[0] xPos[81] yPos[30] dim[-45]
, <font color=#0000ff>class</font> Line color[3] xPos[-29] yPos[92] dim[17]
, <font color=#0000ff>class</font> Circle color[1] xPos[17] yPos[90] dim[-76]
]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the values of
<B>xPos</B>, <B>yPos,</B> and <B>dim</B> were all stored and recovered
successfully, but there&#8217;s something wrong with the retrieval of the
<B>static</B> information. It&#8217;s all &#8216;3&#8217; going in, but it
doesn&#8217;t come out that way. <B>Circle</B>s have a value of 1 (<B>RED</B>,
which is the definition), and <B>Square</B>s have a value of 0 (remember, they
are initialized in the constructor). It&#8217;s as if the <B>static</B>s
didn&#8217;t get serialized at all! That&#8217;s right &#8211; even though class
<B>Class</B> is <B>Serializable</B>, it doesn&#8217;t do what you expect. So if
you want to serialize <B>statics</B>, you must do it yourself.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is what the
<B>serializeStaticState(&#160;) </B>and <B>deserializeStaticState(&#160;)</B>
<B>static </B>methods in <B>Line</B> are for. You can see that they are
explicitly called as part of the storage and retrieval process. (Note that the
order of writing to the serialize file and reading back from it must be
maintained.) Thus to make <B>CADState.java</B> run correctly you must (1) Add a
<B>serializeStaticState(&#160;)</B> and <B>deserializeStaticState(&#160;)</B> to
the shapes, (2) Remove the <B>Vector shapeTypes</B> and all code related to it,
and (3) Add calls to the new serialize and deserialize static methods in the
shapes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another issue you might have to
think about is security, since serialization also saves <B>private</B> data. If
you have a security issue, those fields should be marked as <B>transient</B>.
But then you have to design a secure way to store that information so that when
you do a restore you can reset those <B>private</B> variables.
</FONT><A NAME="_Toc408018642"></A><BR></P></DIV>
<A NAME="Heading349"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java IO stream library does
seem to satisfy the basic requirements: you can perform reading and writing with
the console, a file, a block of memory, or even across the Internet (as you will
see in Chapter 15). It&#8217;s possible (by inheriting from <B>InputStream</B>
and <B>OutputStream</B>) to create new types of input and output objects. And
you can even add a simple extensibility to the kinds of objects a stream will
accept by redefining the <B>toString(&#160;)</B> method that&#8217;s
automatically called when you pass an object to a method that&#8217;s expecting
a <B>String</B> (Java&#8217;s limited &#8220;automatic type conversion&#8221;).
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are questions left unanswered
by the documentation and design of the IO stream library. For example, it would
have been nice if you could say that you want an exception thrown if you try to
overwrite a file when opening it for output &#8211; some programming systems
allow you to specify that you want to open an output file, but only if it
doesn&#8217;t already exist. In Java, it appears that you are supposed to use a
<B>File</B> object to determine whether a file exists, because if you open it as
an <B>FileOutputStream</B> or <B>FileWriter </B>it will always get overwritten.
By representing both files and directory paths, the <B>File</B> class also
suggests poor design by violating the maxim &#8220;Don&#8217;t try to do too
much in a single class.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The IO stream library brings up
mixed feelings. It does much of the job and it&#8217;s portable. But if you
don&#8217;t already understand the decorator pattern, the design is
non-intuitive, so there&#8217;s extra overhead in learning and teaching it.
It&#8217;s also incomplete: there&#8217;s no support for the kind of output
formatting that almost every other language&#8217;s IO package supports. (This
was not remedied in Java 1.1, which missed the opportunity to change the library
design completely, and instead added even more special cases and
complexity.<A NAME="Index1350"></A>) The Java 1.1 changes to the IO library
haven&#8217;t been replacements, but rather additions, and it seems that the
library designers couldn&#8217;t quite get straight which features are
deprecated and which are preferred, resulting in annoying deprecation messages
that show up the contradictions in the library design.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, once you <I>do</I>
understand the decorator pattern and begin using the library in situations that
require its flexibility, you can begin to benefit from this design, at which
point its cost in extra lines of code may not bother you as
much.</FONT><A NAME="_Toc375545401"></A><A NAME="_Toc408018643"></A><BR></P></DIV>
<A NAME="Heading350"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises<A NAME="Index1351"></A></H2></FONT>
<OL>
<LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Open
a text file so that you can read the file one line at a time. Read each line as
a <B>String </B>and place that <B>String </B>object into a <B>Vector</B>. Print
out all of the lines in the <B>Vector</B> in reverse
order.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Modify
Exercise 1 so that the name of the file you read is provided as a command-line
argument.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Modify
Exercise 2 to also open a text file so you can write text into it. Write the
lines in the <B>Vector</B>, along with line numbers, out to the
file.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Modify
Exercise 2 to force all the lines in the <B>Vector</B> to upper case and send
the results to
<B>System.out</B>.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Modify
Exercise 2 to take additional arguments of words to find in the file. Print out
any lines in which the words
match.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">In
<B>Blips.java</B>, copy the file and rename it to <B>BlipCheck.java </B>and
rename the class <B>Blip2</B> to <B>BlipCheck </B>(making it <B>public</B> in
the process). Remove the <B>//!</B> marks in the file and execute the program
including the offending lines. Next, comment out the default constructor for
<B>BlipCheck</B>. Run it and explain why it
works.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">In
<B>Blip3.java</B>, comment out the two lines after the phrases &#8220;You must
do this:&#8221; and run the program. Explain the result and why it differs from
when the two lines are in the
program.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Convert
the <B>SortedWordCount.java</B> program to use the Java 1.1 IO
Streams.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Repair
the program <B>CADState.java</B> as described in the
text.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">(Intermediate)
In Chapter 7, locate the <B>GreenhouseControls.java</B> example, which consists
of three files. In <B>GreenhouseControls.java</B>, the <B>Restart(&#160;)</B>
inner class has a hard-coded set of events. Change the program so that it reads
the events and their relative times from a text file. (Challenging: Use a
factory method from Chapter 16 to build the
events.)</FONT><A NAME="Chapter_11"></A></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn44" HREF="#fnB44">[44]</A><FONT FACE="Georgia" SIZE=2>
In <I>Design Patterns</I>, Erich Gamma <I>et al.</I>, Addison-Wesley 1995.
Described later in this book.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn45" HREF="#fnB45">[45]</A><FONT FACE="Georgia" SIZE=2>
Perhaps by the time you read this, the bug will be fixed.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter09.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter11.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/04/2000</P></DIV>

</BODY>

</HTML>
