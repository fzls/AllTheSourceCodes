<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:Tjava14.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/04/2000
Translation Time:23:25:01
Translation Platform:Win32
Number of Output files:27
This File:Chapter08.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>8: Holding  your objects</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/TIJ2/index.html">2nd Edition</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/javaCD2.html">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 1st edition</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;1998 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter07.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter09.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_8"></A><A NAME="_Toc375545346"></A><A NAME="_Toc407441452"></A><A NAME="_Toc408018562"></A><A NAME="Heading239"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
8: Holding <BR>your objects<A NAME="OLE_LINK2"></A></H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>It&#8217;s a fairly
simple program that has only a fixed quantity of objects with known
lifetimes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, your programs will
always be creating new objects based on some criteria that will be known only at
the time the program is running. You won&#8217;t know until run-time the
quantity or even the exact type of the objects you need. To solve the general
programming problem, you need to create any number of objects, anytime,
anywhere. So you can&#8217;t rely on creating a named handle to hold each one of
your objects:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>MyObject myHandle;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">since you&#8217;ll never know how
many of these things you&#8217;ll actually need.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To solve this rather essential
problem, Java has several ways to hold objects (or rather, handles to objects).
The built-in type is the array, which has been discussed before and will get
additional coverage in this chapter. Also, the Java utilities library has some
<A NAME="Index716"></A><I>collection classes</I> (also known as
<A NAME="Index717"></A><I>container classes</I>, but that term is used by the
AWT so &#8220;collection&#8221; will be used here) that provide more
sophisticated ways to hold and even manipulate your objects. This will comprise
the remainder of this
chapter.</FONT><A NAME="_Toc375545347"></A><A NAME="_Toc408018563"></A><BR></P></DIV>
<A NAME="Heading240"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Arrays</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most of the necessary introduction
to <A NAME="Index718"></A>arrays is in the last section of Chapter 4, which
shows how you define and initialize an array. Holding objects is the focus of
this chapter, and an array is just one way to hold objects. But there are a
number of other ways to hold objects, so what makes an array
special?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are two issues that
distinguish arrays from other types of collections:
<A NAME="Index719"></A>efficiency and <A NAME="Index720"></A>type. The array is
the most efficient way that Java provides to store and access a sequence of
objects (actually, object handles). The array is a simple linear sequence, which
makes element access fast, but you pay for this speed: when you create an array
object, its size is fixed and cannot be changed for the lifetime of that array
object. You might suggest creating an array of a particular size and then, if
you run out of space, creating a new one and moving all the handles from the old
one to the new one. This is the behavior of the <B>Vector</B> class, which will
be studied later in the chapter. However, because of the overhead of this size
flexibility, a <B>Vector</B> is measurably less efficient than an
array.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index721"></A><B>vector</B> class in C++ <I>does</I> know the type of
objects it holds, but it has a different drawback when compared with arrays in
Java: the C++ <B>vector</B>&#8217;s <B>operator[]</B> doesn&#8217;t do bounds
checking, so you can run past the end. (It&#8217;s possible, however, to ask how
big the <B>vector</B> is, and the <B>at(&#160;)</B> method <I>does</I> perform
bounds checking.) In Java, you get bounds checking regardless of whether
you&#8217;re using an array or a collection &#8211; you&#8217;ll get a
<A NAME="Index722"></A><B>RuntimeException</B> if you exceed the bounds. As
you&#8217;ll learn in Chapter 9, this type of exception indicates a programmer
error and thus you don&#8217;t need to check for it in your code. As an aside,
the reason the C++ <B>vector</B> doesn&#8217;t check bounds with every access is
speed &#8211; in Java you have the constant performance overhead of bounds
checking all the time for both arrays and collections.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The other generic collection
classes that will be studied in this chapter,
<A NAME="Index723"></A><B>Vector</B>, <A NAME="Index724"></A><B>Stack</B>, and
<A NAME="Index725"></A><B>Hashtable</B>, all deal with objects as if they had no
specific type. That is, they treat them as type
<A NAME="Index726"></A><B>Object</B>, the root class of all classes in Java.
This works fine from one standpoint: you need to build only one collection, and
any Java object will go into that collection. (Except for primitives &#8211;
these can be placed in collections as constants using the Java primitive wrapper
classes, or as changeable values by wrapping in your own class.) This is the
second place where an array is superior to the generic collections: when you
create an array, you create it to hold a specific type. This means that you get
compile-time type checking to prevent you from putting the wrong type in, or
mistaking the type that you&#8217;re extracting. Of course, Java will prevent
you from sending an inappropriate message to an object, either at compile-time
or at run-time. So it&#8217;s not as if it&#8217;s riskier one way or the other,
it&#8217;s just nicer if the compiler points it out to you, faster at run-time,
and there&#8217;s less likelihood that the end user will get surprised by an
exception.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For efficiency and type checking
it&#8217;s always worth trying to use an array if you can. However, when
you&#8217;re trying to solve a more general problem arrays can be too
restrictive. After looking at arrays, the rest of this chapter will be devoted
to the collection classes provided by
Java.</FONT><A NAME="_Toc375545348"></A><A NAME="_Toc408018564"></A><BR></P></DIV>
<A NAME="Heading241"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Arrays are first-class
objects<BR><A NAME="Index727"></A><A NAME="Index728"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Regardless of what type of array
you&#8217;re working with, the array identifier is actually a handle to a true
object that&#8217;s created on the heap. The heap object can be created either
implicitly, as part of the array initialization syntax, or explicitly with a
<B>new</B> expression. Part of the heap object (in fact, the only field or
method you can access) is the read-only <B>length</B> member that tells you how
many elements can be stored in that array object.
<A NAME="Index729"></A><A NAME="Index730"></A>The &#8216;<B>[]</B>&#8217; syntax
is the only other access that you have to the array object.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example shows the
various ways that an array can be initialized, and how the array handles can be
assigned to different array objects. It also shows that
<A NAME="Index731"></A>arrays of objects and <A NAME="Index732"></A>arrays of
primitives are almost identical in their use. The only difference is that arrays
of objects hold handles while arrays of primitives hold the primitive values
directly. </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ArraySize.java</font>
<font color=#009900>// Initialization &amp; re-assignment of arrays</font>
<font color=#0000ff>package</font> c08;

<font color=#0000ff>class</font> Weeble {} <font color=#009900>// A small mythical creature</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArraySize {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Arrays of objects:</font>
    Weeble[] a; <font color=#009900>// Null handle</font>
    Weeble[] b = <font color=#0000ff>new</font> Weeble[5]; <font color=#009900>// Null handles</font>
    Weeble[] c = <font color=#0000ff>new</font> Weeble[4];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; c.length; i++)
      c[i] = <font color=#0000ff>new</font> Weeble();
    Weeble[] d = {
      <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble()
    };
    <font color=#009900>// Compile error: variable a not initialized:</font>
    <font color=#009900>//!System.out.println("a.length=" + a.length);</font>
    System.out.println(<font color=#004488>"b.length = "</font> + b.length);
    <font color=#009900>// The handles inside the array are </font>
    <font color=#009900>// automatically initialized to null:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; b.length; i++)
      System.out.println(<font color=#004488>"b["</font> + i + <font color=#004488>"]="</font> + b[i]);
    System.out.println(<font color=#004488>"c.length = "</font> + c.length);
    System.out.println(<font color=#004488>"d.length = "</font> + d.length);
    a = d;
    System.out.println(<font color=#004488>"a.length = "</font> + a.length);
    <font color=#009900>// Java 1.1 initialization syntax:</font>
    a = <font color=#0000ff>new</font> Weeble[] {
      <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble()
    };
    System.out.println(<font color=#004488>"a.length = "</font> + a.length);

    <font color=#009900>// Arrays of primitives:</font>
    <font color=#0000ff>int</font>[] e; <font color=#009900>// Null handle</font>
    <font color=#0000ff>int</font>[] f = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[5];
    <font color=#0000ff>int</font>[] g = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[4];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; g.length; i++)
      g[i] = i*i;
    <font color=#0000ff>int</font>[] h = { 11, 47, 93 };
    <font color=#009900>// Compile error: variable e not initialized:</font>
    <font color=#009900>//!System.out.println("e.length=" + e.length);</font>
    System.out.println(<font color=#004488>"f.length = "</font> + f.length);
    <font color=#009900>// The primitives inside the array are</font>
    <font color=#009900>// automatically initialized to zero:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; f.length; i++)
      System.out.println(<font color=#004488>"f["</font> + i + <font color=#004488>"]="</font> + f[i]);
    System.out.println(<font color=#004488>"g.length = "</font> + g.length);
    System.out.println(<font color=#004488>"h.length = "</font> + h.length);
    e = h;
    System.out.println(<font color=#004488>"e.length = "</font> + e.length);
    <font color=#009900>// Java 1.1 initialization syntax:</font>
    e = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[] { 1, 2 };
    System.out.println(<font color=#004488>"e.length = "</font> + e.length);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the output from the
program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>b.length = 5
b[0]=<font color=#0000ff>null</font>
b[1]=<font color=#0000ff>null</font>
b[2]=<font color=#0000ff>null</font>
b[3]=<font color=#0000ff>null</font>
b[4]=<font color=#0000ff>null</font>
c.length = 4
d.length = 3
a.length = 3
a.length = 2
f.length = 5
f[0]=0
f[1]=0
f[2]=0
f[3]=0
f[4]=0
g.length = 4
h.length = 3
e.length = 3
e.length = 2</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The array <B>a</B> is initially
just a <A NAME="Index733"></A><B>null</B> handle, and the compiler prevents you
from doing anything with this handle until you&#8217;ve properly initialized it.
The array <B>b</B> is initialized to point to an array of <B>Weeble</B> handles,
but no actual <B>Weeble</B> objects are ever placed in that array. However, you
can still ask what the size of the array is, since <B>b</B> is pointing to a
legitimate object. This brings up a slight drawback: you can&#8217;t find out
how many elements are actually <I>in</I> the array, since <B>length</B> tells
you only how many elements <I>can</I> be placed in the array; that is, the size
of the array object, not the number of elements it actually holds. However, when
an array object is created its handles are automatically initialized to
<B>null</B> so you can see whether a particular array slot has an object in it
by checking to see whether it&#8217;s <B>null</B>. Similarly, an array of
primitives is automatically initialized to zero for numeric types, <B>null
</B>for <B>char</B>, and<B> false</B> for <B>boolean</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Array <B>c</B> shows the creation
of the array object followed by the assignment of <B>Weeble</B> objects to all
the slots in the array. Array <B>d</B> shows the &#8220;aggregate
initialization&#8221; syntax that causes the array object to be created
(implicitly with <B>new</B> on the heap, just like for array <B>c</B>)
<I>and</I> initialized with <B>Weeble</B> objects, all in one
statement.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The expression</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a = d;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">shows how you can take a handle
that&#8217;s attached to one array object and assign it to another array object,
just as you can do with any other type of object handle. Now both <B>a</B> and
<B>d</B> are pointing to the same array object on the heap.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index734"></A><FONT FACE="Georgia">Java 1.1
adds a new array initialization syntax, which could be thought of as a
&#8220;dynamic aggregate initialization.&#8221; The Java
1.0<A NAME="Index735"></A> aggregate initialization used by <B>d</B> must be
used at the point of <B>d</B>&#8217;s definition, but with the Java 1.1 syntax
you can create and initialize an array object anywhere. For example, suppose
<B>hide(&#160;)</B> is a method that takes an array of <B>Weeble</B> objects.
You could call it by saying:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>hide(d);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">but in Java 1.1 you can also
dynamically create the array you want to pass as the argument:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>hide(<font color=#0000ff>new</font> Weeble[] { <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble() });</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This new syntax provides a more
convenient way to write code in some situations.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second part of the above
example shows that primitive arrays work just like object arrays <I>except</I>
that primitive arrays hold the primitive values
directly.</FONT><A NAME="_Toc375545349"></A><BR></P></DIV>
<A NAME="Heading242"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Collections of primitives<BR><A NAME="Index736"></A><A NAME="Index737"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Collection classes can hold only
handles to objects. An array, however, can be created to hold primitives
directly, as well as handles to objects. It <I>is</I> possible to use the
&#8220;wrapper&#8221; classes such as <B>Integer</B>, <B>Double,</B> etc. to
place primitive values inside a collection, but as you&#8217;ll see later in
this chapter in the <B>WordCount.java</B> example, the wrapper classes for
primitives are only somewhat useful anyway. Whether you put primitives in arrays
or wrap them in a class that&#8217;s placed in a collection is a question of
efficiency. It&#8217;s much more efficient to create and access an array of
primitives than a collection of wrapped primitives.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, if you&#8217;re using a
primitive type and you need the flexibility of a collection that automatically
expands when more space is needed, the array won&#8217;t work and you&#8217;re
forced to use a collection of wrapped primitives. You might think that there
should be a specialized type of <B>Vector</B> for each of the primitive data
types, but Java doesn&#8217;t provide this for you. Some sort of templatizing
mechanism might someday provide a better way for Java to handle this
problem.</FONT><A NAME="fnB32" HREF="#fn32">[32]</A><A NAME="_Toc408018565"></A><BR></P></DIV>
<A NAME="Heading243"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Returning an array</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Suppose you&#8217;re writing a
method and you don&#8217;t just want to return one thing, but a whole bunch of
things. Languages like C and C++ make this difficult because you can&#8217;t
just return an array, only a pointer to an array. This introduces problems
because it becomes messy to control the lifetime of the array, which easily
leads to memory leaks.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java takes a similar approach, but
you just &#8220;return an array.&#8221; Actually, of course, you&#8217;re
returning a handle to an array, but with Java you never worry about
responsibility for that array &#8211; it will be around as long as you need it,
and the garbage collector will clean it up when you&#8217;re
done.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example, consider returning
an array of <B>String</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: IceCream.java</font>
<font color=#009900>// Returning arrays from methods</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IceCream {
  <font color=#0000ff>static</font> String[] flav = {
    <font color=#004488>"Chocolate"</font>, <font color=#004488>"Strawberry"</font>,
    <font color=#004488>"Vanilla Fudge Swirl"</font>, <font color=#004488>"Mint Chip"</font>,
    <font color=#004488>"Mocha Almond Fudge"</font>, <font color=#004488>"Rum Raisin"</font>,
    <font color=#004488>"Praline Cream"</font>, <font color=#004488>"Mud Pie"</font> 
  };
  <font color=#0000ff>static</font> String[] flavorSet(<font color=#0000ff>int</font> n) {
    <font color=#009900>// Force it to be positive &amp; within bounds:</font>
    n = Math.abs(n) % (flav.length + 1);
    String[] results = <font color=#0000ff>new</font> String[n];
    <font color=#0000ff>int</font>[] picks = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[n];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; picks.length; i++)
      picks[i] = -1;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; picks.length; i++) {
      retry:
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
        <font color=#0000ff>int</font> t =
          (<font color=#0000ff>int</font>)(Math.random() * flav.length);
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; i; j++)
          <font color=#0000ff>if</font>(picks[j] == t) <font color=#0000ff>continue</font> retry;
        picks[i] = t;
        results[i] = flav[t];
        <font color=#0000ff>break</font>;
      }
    }
    <font color=#0000ff>return</font> results;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 20; i++) {
      System.out.println(
        <font color=#004488>"flavorSet("</font> + i + <font color=#004488>") = "</font>);
      String[] fl = flavorSet(flav.length);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; fl.length; j++)
        System.out.println(<font color=#004488>"\t"</font> + fl[j]);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The method <B>flavorSet(&#160;)</B>
creates an array of <B>String</B> called <B>results</B>. The size of this array
is <B>n</B>, determined by the argument you pass into the method. Then it
proceeds to choose flavors randomly from the array <B>flav</B> and place them
into <B>results</B>, which it finally returns. Returning an array is just like
returning any other object &#8211; it&#8217;s a handle. It&#8217;s not important
that the array was created within <B>flavorSet(&#160;)</B>, or that the array
was created anyplace else, for that matter. The garbage collector takes care of
cleaning up the array when you&#8217;re done with it, and the array will persist
for as long as you need it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an aside, notice that when
<B>flavorSet(&#160;)</B> chooses flavors randomly, it ensures that a random
choice hasn&#8217;t been picked before. This is performed in a seemingly
infinite <B>while</B> loop that keeps making random choices until it finds one
that&#8217;s not already in the <B>picks</B> array. (Of course, a <B>String</B>
comparison could also have been performed to see if the random choice was
already in the <B>results</B> array, but <B>String</B> comparisons are
inefficient.) If it&#8217;s successful it adds the entry and <B>break</B>s out
to go find the next one (<B>i </B>gets incremented). But if <B>t</B> is a number
that&#8217;s already in <B>picks</B>, then a labeled <B>continue</B> is used to
jump back two levels, which forces a new <B>t</B> to be selected. It&#8217;s
particularly convincing to watch this happen with a debugger.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>main(&#160;)</B> prints out 20
full sets of flavors, so you can see that <B>flavorSet(&#160;)</B> chooses the
flavors in a random order each time. It&#8217;s easiest to see this if you
redirect the output into a file. And while you&#8217;re looking at the file,
remember, you&#8217;re not really hungry. (You just <I>want</I> the ice cream,
you don&#8217;t <I>need</I>
it.)</FONT><A NAME="_Toc375545350"></A><A NAME="_Toc408018566"></A><BR></P></DIV>
<A NAME="Heading244"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Collections</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To summarize what we&#8217;ve seen
so far, your first, most efficient choice to hold a group of objects should be
an array, and you&#8217;re forced into this choice if you want to hold a group
of primitives. In the remainder of the chapter we&#8217;ll look at the more
general case, when you don&#8217;t know at the time you&#8217;re writing the
program how many objects you&#8217;re going to need, or if you need a more
sophisticated way to store your objects. Java provides four types of
<A NAME="Index738"></A><I>collection classes</I> to solve this problem:
<A NAME="Index739"></A><B>Vector</B>, <A NAME="Index740"></A><B>BitSet</B>,<B>
<A NAME="Index741"></A>Stack</B>, and <A NAME="Index742"></A><B>Hashtable</B>.
Although compared to other languages that provide collections this is a fairly
meager supply, you can nonetheless solve a surprising number of problems using
these tools.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Among their other characteristics
&#8211; <B>Stack</B>, for example, implements a LIFO (last-in, first-out)
sequence, and <B>Hashtable</B> is an <A NAME="Index743"></A><I>associative
array</I> that lets you associate any object with any other object &#8211; the
Java collection classes will automatically resize themselves. Thus, you can put
in any number of objects and you don&#8217;t need to worry about how big to make
the collection while you&#8217;re writing the
program.</FONT><A NAME="_Ref348399494"></A><A NAME="_Toc375545351"></A><A NAME="_Toc408018567"></A><BR></P></DIV>
<A NAME="Heading245"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Disadvantage: unknown type</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The &#8220;disadvantage&#8221; to
using the Java collections is that you lose type information when you put an
object into a collection. This happens because, when the collection was written,
the programmer of that collection had no idea what specific type you wanted to
put in the collection, and making the collection hold only your type would
prevent it from being a general-purpose tool. So instead, the collection holds
handles to objects of type <B>Object</B>, which is of course every object in
Java, since it&#8217;s the root of all the classes. (Of course, this
doesn&#8217;t include primitive types, since they aren&#8217;t inherited from
anything.) This is a great solution, except for these reasons:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	Since the type information is thrown away when
you put an object handle into a collection, <I>any</I> type of object can be put
into your collection, even if you mean it to hold only, say, cats. Someone could
just as easily put a dog into the
collection.</FONT><LI><FONT FACE="Georgia">	Since the type information is
lost, the only thing the collection knows it holds is a handle to an
<B>Object</B>. You must perform a <A NAME="Index744"></A>cast to the correct
type before you use
it.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">On the up side, Java
won&#8217;t let you <I>misuse</I> the objects that you put into a collection. If
you throw a dog into a collection of cats, then go through and try to treat
everything in the collection as a cat, you&#8217;ll get an exception when you
get to the dog. In the same vein, if you try to cast the dog handle that you
pull out of the cat collection into a cat, you&#8217;ll get an exception at
run-time.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CatsAndDogs.java</font>
<font color=#009900>// Simple collection example (Vector)</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Cat {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> catNumber;
  Cat(<font color=#0000ff>int</font> i) {
    catNumber = i;
  }
  <font color=#0000ff>void</font> print() {
    System.out.println(<font color=#004488>"Cat #"</font> + catNumber);
  }
}

<font color=#0000ff>class</font> Dog {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> dogNumber;
  Dog(<font color=#0000ff>int</font> i) {
    dogNumber = i;
  }
  <font color=#0000ff>void</font> print() {
    System.out.println(<font color=#004488>"Dog #"</font> + dogNumber);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CatsAndDogs {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector cats = <font color=#0000ff>new</font> Vector();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 7; i++)
      cats.addElement(<font color=#0000ff>new</font> Cat(i));
    <font color=#009900>// Not a problem to add a dog to cats:</font>
    cats.addElement(<font color=#0000ff>new</font> Dog(7));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cats.size(); i++)
      ((Cat)cats.elementAt(i)).print();
    <font color=#009900>// Dog is detected only at run-time</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that using a
<B>Vector</B> is straightforward: create one, put objects in using
<A NAME="Index745"></A><A NAME="Index746"></A><B>addElement(&#160;),</B> and
later get them out with
<A NAME="Index747"></A><A NAME="Index748"></A><B>elementAt(&#160;).</B> (Note
that <B>Vector</B> has a method
<A NAME="Index749"></A><A NAME="Index750"></A><B>size(&#160;)</B> to let you
know how many elements have been added so you don&#8217;t inadvertently run off
the end and cause an exception.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The classes <B>Cat</B> and
<B>Dog</B> are distinct &#8211; they have nothing in common except that they are
<B>Object</B>s. (If you don&#8217;t explicitly say what class you&#8217;re
inheriting from, you automatically inherit from <B>Object.</B>) The
<B>Vector</B> class, which comes from <B>java.util</B>, holds <B>Object</B>s, so
not only can you put <B>Cat</B> objects into this collection using the <B>Vector
</B>method <B>addElement(&#160;)</B>, but you can also add <B>Dog</B> objects
without complaint at either compile-time or run-time. When you go to fetch out
what you think are <B>Cat</B> objects using the <B>Vector</B> method
<B>elementAt(&#160;)</B>, you get back a handle to an <B>Object</B> that you
must cast to a <B>Cat</B>. Then you need to surround the entire expression with
parentheses to force the evaluation of the cast before calling the
<B>print(&#160;)</B> method for <B>Cat</B>, otherwise you&#8217;ll get a syntax
error. Then, at run-time, when you try to cast the <B>Dog</B> object to a
<B>Cat</B>, you&#8217;ll get an exception.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is more than just an
annoyance. It&#8217;s something that can create some difficult-to-find bugs. If
one part (or several parts) of a program inserts objects into a collection, and
you discover only in a separate part of the program through an exception that a
bad object was placed in the collection, then you must find out where the bad
insert occurred. You do this by code inspection, which is about the worst
debugging tool you have. On the upside, it&#8217;s convenient to start with some
standardized collection classes for programming, despite the scarcity and
awkwardness.</FONT><BR></P></DIV>
<A NAME="Heading246"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Sometimes it works right anyway</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It turns out that in some cases
things seem to work correctly without casting back to your original type. The
first case is quite special: the <B>String</B> class has some extra help from
the compiler to make it work smoothly. Whenever the compiler expects a
<B>String</B> object and it hasn&#8217;t got one, it will automatically call the
<A NAME="Index751"></A><A NAME="Index752"></A><B>toString(&#160;)</B> method
that&#8217;s defined in <B>Object</B> and can be overridden by any Java class.
This method produces the desired <B>String</B> object, which is then used
wherever it was wanted.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, all you need to do to make
objects of your class print out is to override the <B>toString(&#160;)</B>
method, as shown in the following example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: WorksAnyway.java</font>
<font color=#009900>// In special cases, things just seem</font>
<font color=#009900>// to work correctly.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Mouse {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> mouseNumber;
  Mouse(<font color=#0000ff>int</font> i) {
    mouseNumber = i;
  }
  <font color=#009900>// Magic method:</font>
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"This is Mouse #"</font> + mouseNumber;
  }
  <font color=#0000ff>void</font> print(String msg) {
    <font color=#0000ff>if</font>(msg != <font color=#0000ff>null</font>) System.out.println(msg);
    System.out.println(
      <font color=#004488>"Mouse number "</font> + mouseNumber);
  }
}

<font color=#0000ff>class</font> MouseTrap {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> caughtYa(Object m) {
    Mouse mouse = (Mouse)m; <font color=#009900>// Cast from Object</font>
    mouse.print(<font color=#004488>"Caught one!"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WorksAnyway {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector mice = <font color=#0000ff>new</font> Vector();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      mice.addElement(<font color=#0000ff>new</font> Mouse(i));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; mice.size(); i++) {
      <font color=#009900>// No cast necessary, automatic call</font>
      <font color=#009900>// to Object.toString():</font>
      System.out.println(
        <font color=#004488>"Free mouse: "</font> + mice.elementAt(i));
      MouseTrap.caughtYa(mice.elementAt(i));
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see the redefinition of
<B>toString(&#160;)</B> in <B>Mouse</B>. In the second <B>for</B> loop in
<B>main(&#160;)</B> you find the statement:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println(<font color=#004488>"Free mouse: "</font> + mice.elementAt(i));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After the &#8216;<B>+</B>&#8217;
sign the compiler expects to see a
<A NAME="Index753"></A><A NAME="Index754"></A><B>String</B> object.
<B>elementAt(&#160;)</B> produces an <B>Object</B>, so to get the desired
<B>String</B> the compiler implicitly calls <B>toString(&#160;)</B>.
Unfortunately, you can work this kind of magic only with <B>String</B>; it
isn&#8217;t available for any other type.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A second approach to hiding the
cast has been placed inside <B>Mousetrap</B>. The <B>caughtYa(&#160;)</B> method
accepts not a <B>Mouse</B>, but an <B>Object,</B> which it then casts to a
<B>Mouse</B>. This is quite presumptuous, of course, since by accepting an
<B>Object</B> anything could be passed to the method. However, if the cast is
incorrect &#8211; if you passed the wrong type &#8211; you&#8217;ll get an
exception at run-time. This is not as good as compile-time checking but
it&#8217;s still robust. Note that in the use of this method:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>MouseTrap.caughtYa(mice.elementAt(i));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">no cast is
necessary.</FONT><BR></P></DIV>
<A NAME="Heading247"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Making a type-conscious
Vector<BR><A NAME="Index755"></A><A NAME="Index756"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might not want to give up on
this issue just yet. A more ironclad solution is to create a new class using the
<B>Vector</B>, such that it will accept only your type and produce only your
type:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: GopherVector.java</font>
<font color=#009900>// A type-conscious Vector</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Gopher {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> gopherNumber;
  Gopher(<font color=#0000ff>int</font> i) {
    gopherNumber = i;
  }
  <font color=#0000ff>void</font> print(String msg) {
    <font color=#0000ff>if</font>(msg != <font color=#0000ff>null</font>) System.out.println(msg);
    System.out.println(
      <font color=#004488>"Gopher number "</font> + gopherNumber);
  }
}

<font color=#0000ff>class</font> GopherTrap {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> caughtYa(Gopher g) {
    g.print(<font color=#004488>"Caught one!"</font>);
  }
}

<font color=#0000ff>class</font> GopherVector {
  <font color=#0000ff>private</font> Vector v = <font color=#0000ff>new</font> Vector();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> addElement(Gopher m) {
    v.addElement(m);
  }
  <font color=#0000ff>public</font> Gopher elementAt(<font color=#0000ff>int</font> index) {
    <font color=#0000ff>return</font> (Gopher)v.elementAt(index);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> size() { <font color=#0000ff>return</font> v.size(); }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    GopherVector gophers = <font color=#0000ff>new</font> GopherVector();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      gophers.addElement(<font color=#0000ff>new</font> Gopher(i));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; gophers.size(); i++)
      GopherTrap.caughtYa(gophers.elementAt(i));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is similar to the previous
example, except that the new <B>GopherVector</B> class has a <B>private
</B>member of type <B>Vector</B> (inheriting from <B>Vector</B> tends to be
frustrating, for reasons you&#8217;ll see later), and methods just like
<B>Vector</B>. However, it doesn&#8217;t accept and produce generic
<B>Object</B>s, only <B>Gopher</B> objects.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because a <B>GopherVector</B> will
accept only a <B>Gopher</B>, if you were to say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>gophers.addElement(<font color=#0000ff>new</font> Pigeon());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">you would get an error message
<I>at compile time</I>. This approach, while more tedious from a coding
standpoint, will tell you immediately if you&#8217;re using a type
improperly.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that no cast is necessary when
using <B>elementAt(&#160;)</B> &#8211; it&#8217;s always a
<B>Gopher</B>.</FONT><BR></P></DIV>
<A NAME="Heading248"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Parameterized types</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This kind of problem isn&#8217;t
isolated &#8211; there are numerous cases in which you need to create new types
based on other types, and in which it is useful to have specific type
information at compile-time. This is the concept of a
<A NAME="Index757"></A><A NAME="Index758"></A><I>parameterized type</I>. In C++,
this is directly supported by the language in
<A NAME="Index759"></A><A NAME="Index760"></A><I>templates</I>. At one point,
Java had reserved the keyword <A NAME="Index761"></A><B>generic</B> to someday
support parameterized types, but it&#8217;s uncertain if this will ever
occur.</FONT><A NAME="_Toc375545352"></A><A NAME="_Toc408018568"></A><BR></P></DIV>
<A NAME="Heading249"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Enumerators (iterators)</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In any collection class, you must
have a way to put things in and a way to get things out. After all, that&#8217;s
the primary job of a collection &#8211; to hold things. In the
<A NAME="Index762"></A><B>Vector</B>, <B>addElement(&#160;)</B> is the way that
you insert objects, and <B>elementAt(&#160;)</B> is <I>one</I> way to get things
out. <B>Vector</B> is quite flexible &#8211; you can select anything at any
time, and select multiple elements at once using different
indexes.<A NAME="Index763"></A><A NAME="Index764"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to start thinking at a
higher level, there&#8217;s a drawback: you need to know the exact type of the
collection in order to use it. This might not seem bad at first, but what if you
start out using a <B>Vector</B>, and later on in your program you decide, for
efficiency, that you want to change to a <B>List</B> (which is part of the Java
1.2<A NAME="Index765"></A> collections library)? Or you&#8217;d like to write a
piece of code that doesn&#8217;t know or care what type of collection it&#8217;s
working with.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The concept of an
<A NAME="Index766"></A><I>iterator </I>can be used to achieve this next level of
abstraction. This is an object whose job is to move through a sequence of
objects and select each object in that sequence without the client programmer
knowing or caring about the underlying structure of that sequence. In addition,
an iterator is usually what&#8217;s called a &#8220;light-weight&#8221; object;
that is, one that&#8217;s cheap to create. For that reason, you&#8217;ll often
find seemingly strange constraints for iterators; for example, some iterators
can move in only one direction.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java
<B>Enumeration</B></FONT><A NAME="fnB33" HREF="#fn33">[33]</A><FONT FACE="Georgia">
is an example of an iterator with these kinds of constraints. There&#8217;s not
much you can do with one except: <A NAME="Index767"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	Ask a collection to hand you an <B>Enumeration
</B>using a method called <B>elements(&#160;)</B>.<B> </B>This <B>Enumeration
</B>will be ready to return the first element in the sequence on your first call
to its <B>nextElement(&#160;)</B>
method.</FONT><LI><FONT FACE="Georgia">	Get the next object in the
sequence with
<B>nextElement(&#160;).</B></FONT><LI><FONT FACE="Georgia">	See if there
<I>are</I> any more objects in the sequence with
<B>hasMoreElements(&#160;).</B></FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That&#8217;s
all. It&#8217;s a simple implementation of an iterator, but still powerful. To
see how it works, let&#8217;s revisit the <B>CatsAndDogs.java</B> program from
earlier in the chapter. In the original version, the method
<B>elementAt(&#160;)</B> was used to select each element, but in the following
modified version an enumeration is used:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CatsAndDogs2.java</font>
<font color=#009900>// Simple collection with Enumeration</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Cat2 {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> catNumber;
  Cat2(<font color=#0000ff>int</font> i) {
    catNumber = i;
  }
  <font color=#0000ff>void</font> print() {
    System.out.println(<font color=#004488>"Cat number "</font> +catNumber);
  }
}

<font color=#0000ff>class</font> Dog2 {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> dogNumber;
  Dog2(<font color=#0000ff>int</font> i) {
    dogNumber = i;
  }
  <font color=#0000ff>void</font> print() {
    System.out.println(<font color=#004488>"Dog number "</font> +dogNumber);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CatsAndDogs2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector cats = <font color=#0000ff>new</font> Vector();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 7; i++)
      cats.addElement(<font color=#0000ff>new</font> Cat2(i));
    <font color=#009900>// Not a problem to add a dog to cats:</font>
    cats.addElement(<font color=#0000ff>new</font> Dog2(7));
    Enumeration e = cats.elements();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      ((Cat2)e.nextElement()).print();
    <font color=#009900>// Dog is detected only at run-time</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the only change is
in the last few lines. Instead of:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cats.size(); i++)
      ((Cat)cats.elementAt(i)).print();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">an <B>Enumeration</B> is used to
step through the sequence:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>while</font>(e.hasMoreElements())
      ((Cat2)e.nextElement()).print();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With the <B>Enumeration</B>, you
don&#8217;t need to worry about the number of elements in the collection.
That&#8217;s taken care of for you by
<A NAME="Index768"></A><A NAME="Index769"></A><B>hasMoreElements(&#160;)</B> and
<A NAME="Index770"></A><A NAME="Index771"></A><B>nextElement(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As another example, consider the
creation of a general-purpose printing method:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: HamsterMaze.java</font>
<font color=#009900>// Using an Enumeration</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Hamster {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> hamsterNumber;
  Hamster(<font color=#0000ff>int</font> i) {
    hamsterNumber = i;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"This is Hamster #"</font> + hamsterNumber;
  }
}

<font color=#0000ff>class</font> Printer {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printAll(Enumeration e) {
    <font color=#0000ff>while</font>(e.hasMoreElements())
      System.out.println(
        e.nextElement().toString());
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> HamsterMaze {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector v = <font color=#0000ff>new</font> Vector();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      v.addElement(<font color=#0000ff>new</font> Hamster(i));
    Printer.printAll(v.elements());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Look closely at the printing
method:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>static</font> <font color=#0000ff>void</font> printAll(Enumeration e) {
  <font color=#0000ff>while</font>(e.hasMoreElements())
    System.out.println(
      e.nextElement().toString());
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that there&#8217;s no
information about the type of sequence. All you have is an <B>Enumeration</B>,
and that&#8217;s all you need to know about the sequence: that you can get the
next object, and that you can know when you&#8217;re at the end. This idea of
taking a collection of objects and passing through it to perform an operation on
each one is powerful and will be seen throughout this book.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This particular example is even
more generic, since it uses the ubiquitous
<A NAME="Index772"></A><B>toString(&#160;)</B> method (ubiquitous only because
it&#8217;s part of the <B>Object</B> class). An alternative way to call print
(although probably slightly less efficient, if you could even notice the
difference) is: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println(<font color=#004488>""</font> + e.nextElement());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><A NAME="Index773"></A><A NAME="Index774"></A><FONT FACE="Georgia">which
uses the &#8220;automatic conversion to <B>String</B>&#8221; that&#8217;s wired
into Java. When the compiler sees a <B>String</B>, followed by a
&#8216;<B>+</B>&#8217;, it expects another <B>String</B> to follow and calls
<B>toString(&#160;)</B> automatically. (In <A NAME="Index775"></A>Java 1.1, the
first <B>String</B> is unnecessary; any object will be converted to a
<B>String.</B>) You can also perform a cast, which has the effect of calling
<B>toString(&#160;)</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println((String)e.nextElement());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, however, you&#8217;ll
want to do something more than call <B>Object</B> methods, so you&#8217;ll run
up against the type-casting issue again. You must assume you&#8217;ve gotten an
<B>Enumeration</B> to a sequence of the particular type you&#8217;re interested
in, and cast the resulting objects to that type (getting a run-time exception if
you&#8217;re
wrong).</FONT><A NAME="_Toc375545353"></A><A NAME="_Toc408018569"></A><BR></P></DIV>
<A NAME="Heading250"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Types of collections</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The standard Java
1.0<A NAME="Index776"></A> and 1.1 library comes with a bare minimum set of
collection classes, but they&#8217;re probably enough to get by with for many of
your programming projects. (As you&#8217;ll see at the end of this chapter, Java
1.2<A NAME="Index777"></A> provides a radically redesigned and filled-out
library of collections.)
</FONT><A NAME="_Ref348399519"></A><A NAME="_Toc375545354"></A><A NAME="_Toc408018570"></A><BR></P></DIV>
<A NAME="Heading251"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Vector<BR><A NAME="Index778"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Vector</B> is quite simple
to use, as you&#8217;ve seen so far. Although most of the time you&#8217;ll just
use <B>addElement(&#160;)</B> to insert objects, <B>elementAt(&#160;)</B> to get
them out one at a time, and <B>elements(&#160;)</B> to get an <B>Enumeration</B>
to the sequence, there&#8217;s also a set of other methods that can be useful.
As usual with the Java libraries, we won&#8217;t use or talk about them all
here, but be sure to look them up in the electronic documentation to get a feel
for what they can do.</FONT><BR></P></DIV>
<A NAME="Heading252"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Crashing Java<BR><A NAME="Index779"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java standard collections
contain a <B>toString(&#160;)</B> method so they can produce a <B>String</B>
representation of themselves, including the objects they hold. Inside of
<B>Vector</B>, for example, the <B>toString(&#160;)</B> steps through the
elements of the <B>Vector</B> and calls <B>toString(&#160;)</B> for each one.
Suppose you&#8217;d like to print out the address of your class. It seems to
make sense to simply refer to <B>this </B>(in particular, C++ programmers are
prone to this approach):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CrashJava.java</font>
<font color=#009900>// One way to crash Java</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CrashJava {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"CrashJava address: "</font> + <font color=#0000ff>this</font> + <font color=#004488>"\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector v = <font color=#0000ff>new</font> Vector();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      v.addElement(<font color=#0000ff>new</font> CrashJava());
    System.out.println(v);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It turns out that if you simply
create a <B>CrashJava</B> object and print it out, you&#8217;ll get an endless
sequence of exceptions. However, if you place the <B>CrashJava</B> objects in a
<B>Vector</B> and print out that <B>Vector</B> as shown here, it can&#8217;t
handle it and you don&#8217;t even get an exception; Java just crashes. (But at
least it didn&#8217;t bring down my operating system.) This was tested with Java
1.1<A NAME="Index780"></A>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What&#8217;s happening is automatic
type conversion for <B>String</B>s. When you say: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#004488>"CrashJava address: "</font> + <font color=#0000ff>this</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The compiler sees a <B>String</B>
followed by a &#8216;<B>+</B>&#8217; and<B> </B>something that&#8217;s not a
<B>String</B>, so it tries to convert <B>this</B> to a <B>String</B>. It does
this conversion by calling <B>toString(&#160;)</B>, which produces a
<A NAME="Index781"></A><A NAME="Index782"></A>recursive call. When this occurs
inside a <B>Vector,</B> it appears that the
<A NAME="Index783"></A><A NAME="Index784"></A>stack overflows without the
exception-handling mechanism getting a chance to respond.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you really do want to print the
address of the object in this case, the solution is to call the <B>Object</B>
<B>toString(&#160;)</B> method, which does just that. So instead of saying
<B>this</B>, you&#8217;d say <B>super.toString(&#160;)</B>. (This only works if
you're directly inheriting from <B>Object</B> or if none of your parent classes
have overridden the <B>toString(&#160;)</B>
method).</FONT><A NAME="_Toc375545355"></A><A NAME="_Toc408018571"></A><BR></P></DIV>
<A NAME="Heading253"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
BitSet</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index785"></A><B>BitSet</B> is really a <B>Vector</B> of bits, and it
is used if you want to efficiently store a lot of on-off information. It&#8217;s
efficient only from the standpoint of size; if you&#8217;re looking for
efficient access, it is slightly slower than using an array of some native
type.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, the minimum size of
the <B>BitSet</B> is that of a long: 64 bits. This implies that if you&#8217;re
storing anything smaller, like 8 bits, a <B>BitSet</B> will be wasteful, so
you&#8217;re better off creating your own class to hold your
flags.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In a normal <B>Vector</B>, the
collection will expand as you add more elements. The <B>BitSet</B> does this as
well &#8211; sort of. That is, sometimes it works and sometimes it
doesn&#8217;t, which makes it appear that the Java version 1.0 implementation of
<B>BitSet</B> is just badly done. (It is fixed in Java
1.1.<A NAME="Index786"></A>) The following example shows how the <B>BitSet
</B>works and demonstrates the version 1.0 bug:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Bits.java</font>
<font color=#009900>// Demonstration of BitSet</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Bits {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Random rand = <font color=#0000ff>new</font> Random();
    <font color=#009900>// Take the LSB of nextInt():</font>
    <font color=#0000ff>byte</font> bt = (<font color=#0000ff>byte</font>)rand.nextInt();
    BitSet bb = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 7; i &gt;=0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  bt) != 0)
        bb.set(i);
      <font color=#0000ff>else</font>
        bb.clear(i);
    System.out.println(<font color=#004488>"byte value: "</font> + bt);
    printBitSet(bb);

    <font color=#0000ff>short</font> st = (<font color=#0000ff>short</font>)rand.nextInt();
    BitSet bs = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 15; i &gt;=0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  st) != 0)
        bs.set(i);
      <font color=#0000ff>else</font>
        bs.clear(i);
    System.out.println(<font color=#004488>"short value: "</font> + st);
    printBitSet(bs);

    <font color=#0000ff>int</font> it = rand.nextInt();
    BitSet bi = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 31; i &gt;=0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  it) != 0)
        bi.set(i);
      <font color=#0000ff>else</font>
        bi.clear(i);
    System.out.println(<font color=#004488>"int value: "</font> + it);
    printBitSet(bi);

    <font color=#009900>// Test bitsets &gt;= 64 bits:</font>
    BitSet b127 = <font color=#0000ff>new</font> BitSet();
    b127.set(127);
    System.out.println(<font color=#004488>"set bit 127: "</font> + b127);
    BitSet b255 = <font color=#0000ff>new</font> BitSet(65);
    b255.set(255);
    System.out.println(<font color=#004488>"set bit 255: "</font> + b255);
    BitSet b1023 = <font color=#0000ff>new</font> BitSet(512);
<font color=#009900>// Without the following, an exception is thrown</font>
<font color=#009900>// in the Java 1.0 implementation of BitSet:</font>
<font color=#009900>//    b1023.set(1023);</font>
    b1023.set(1024);
    System.out.println(<font color=#004488>"set bit 1023: "</font> + b1023);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printBitSet(BitSet b) {
    System.out.println(<font color=#004488>"bits: "</font> + b);
    String bbits = <font color=#0000ff>new</font> String();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; b.size() ; j++)
      bbits += (b.get(j) ? <font color=#004488>"1"</font> : <font color=#004488>"0"</font>);
    System.out.println(<font color=#004488>"bit pattern: "</font> + bbits);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The random number generator is used
to create a random <B>byte</B>, <B>short</B>, and <B>int</B>, and each one is
transformed into a corresponding bit pattern in a <B>BitSet</B>. This works fine
because a <B>BitSet</B> is 64 bits, so none of these cause it to increase in
size. But in Java 1.0<A NAME="Index787"></A>, when the <B>BitSet</B> is greater
than 64 bits, some strange behavior occurs. If you set a bit that&#8217;s just
one greater than the <B>BitSet</B>&#8217;s currently-allocated storage, it will
expand nicely. But if you try to set bits at higher locations than that without
first just touching the boundary, you&#8217;ll get an exception, since the
<B>BitSet</B> won&#8217;t expand properly in Java 1.0. The example shows a
<B>BitSet</B> of 512 bits being created. The constructor allocates storage for
twice that number of bits. Then if you try to set bit 1024 or greater without
first setting bit 1023, you&#8217;ll throw an exception in
<A NAME="Index788"></A>Java 1.0. Fortunately, this is fixed in Java
1.1,<A NAME="Index789"></A> but avoid using the <B>BitSet</B> if you write code
for Java
1.0.</FONT><A NAME="_Toc375545356"></A><A NAME="_Toc408018572"></A><BR></P></DIV>
<A NAME="Heading254"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Stack</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index790"></A><B>Stack</B> is sometimes referred to as a
&#8220;last-in, first-out&#8221; (LIFO) collection. That is, whatever you
&#8220;push&#8221; on the <B>Stack</B> last is the first item you can
&#8220;pop&#8221; out. Like all of the other collections in Java, what you push
and pop are <B>Object</B>s, so you must cast what you pop.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What&#8217;s rather odd is that
instead of using a <A NAME="Index791"></A><B>Vector</B> as a building block to
create a <B>Stack</B>, <B>Stack </B>is inherited from <B>Vector</B>. So it has
all of the characteristics and behaviors of a <B>Vector</B> <I>plus</I> some
extra <B>Stack</B> behaviors. It&#8217;s difficult to know whether the designers
explicitly decided that this was an especially useful way to do things, or
whether it was just a na&iuml;ve design.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a simple demonstration
of <B>Stack</B> that reads each line from an array and pushes it as a
<B>String</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Stacks.java</font>
<font color=#009900>// Demonstration of Stack Class</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Stacks {
  <font color=#0000ff>static</font> String[] months = { 
    <font color=#004488>"January"</font>, <font color=#004488>"February"</font>, <font color=#004488>"March"</font>, <font color=#004488>"April"</font>,
    <font color=#004488>"May"</font>, <font color=#004488>"June"</font>, <font color=#004488>"July"</font>, <font color=#004488>"August"</font>, <font color=#004488>"September"</font>,
    <font color=#004488>"October"</font>, <font color=#004488>"November"</font>, <font color=#004488>"December"</font> };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Stack stk = <font color=#0000ff>new</font> Stack();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; months.length; i++)
      stk.push(months[i] + <font color=#004488>" "</font>);
    System.out.println(<font color=#004488>"stk = "</font> + stk);
    <font color=#009900>// Treating a stack as a Vector:</font>
    stk.addElement(<font color=#004488>"The last line"</font>);
    System.out.println(
      <font color=#004488>"element 5 = "</font> + stk.elementAt(5));
    System.out.println(<font color=#004488>"popping elements:"</font>);
    <font color=#0000ff>while</font>(!stk.empty())
      System.out.println(stk.pop());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each line in the <B>months
</B>array is inserted into the <B>Stack</B> with <B>push(&#160;)</B>, and later
fetched from the top of the stack with a <B>pop(&#160;)</B>. To make a point,
<B>Vector </B>operations are also performed on the <B>Stack</B> object. This is
possible because, by virtue of inheritance, a <B>Stack</B> <I>is</I> a
<B>Vector</B>. Thus, all operations that can be performed on a <B>Vector</B> can
also be performed on a <B>Stack</B>, such as
<B>elementAt(&#160;)</B>.</FONT><A NAME="_Toc375545357"></A><A NAME="_Toc408018573"></A><BR></P></DIV>
<A NAME="Heading255"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Hashtable<BR><A NAME="Index792"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>Vector</B> allows you to
select from a sequence of objects using a number, so in a sense it associates
numbers to objects. But what if you&#8217;d like to select from a sequence of
objects using some other criterion? A <B>Stack</B> is an example: its selection
criterion is &#8220;the last thing pushed on the stack.&#8221; A powerful twist
on this idea of &#8220;selecting from a sequence&#8221; is alternately termed a
<A NAME="Index793"></A><I>map</I>, a <A NAME="Index794"></A><I>dictionary,</I>
or an <A NAME="Index795"></A><A NAME="Index796"></A><I>associative array</I>.
Conceptually, it seems like a vector, but instead of looking up objects using a
number, you look them up using <I>another object</I>! This is often a key
process in a program.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The concept shows up in Java as the
<B>abstract </B>class<B> Dictionary</B>. The interface for this class is
straightforward: <B>size(&#160;)</B> tells you how many elements are within,
<B>isEmpty(&#160;)</B> is <B>true</B> if there are no elements, <B>put(Object
key, Object value)</B> adds a value (the thing you want), and associates it with
a key (the thing you look it up with). <B>get(Object key)</B> produces the value
given the corresponding key, and <B>remove(Object key)</B> removes the key-value
pair from the list. There are enumerations: <B>keys(&#160;)</B> produces an
<B>Enumeration</B> of the keys, and <B>elements(&#160;)</B> produces an
<B>Enumeration</B> of all the values. That&#8217;s all there is to a
<B>Dictionary</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>Dictionary</B> isn&#8217;t
terribly difficult to implement. Here&#8217;s a simple approach, which uses two
<B>Vector</B>s, one for keys and one for values:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: AssocArray.java</font>
<font color=#009900>// Simple version of a Dictionary</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AssocArray <font color=#0000ff>extends</font> Dictionary {
  <font color=#0000ff>private</font> Vector keys = <font color=#0000ff>new</font> Vector();
  <font color=#0000ff>private</font> Vector values = <font color=#0000ff>new</font> Vector();
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> size() { <font color=#0000ff>return</font> keys.size(); }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> isEmpty() {
    <font color=#0000ff>return</font> keys.isEmpty();
  }
  <font color=#0000ff>public</font> Object put(Object key, Object value) {
    keys.addElement(key);
    values.addElement(value);
    <font color=#0000ff>return</font> key;
  }
  <font color=#0000ff>public</font> Object get(Object key) {
    <font color=#0000ff>int</font> index = keys.indexOf(key);
    <font color=#009900>// indexOf() Returns -1 if key not found:</font>
    <font color=#0000ff>if</font>(index == -1) <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
    <font color=#0000ff>return</font> values.elementAt(index);
  }
  <font color=#0000ff>public</font> Object remove(Object key) {
    <font color=#0000ff>int</font> index = keys.indexOf(key);
    <font color=#0000ff>if</font>(index == -1) <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
    keys.removeElementAt(index);
    Object returnval = values.elementAt(index);
    values.removeElementAt(index);
    <font color=#0000ff>return</font> returnval;
  }
  <font color=#0000ff>public</font> Enumeration keys() {
    <font color=#0000ff>return</font> keys.elements();
  }
  <font color=#0000ff>public</font> Enumeration elements() {
    <font color=#0000ff>return</font> values.elements();
  }
  <font color=#009900>// Test it:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    AssocArray aa = <font color=#0000ff>new</font> AssocArray();
    <font color=#0000ff>for</font>(<font color=#0000ff>char</font> c = 'a'; c &lt;= 'z'; c++)
      aa.put(String.valueOf(c),
             String.valueOf(c)
             .toUpperCase());
    <font color=#0000ff>char</font>[] ca = { 'a', 'e', 'i', 'o', 'u' };
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; ca.length; i++)
      System.out.println(<font color=#004488>"Uppercase: "</font> +
             aa.get(String.valueOf(ca[i])));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first thing you see in the
definition of <B>AssocArray</B> is that it <B>extends Dictionary</B>. This means
that <B>AssocArray</B> <I>is a type of </I><B>Dictionary</B>, so you can make
the same requests of it that you can a <B>Dictionary</B>. If you make your own
<B>Dictionary</B>, as is done here, all you need to do is fill in all the
methods that are in <B>Dictionary</B>. (And you <I>must</I> override all the
methods because all of them &#8211; with the exception of the constructor
&#8211; are abstract.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Vector</B>s <B>keys</B> and
<B>values</B> are linked by a common index number. That is, if you call
<B>put(&#160;)</B> with a key of &#8220;roof&#8221; and a value of
&#8220;blue&#8221; (assuming you&#8217;re associating the various parts of a
house with the colors they are to be painted) and there are already 100 elements
in the <B>AssocArray</B>, then &#8220;roof&#8221; will be the 101 element of
<B>keys</B> and &#8220;blue&#8221; will be the 101 element of <B>values</B>. And
if you look at <B>get(&#160;)</B>, when you pass &#8220;roof&#8221; in as the
key, it produces the index number with <B>keys</B>.<B>indexOf(&#160;)</B>, and
then uses that index number to produce the value in the associated <B>values</B>
vector.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The test in <B>main(&#160;)</B> is
simple; it&#8217;s just a map of lowercase characters to uppercase characters,
which could obviously be done in a number of more efficient ways. But it shows
that <B>AssocArray</B> is functional.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The standard Java library contains
only one embodiment of a <B>Dictionary</B>, called
<B>Hashtable</B>.</FONT><A NAME="fnB34" HREF="#fn34">[34]</A><FONT FACE="Georgia">
Java&#8217;s <B>Hashtable</B> has the same basic interface as <B>AssocArray
</B>(since they both inherit <B>Dictionary</B>), but it<B> </B>differs in one
distinct way: efficiency. If you look at what must be done for a
<B>get(&#160;)</B>, it seems pretty slow to search through a <B>Vector</B> for
the key. This is where <B>Hashtable</B> speeds things up. Instead of the tedious
linear search for the key, it uses a special value called a <I>hash code</I>.<I>
</I>The hash code is a way to take some information in the object in question
and turn it into a &#8220;relatively unique&#8221; <B>int</B> for that object.
All objects have a hash code, and <A NAME="Index797"></A><B>hashCode(&#160;)</B>
is a method in the root class <A NAME="Index798"></A><B>Object</B>. A
<B>Hashtable </B>takes the <B>hashCode(&#160;)</B> of the object and uses it to
quickly hunt for the key. This results in a dramatic performance
improvement.</FONT><A NAME="fnB35" HREF="#fn35">[35]</A><FONT FACE="Georgia">
The <I>way</I> that a <B>Hashtable</B> works is beyond the scope of this
book</FONT><A NAME="fnB36" HREF="#fn36">[36]</A><FONT FACE="Georgia">
&#8211; all you need to know is that <B>Hashtable</B> is a fast
<B>Dictionary</B>, and that a <B>Dictionary</B> is a useful
tool.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example of the use of a
<B>Hashtable</B>, consider a program to check the randomness of Java&#8217;s
<A NAME="Index799"></A><A NAME="Index800"></A><B>Math.random(&#160;)</B> method.
Ideally, it would produce a perfect distribution of random numbers, but to test
this you need to generate a bunch of random numbers and count the ones that fall
in the various ranges. A <B>Hashtable</B> is perfect for this, since it
associates objects with objects (in this case, the values produced by
<B>Math.random(&#160;)</B> with the number of times those values
appear):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Statistics.java</font>
<font color=#009900>// Simple demonstration of Hashtable</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Counter { 
  <font color=#0000ff>int</font> i = 1; 
  <font color=#0000ff>public</font> String toString() { 
    <font color=#0000ff>return</font> Integer.toString(i); 
  }
}

<font color=#0000ff>class</font> Statistics {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Hashtable ht = <font color=#0000ff>new</font> Hashtable();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10000; i++) {
      <font color=#009900>// Produce a number between 0 and 20:</font>
      Integer r = 
        <font color=#0000ff>new</font> Integer((<font color=#0000ff>int</font>)(Math.random() * 20));
      <font color=#0000ff>if</font>(ht.containsKey(r))
        ((Counter)ht.get(r)).i++;
      <font color=#0000ff>else</font>
        ht.put(r, <font color=#0000ff>new</font> Counter());
    }
    System.out.println(ht);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, each time a
random number is generated it is wrapped inside an <B>Integer</B> object so that
handle can be used with the <B>Hashtable</B>. (You can&#8217;t use a primitive
with a collection, only an object handle.) The <B>containsKey(&#160;)</B> method
checks to see if this key is already in the collection. (That is, has the number
been found already?) If so, the <A NAME="Index801"></A><B>get(&#160;)</B>
methods gets the associated value for the key, which in this case is a
<B>Counter</B> object. The value <B>i</B> inside the counter is then incremented
to indicate that one more of this particular random number has been
found.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the key has not been found yet,
the method <A NAME="Index802"></A><B>put(&#160;)</B> will place a new key-value
pair into the <B>Hashtable</B>. Since <B>Counter</B> automatically initializes
its variable <B>i</B> to one when it&#8217;s created, it indicates the first
occurrence of this particular random number.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To display the <B>Hashtable</B>, it
is simply printed out. The <B>Hashtable</B> <B>toString(&#160;)</B> method moves
through all the key-value pairs and calls the <B>toString(&#160;)</B> for each
one. The <B>Integer toString(&#160;)</B> is pre-defined, and you can see the
<B>toString(&#160;)</B> for <B>Counter</B>. The output from one run (with some
line breaks added) is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>{19=526, 18=533, 17=460, 16=513, 15=521, 14=495,
 13=512, 12=483, 11=488, 10=487, 9=514, 8=523,
 7=497, 6=487, 5=480, 4=489, 3=509, 2=503, 1=475,
 0=505}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might wonder at the necessity
of the class <B>Counter,</B> which seems like it doesn&#8217;t even have the
functionality of the wrapper class <B>Integer</B>. Why not use <B>int</B> or
<B>Integer</B>? Well, you can&#8217;t use an <B>int</B> because all of the
collections can hold only<B> Object</B> handles. After seeing collections the
wrapper classes might begin to make a little more sense to you, since you
can&#8217;t put any of the primitive types in collections. However, the only
thing you <I>can</I> do with the Java <A NAME="Index803"></A>wrappers is to
initialize them to a particular value and read that value. That is,
there&#8217;s no way to change a value once a wrapper object has been created.
This makes the <B>Integer</B> wrapper immediately useless to solve our problem,
so we&#8217;re forced to create a new class that does satisfy the
need.</FONT><BR></P></DIV>
<A NAME="Heading256"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Creating &#8220;key&#8221; classes</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the previous example, a standard
library class (<B>Integer</B>) was used as a key for the <B>Hashtable</B>. It
worked fine as a key, because it has all the necessary wiring to make it work
correctly as a key. But a common pitfall occurs when using <B>Hashtable</B>s
when you create your own classes to be used as keys. For example, consider a
weather predicting system that matches <B>Groundhog</B> objects to
<B>Prediction</B> objects. It seems fairly straightforward: you create the two
classes and use <B>Groundhog</B> as the key and <B>Prediction</B> as the
value:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SpringDetector.java</font>
<font color=#009900>// Looks plausible, but doesn't work right.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Groundhog {
  <font color=#0000ff>int</font> ghNumber;
  Groundhog(<font color=#0000ff>int</font> n) { ghNumber = n; }
}

<font color=#0000ff>class</font> Prediction {
  <font color=#0000ff>boolean</font> shadow = Math.random() &gt; 0.5;
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>if</font>(shadow)
      <font color=#0000ff>return</font> <font color=#004488>"Six more weeks of Winter!"</font>;
    <font color=#0000ff>else</font>
      <font color=#0000ff>return</font> <font color=#004488>"Early Spring!"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SpringDetector {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Hashtable ht = <font color=#0000ff>new</font> Hashtable();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      ht.put(<font color=#0000ff>new</font> Groundhog(i), <font color=#0000ff>new</font> Prediction());
    System.out.println(<font color=#004488>"ht = "</font> + ht + <font color=#004488>"\n"</font>);
    System.out.println(
      <font color=#004488>"Looking up prediction for groundhog #3:"</font>);
    Groundhog gh = <font color=#0000ff>new</font> Groundhog(3);
    <font color=#0000ff>if</font>(ht.containsKey(gh))
      System.out.println((Prediction)ht.get(gh));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each <B>Groundhog</B> is given an
identity number, so you can look up a <B>Prediction</B> in the <B>Hashtable</B>
by saying &#8220;Give me the <B>Prediction </B>associated with <B>Groundhog</B>
number 3.&#8221; The <B>Prediction</B> class contains a <B>boolean</B> that is
initialized using <B>Math.random(&#160;)</B>, and a <B>toString(&#160;)</B> that
interprets the result for you. In <B>main(&#160;)</B>, a <B>Hashtable</B> is
filled with <B>Groundhog</B>s and their associated <B>Prediction</B>s. The
<B>Hashtable </B>is printed so you can see that it has been filled. Then a
<B>Groundhog</B> with an identity number of 3 is used to look up the prediction
for <B>Groundhog</B> #3.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It seems simple enough, but it
doesn&#8217;t work. The problem is that <B>Groundhog</B> is inherited from the
common root class <B>Object</B> (which is what happens if you don&#8217;t
specify a base class, thus all classes are ultimately inherited from
<B>Object</B>). It is <B>Object</B>&#8217;s <B>hashCode(&#160;)</B> method that
is used to generate the hash code for each object, and by default it just uses
the address of its object. Thus, the first instance of <B>Groundhog(3)</B> does
<I>not</I> produce a hash code equal to the hash code for the second instance of
<B>Groundhog(3)</B> that we tried to use as a lookup.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might think that all you need
to do is write an appropriate override for
<A NAME="Index804"></A><B>hashCode(&#160;)</B>. But it still won&#8217;t work
until you&#8217;ve done one more thing: override the
<A NAME="Index805"></A><B>equals(&#160;)</B> that is also part of <B>Object</B>.
This method is used by the <B>Hashtable</B> when trying to determine if your key
is equal to any of the keys in the table. Again, the default
<B>Object.equals(&#160;)</B> simply compares object addresses, so one
<B>Groundhog(3)</B> is not equal to another
<B>Groundhog(3)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, to use your own classes as
keys in a <B>Hashtable</B>, you must override both <B>hashCode(&#160;)</B> and
<B>equals(&#160;)</B>, as shown in the following solution to the problem
above:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SpringDetector2.java</font>
<font color=#009900>// If you create a class that's used as a key in</font>
<font color=#009900>// a Hashtable, you must override hashCode()</font>
<font color=#009900>// and equals().</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Groundhog2 {
  <font color=#0000ff>int</font> ghNumber;
  Groundhog2(<font color=#0000ff>int</font> n) { ghNumber = n; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { <font color=#0000ff>return</font> ghNumber; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> (o <font color=#0000ff>instanceof</font> Groundhog2)
      &amp;&amp; (ghNumber == ((Groundhog2)o).ghNumber);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SpringDetector2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Hashtable ht = <font color=#0000ff>new</font> Hashtable();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      ht.put(<font color=#0000ff>new</font> Groundhog2(i),<font color=#0000ff>new</font> Prediction());
    System.out.println(<font color=#004488>"ht = "</font> + ht + <font color=#004488>"\n"</font>);
    System.out.println(
      <font color=#004488>"Looking up prediction for groundhog #3:"</font>);
    Groundhog2 gh = <font color=#0000ff>new</font> Groundhog2(3);
    <font color=#0000ff>if</font>(ht.containsKey(gh))
      System.out.println((Prediction)ht.get(gh));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that this uses the
<B>Prediction</B> class from the previous example, so <B>SpringDetector.java</B>
must be compiled first or you&#8217;ll get a compile-time error when you try to
compile<B> SpringDetector2.java</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Groundhog2.hashCode(&#160;)</B>
returns the ground hog number as an identifier. (In this example, the programmer
is responsible for ensuring that no two ground hogs exist with the same ID
number.) The <B>hashCode(&#160;) </B>is not required to return a unique
identifier, but the <B>equals(&#160;)</B> method must be able to strictly
determine whether two objects are equivalent.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Even though it appears that the
<B>equals(&#160;)</B> method is only checking to see whether the argument is an
instance of <B>Groundhog2</B> (using the <B>instanceof</B> keyword, which is
fully explained in Chapter 11), the <B>instanceof</B> actually quietly does a
second sanity check, to see if the object is <B>null</B>, since
<B>instanceof</B> produces <B>false</B> if the left-hand argument is
<B>null</B>. Assuming it&#8217;s the correct type and not <B>null</B>, the
comparison is based on the actual <B>ghNumber</B>s. This time, when you run the
program, you&#8217;ll see it produces the correct output. (Many of the Java
library classes override the <B>hashCode(&#160;)</B> and <B>equals(&#160;)</B>
methods to be based upon their contents.)</FONT><BR></P></DIV>
<A NAME="Heading257"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Properties: a type of Hashtable</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the first example in this book,
a type of <B>Hashtable</B> was used called <B>Properties</B>. In that example,
the lines:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Properties p = System.getProperties();
p.list(System.out);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">called the <B>static</B> method
<A NAME="Index806"></A><B>getProperties(&#160;)</B> to get a special
<B>Properties</B> object that described the system characteristics. The method
<B>list(&#160;)</B> is a method of <B>Properties </B>that sends the contents to
any stream output that you choose. There&#8217;s also a <B>save(&#160;)</B>
method to allow you to write your property list to a file in a way that it can
be retrieved later with the <B>load(&#160;)</B> method.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although the
<A NAME="Index807"></A><B>Properties</B> class is inherited from
<B>Hashtable</B>, it also <I>contains</I> a second <B>Hashtable</B> that acts to
hold the list of &#8220;default&#8221; properties. So if a property isn&#8217;t
found in the primary list, the defaults will be searched.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Properties</B> class is also
available for use in your programs (an example is <B>ClassScanner.java</B> in
Chapter 17). You can find more complete details in the Java library
documentation.</FONT><A NAME="_Toc375545358"></A><A NAME="_Toc408018574"></A><BR></P></DIV>
<A NAME="Heading258"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Enumerators revisited</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">We can now demonstrate the true
power of the <A NAME="Index808"></A><B>Enumeration</B>: the ability to separate
the operation of traversing a sequence from the underlying structure of that
sequence. In the following example, the class <B>PrintData</B> uses an
<B>Enumeration</B> to move through a sequence and call the
<A NAME="Index809"></A><B>toString(&#160;)</B> method for every object. Two
different types of collections are created, a
<A NAME="Index810"></A><B>Vector</B> and a
<A NAME="Index811"></A><B>Hashtable</B>, and they are each filled with,
respectively, <B>Mouse </B>and <B>Hamster </B>objects. (These classes are
defined earlier in the chapter; notice you must have compiled
<B>HamsterMaze.java</B> and <B>WorksAnyway.java</B> for the following program to
compile.) Because an <B>Enumeration </B>hides the structure of the underlying
collection, <B>PrintData</B> doesn&#8217;t know or care what kind of collection
the <B>Enumeration </B>comes from:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Enumerators2.java</font>
<font color=#009900>// Revisiting Enumerations</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> PrintData {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(Enumeration e) {
    <font color=#0000ff>while</font>(e.hasMoreElements())
      System.out.println(
        e.nextElement().toString());
  }
}

<font color=#0000ff>class</font> Enumerators2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector v = <font color=#0000ff>new</font> Vector();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      v.addElement(<font color=#0000ff>new</font> Mouse(i));

    Hashtable h = <font color=#0000ff>new</font> Hashtable();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      h.put(<font color=#0000ff>new</font> Integer(i), <font color=#0000ff>new</font> Hamster(i));

    System.out.println(<font color=#004488>"Vector"</font>);
    PrintData.print(v.elements());
    System.out.println(<font color=#004488>"Hashtable"</font>);
    PrintData.print(h.elements());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that
<B>PrintData.print(&#160;)</B> takes advantage of the fact that the objects in
these collections are of class <B>Object</B> so it can call
<B>toString(&#160;)</B>. It&#8217;s more likely that in your problem, you must
make the assumption that your <B>Enumeration</B> is walking through a collection
of some specific type. For example, you might assume that everything in the
collection is a <B>Shape</B> with a <B>draw(&#160;)</B> method. Then you must
downcast from the <B>Object </B>that <B>Enumeration.nextElement</B>() returns to
produce a
<B>Shape</B>.</FONT><A NAME="_Toc375545359"></A><A NAME="_Toc375545403"></A><A NAME="_Toc408018575"></A><BR></P></DIV>
<A NAME="Heading259"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Sorting</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the things missing in the
Java 1.0<A NAME="Index812"></A> and 1.1 libraries is algorithmic operations,
even simple <A NAME="Index813"></A>sorting. So it makes sense to create a
<B>Vector</B> that sorts itself using the classic
<A NAME="Index814"></A>Quicksort.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A problem with writing generic
sorting code is that sorting must perform comparisons based on the actual type
of the object. Of course, one approach is to write a different sorting method
for every different type, but you should be able to recognize that this does not
produce code that is easily re-used for new types.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A primary goal of programming
design is to &#8220;separate things that change from things that stay the
same,&#8221; and here, the code that stays the same is the general sort
algorithm, but the thing that changes from one use to the next is the way
objects are compared. So instead of hard-wiring the comparison code into many
different sort routines, the technique of the
<A NAME="Index815"></A><I>callback</I> will be used. With a callback, the part
of the code that varies from case to case is encapsulated inside its own class,
and the part of the code that&#8217;s always the same will call back to the code
that changes. That way you can make different objects to express different ways
of comparison and feed them to the same sorting code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following <B>interface</B>
describes how to compare two objects, and thus encapsulates &#8220;the things
that change&#8221; for this particular problem:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Compare.java</font>
<font color=#009900>// Interface for sorting callback:</font>
<font color=#0000ff>package</font> c08;

<font color=#0000ff>interface</font> Compare {
  <font color=#0000ff>boolean</font> lessThan(Object lhs, Object rhs);
  <font color=#0000ff>boolean</font> lessThanOrEqual(Object lhs, Object rhs);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For both methods, the <B>lhs</B>
represents the &#8220;left hand&#8221; object and the <B>rhs</B> represents the
&#8220;right hand&#8221; object in the comparison.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A subclass of <B>Vector</B> can be
created that implements the Quicksort using <B>Compare</B>. The algorithm, which
is known for its speed, will not be explained here. For details, see
<I>Practical Algorithms for Programmers</I>, by Binstock &amp; Rex,
Addison-Wesley 1995.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SortVector.java</font>
<font color=#009900>// A generic sorting vector</font>
<font color=#0000ff>package</font> c08;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SortVector <font color=#0000ff>extends</font> Vector {
  <font color=#0000ff>private</font> Compare compare; <font color=#009900>// To hold the callback</font>
  <font color=#0000ff>public</font> SortVector(Compare comp) {
    compare = comp;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> sort() {
    quickSort(0, size() - 1);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> quickSort(<font color=#0000ff>int</font> left, <font color=#0000ff>int</font> right) {
    <font color=#0000ff>if</font>(right &gt; left) {
      Object o1 = elementAt(right);
      <font color=#0000ff>int</font> i = left - 1;
      <font color=#0000ff>int</font> j = right;
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
        <font color=#0000ff>while</font>(compare.lessThan(
              elementAt(++i), o1))
          ;
        <font color=#0000ff>while</font>(j &gt; 0)
          <font color=#0000ff>if</font>(compare.lessThanOrEqual(
             elementAt(--j), o1))
            <font color=#0000ff>break</font>; <font color=#009900>// out of while</font>
        <font color=#0000ff>if</font>(i &gt;= j) <font color=#0000ff>break</font>;
        swap(i, j);
      }
      swap(i , right);
      quickSort(left, i-1);
      quickSort(i+1, right);
    }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> swap(<font color=#0000ff>int</font> loc1, <font color=#0000ff>int</font> loc2) {
    Object tmp = elementAt(loc1);
    setElementAt(elementAt(loc2), loc1);
    setElementAt(tmp, loc2);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can now see the reason for the
term &#8220;callback,&#8221; since the <B>quickSort(&#160;)</B> method
&#8220;calls back&#8221; to the methods in <B>Compare</B>. You can also see how
this technique has produced generic, reusable code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To use the <B>SortVector</B>, you
must create a class that implements <B>Compare</B> for the kind of objects that
you&#8217;re sorting. This is a place where an inner class is not essential, but
it can make sense for code organization. Here&#8217;s an example for
<B>String</B> objects:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: StringSortTest.java</font>
<font color=#009900>// Testing the generic sorting Vector</font>
<font color=#0000ff>package</font> c08;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StringSortTest {
  <font color=#0000ff>static</font> <font color=#0000ff>class</font> StringCompare <font color=#0000ff>implements</font> Compare {
    <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> lessThan(Object l, Object r) {
      <font color=#0000ff>return</font> ((String)l).toLowerCase().compareTo(
        ((String)r).toLowerCase()) &lt; 0;
    }
    <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
    lessThanOrEqual(Object l, Object r) {
      <font color=#0000ff>return</font> ((String)l).toLowerCase().compareTo(
        ((String)r).toLowerCase()) &lt;= 0;
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SortVector sv = 
      <font color=#0000ff>new</font> SortVector(<font color=#0000ff>new</font> StringCompare());
    sv.addElement(<font color=#004488>"d"</font>);
    sv.addElement(<font color=#004488>"A"</font>);
    sv.addElement(<font color=#004488>"C"</font>);
    sv.addElement(<font color=#004488>"c"</font>);
    sv.addElement(<font color=#004488>"b"</font>);
    sv.addElement(<font color=#004488>"B"</font>);
    sv.addElement(<font color=#004488>"D"</font>);
    sv.addElement(<font color=#004488>"a"</font>);
    sv.sort();
    Enumeration e = sv.elements();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      System.out.println(e.nextElement());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The inner class is <B>static</B>
because it does not need a link to an outer class in order for it to
function.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see how, once the framework
is set up, it&#8217;s easy to reuse a design like this &#8211; you simply write
the class that encapsulates &#8220;the things that change&#8221; and hand an
object to the <B>SortVector</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The comparison forces the strings
to lower case, so that the capital <B>A</B>&#8217;s end up next to the small
<B>a</B>&#8217;s and not in some entirely different place. This example shows,
however, a slight deficiency in this approach, since the test code above puts
the uppercase and lowercase single letters of the same letter in the order that
they appear: A a b B c C d D. This is not usually much of a problem, because
you&#8217;re usually working with longer strings and in that situation the
effect doesn&#8217;t show up. (The Java 1.2<A NAME="Index816"></A> collections
provide sorting functionality that solves this problem.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Inheritance (<B>extends</B>) is
used here to create a new type of <B>Vector</B> &#8211; that is,
<B>SortVector</B> <I>is a </I><B>Vector</B> with some added functionality. The
use of inheritance here is powerful but it presents problems. It turns out that
some methods are <B>final </B>(described in Chapter 7), so you cannot override
them. If you want to create a sorted <B>Vector</B> that accepts and produces
only <B>String </B>objects you run into a wall, since <B>addElement(&#160;)</B>
and <B>elementAt(&#160;) </B>are <B>final</B>, and these are precisely the
methods you&#8217;d need to override so they accept and produce only
<B>String</B> objects. No luck there.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">On the other hand, consider
<A NAME="Index817"></A>composition: the placing of an object <I>inside</I> a new
class. Rather than rewrite the above code to accomplish this, we can simply use
a <B>SortVector</B> inside the new class. In this case, the inner class to
implement the interface <B>Compare </B>will be created
anonymously:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: StrSortVector.java</font>
<font color=#009900>// Automatically sorted Vector that </font>
<font color=#009900>// accepts and produces only Strings</font>
<font color=#0000ff>package</font> c08;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StrSortVector {
  <font color=#0000ff>private</font> SortVector v = <font color=#0000ff>new</font> SortVector(
    <font color=#009900>// Anonymous inner class:</font>
    <font color=#0000ff>new</font> Compare() {
      <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
      lessThan(Object l, Object r) {
        <font color=#0000ff>return</font> 
          ((String)l).toLowerCase().compareTo(
          ((String)r).toLowerCase()) &lt; 0;
      }
      <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
      lessThanOrEqual(Object l, Object r) {
        <font color=#0000ff>return</font> 
          ((String)l).toLowerCase().compareTo(
          ((String)r).toLowerCase()) &lt;= 0;
      }
    }
  );
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> sorted = <font color=#0000ff>false</font>;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> addElement(String s) {
    v.addElement(s);
    sorted = <font color=#0000ff>false</font>;
  }
  <font color=#0000ff>public</font> String elementAt(<font color=#0000ff>int</font> index) {
    <font color=#0000ff>if</font>(!sorted) {
      v.sort();
      sorted = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>return</font> (String)v.elementAt(index);
  }
  <font color=#0000ff>public</font> Enumeration elements() {
    <font color=#0000ff>if</font>(!sorted) {
      v.sort();
      sorted = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>return</font> v.elements();
  }
  <font color=#009900>// Test it:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    StrSortVector sv = <font color=#0000ff>new</font> StrSortVector();
    sv.addElement(<font color=#004488>"d"</font>);
    sv.addElement(<font color=#004488>"A"</font>);
    sv.addElement(<font color=#004488>"C"</font>);
    sv.addElement(<font color=#004488>"c"</font>);
    sv.addElement(<font color=#004488>"b"</font>);
    sv.addElement(<font color=#004488>"B"</font>);
    sv.addElement(<font color=#004488>"D"</font>);
    sv.addElement(<font color=#004488>"a"</font>);
    Enumeration e = sv.elements();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      System.out.println(e.nextElement());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This quickly reuses the code from
<B>SortVector</B> to create the desired functionality. However, not all of the
<B>public</B> methods from <B>SortVector</B> and <B>Vector</B> appear in
<B>StrSortVector</B>. When reusing code this way, you can make a definition in
the new class for each one in the contained class, or you can start with just a
few and periodically go back and add more when you need them. Eventually the new
class design will settle down.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The advantage to this approach is
that it will take only<B> String</B> objects and produce only <B>String</B>
objects, and the checking happens at compile time instead of run time. Of
course, that&#8217;s only true for <B>addElement(&#160;)</B> and
<B>elementAt(&#160;)</B>; <B>elements(&#160;)</B> still produces an
<B>Enumeration</B> that is untyped at compile time. Type checking for the
<A NAME="Index818"></A><B>Enumeration</B> and in <B>StrSortVector</B> still
happens, of course, it just happens at run-time by throwing exceptions if you do
something wrong. It&#8217;s a trade-off: do you find out about something <I>for
sure</I> at compile time or <I>probably</I> at run-time? (That is,
&#8220;probably not while you&#8217;re testing the code&#8221; and
&#8220;probably when the program user tries something you didn&#8217;t test
for.&#8221;) Given the choices and the hassle, it&#8217;s easier to use
inheritance and just grit your teeth while casting &#8211; again, if
<A NAME="Index819"></A>parameterized types are ever added to Java, they will
solve this problem.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see there&#8217;s a flag
called <B>sorted</B> in this class. You could sort the vector every time
<B>addElement(&#160;)</B> is called, and constantly keep it in a sorted state.
But usually people add a lot of elements to a <B>Vector </B>before beginning to
read it. So sorting after every <B>addElement(&#160;)</B> would be less
efficient than waiting until someone wants to read the vector and then sorting
it, which is what is done here. The technique of delaying a process until it is
absolutely necessary is called <A NAME="Index820"></A><I>lazy evaluation</I>.
(There is an analogous technique called <I>lazy initialization</I> which waits
until a field value is necessary before initializing
it.)</FONT><A NAME="_Toc408018576"></A><BR></P></DIV>
<A NAME="Heading260"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The generic collection library</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ve seen in this chapter
that the standard Java library has some fairly useful collections, but far from
a complete set. In addition, algorithms like sorting are not supported at all.
One of the strengths of C++ is its libraries, in particular the
<A NAME="Index821"></A><A NAME="Index822"></A><A NAME="Index823"></A><I>Standard
Template Library</I> (STL) that provides a fairly full set of collections as
well as many algorithms like sorting and searching that work with those
collections. Based on this model, the <A NAME="Index824"></A>ObjectSpace company
was inspired to create the <A NAME="Index825"></A><I>Generic Collection
Library</I> <I>for Java </I>(formerly called the
<A NAME="Index826"></A><A NAME="Index827"></A><I>Java Generic Library</I>, but
the abbreviation JGL is still used &#8211; the old name infringed on Sun&#8217;s
copyright), which follows the design of the STL as much as possible (given the
differences between the two languages). The JGL seems to fulfill many, if not
all, of the needs for a collection library, or as far as one could go in this
direction without C++&#8217;s template mechanism. The JGL includes linked lists,
sets, queues, maps, stacks, sequences, and iterators that are far more
functional than <B>Enumeration</B>, as well as a full set of<B> </B>algorithms
such as searching and sorting. ObjectSpace also made, in some cases, more
intelligent design decisions than the Sun library designers. For example, the
methods in the JGL collections are <I>not</I> final so it&#8217;s easy to
inherit and override those methods.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The JGL has been included in some
vendors&#8217; Java distributions and ObjectSpace has made the JGL freely
available for all uses, including commercial use, at
<I>http://www.ObjectSpace.com</I>. The online documentation that comes in the
JGL package is quite good and should be adequate to get you
started.</FONT><A NAME="_Toc408018577"></A><BR></P></DIV>
<A NAME="Heading261"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The new collections</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To me, collection classes are one
of the most powerful tools for raw programming. You might have gathered that
I&#8217;m somewhat disappointed in the collections provided in Java through
version 1.1. As a result, it&#8217;s a tremendous pleasure to see that
collections were given proper attention in
<A NAME="Index828"></A><A NAME="Index829"></A><A NAME="Index830"></A><A NAME="Index831"></A>Java
1.2, and thoroughly redesigned (by Joshua Bloch at Sun). I consider the new
collections to be one of the two major features in Java 1.2 (the other is the
Swing library, covered in Chapter 13) because they significantly increase your
programming muscle and help bring Java in line with more mature programming
systems.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some of the redesign makes things
tighter and more sensible. For example, many names are shorter, cleaner, and
easier to understand, as well as to type. Some names are changed to conform to
accepted terminology: a particular favorite of mine is &#8220;iterator&#8221;
instead of &#8220;enumeration.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The redesign also fills out the
functionality of the collections library. You can now have the behavior of
<A NAME="Index832"></A>linked lists, <A NAME="Index833"></A>queues, and
<A NAME="Index834"></A>dequeues (double-ended queues, pronounced
&#8220;decks&#8221;).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The design of a collections library
is difficult (true of most library design problems). In
<A NAME="Index835"></A><A NAME="Index836"></A>C++, the STL covered the bases
with many different classes. This was better than what was available prior to
the STL (nothing), but it didn&#8217;t translate well into Java. The result was
a rather confusing morass of classes. On the other extreme, I&#8217;ve seen a
collections library that consists of a single class, &#8220;collection,&#8221;
which acts like a <B>Vector </B>and a <B>Hashtable </B>at the same time. The
designers of the new collections library wanted to strike a balance: the full
functionality that you expect from a mature collections library, but easier to
learn and use than the STL and other similar collections libraries. The result
can seem a bit odd in places. Unlike some of the decisions made in the early
Java libraries, these oddities were not accidents, but carefully considered
decisions based on tradeoffs in complexity. It might take you a little while to
get comfortable with some aspects of the library, but I think you&#8217;ll find
yourself rapidly acquiring and using these new tools.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The new collections library takes
the issue of &#8220;holding your objects&#8221; and divides it into two distinct
concepts:
<A NAME="Index837"></A><A NAME="Index838"></A><A NAME="Index839"></A><A NAME="Index840"></A><A NAME="Index841"></A><A NAME="Index842"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia"><B>	Collection</B>: a group of individual
elements, often with some rule applied to them. A <B>List</B> must hold the
elements in a particular sequence, and a <B>Set</B> cannot have any duplicate
elements. (A <I>bag</I>, which is not implemented in the new collections library
since <B>List</B>s provide you with that functionality, has no such
rules.)</FONT><LI><FONT FACE="Georgia"><B>	Map</B>: a group of key-value
object pairs (what you&#8217;ve seen up until now as a <B>Hashtable</B>). At
first glance, this might seem like it ought to be a <B>Collection</B> of pairs,
but when you try to implement it that way the design gets awkward, so it&#8217;s
clearer to make it a separate concept. On the other hand, it&#8217;s convenient
to look at portions of a <B>Map</B> by creating a <B>Collection</B> to represent
that portion. Thus, a <B>Map</B> can return a <B>Set</B> of its keys, a <B>List
</B>of its values, or a <B>List </B>of its pairs. <B>Map</B>s, like arrays, can
easily be expanded to multiple dimensions without adding new concepts: you
simply make a <B>Map</B> whose values are <B>Map</B>s (and the values of
<I>those</I> <B>Map</B>s can be <B>Map</B>s,
etc.).</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Collection</B>s
and <B>Map</B>s may be implemented in many different ways, according to your
programming needs. It&#8217;s helpful to look at a diagram of the new
collections:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="Tjava117.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This diagram can be a bit
overwhelming at first, but throughout the rest of this section you&#8217;ll see
that there are really only three collection components: <B>Map</B>, <B>List</B>,
and <B>Set</B>, and only two or three implementations of each one (with,
typically, a preferred version). When you see this, the new collections should
not seem so daunting.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The dashed boxes represent
<B>interface</B>s, the dotted boxes represent <B>abstract</B> classes, and the
solid boxes are regular (concrete) classes. The dashed arrows indicate that a
particular class is implementing an <B>interface</B> (or in the case of an
<B>abstract</B> class, partially implementing that <B>interface</B>). The
double-line arrows show that a class can produce objects of the class the arrow
is pointing to. For example, any <B>Collection</B> can produce an
<B>Iterator</B>, while a <B>List</B> can produce a <B>ListIterator</B> (as well
as an ordinary <B>Iterator</B>, since <B>List</B> is inherited from
<B>Collection</B>).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The interfaces that are concerned
with holding objects are <B>Collection</B>, <B>List</B>, <B>Set</B>, and
<B>Map</B>.<B> </B>Typically, you&#8217;ll write the bulk of your code to talk
to these interfaces, and the only place where you&#8217;ll specify the precise
type you&#8217;re using is at the point of creation. So you can create a
<B>List</B> like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>List x = <font color=#0000ff>new</font> LinkedList();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, you can also decide to
make <B>x </B>a <B>LinkedList </B>(instead of a generic <B>List</B>)<B> </B>and
carry the precise type information around with <B>x</B>. The beauty (and the
intent) of using the <B>interface</B> is that if you decide you want to change
your implementation, all you need to do is change it at the point of creation,
like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>List x = <font color=#0000ff>new</font> ArrayList();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of your code can remain
untouched.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the class hierarchy, you can see
a number of classes whose names begin with &#8220;<B>Abstract</B>,&#8221; and
these can seem a bit confusing at first. They are simply tools that partially
implement a particular interface. If you were making your own <B>Set</B>, for
example, you wouldn&#8217;t start with the <B>Set</B> interface and implement
all the methods, instead you&#8217;d inherit from
<A NAME="Index843"></A><B>AbstractSet</B> and do the minimal necessary work to
make your new class. However, the new collections library contains enough
functionality to satisfy your needs virtually all the time. So for our purposes,
you can ignore any class that begins with
&#8220;<B>Abstract</B>.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Therefore, when you look at the
diagram, you&#8217;re really concerned with only those <B>interface</B>s at the
top of the diagram and the concrete classes (those with solid boxes around
them). You&#8217;ll typically make an object of a concrete class, upcast it to
the corresponding <B>interface</B>, and then use the <B>interface</B> throughout
the rest of your code. Here&#8217;s a simple example, which fills a
<B>Collection</B> with <B>String</B> objects and then prints each element in the
<B>Collection</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SimpleCollection.java</font>
<font color=#009900>// A simple example using the new Collections</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleCollection {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      c.add(Integer.toString(i));
    Iterator it = c.iterator();
    <font color=#0000ff>while</font>(it.hasNext())
      System.out.println(it.next());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the code examples for the new
collections libraries will be placed in the subdirectory <B>newcollections</B>,
so you&#8217;ll be reminded that these work only with Java 1.2. As a result, you
must invoke the program by saying:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java c08.newcollections.SimpleCollection</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">with a similar syntax for the rest
of the programs in the package.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the new
collections are part of the <B>java.util</B> library, so you don&#8217;t need to
add any extra <B>import</B> statements to use them.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first line in
<B>main(&#160;)</B> creates an <A NAME="Index844"></A><B>ArrayList</B> object
and then upcasts it to a <B>Collection</B>. Since this example uses only the
<B>Collection </B>methods, any object of a class inherited from
<B>Collection</B> would work, but <B>ArrayList</B> is the typical workhorse
<B>Collection</B> and takes the place of <B>Vector</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>add(&#160;)</B> method, as
its name suggests, puts a new element in the <B>Collection</B>. However, the
documentation carefully states that <B>add(&#160;)</B> &#8220;ensures that this
Collection contains the specified element.&#8221; This is to allow for the
meaning of <B>Set</B>, which adds the element only if it isn&#8217;t already
there. With an <B>ArrayList</B>, or any sort of <B>List</B>, <B>add(&#160;)</B>
always means &#8220;put it in.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All <B>Collection</B>s can produce
an <A NAME="Index845"></A><B>Iterator</B> via their
<A NAME="Index846"></A><B>iterator(&#160;)</B> method. An <B>Iterator</B> is
just like an <A NAME="Index847"></A><B>Enumeration</B>, which it replaces,
except:
<A NAME="Index848"></A><A NAME="Index849"></A><A NAME="Index850"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	It uses a name (iterator) that is historically
understood and accepted in the OOP
community.</FONT><LI><FONT FACE="Georgia">	It uses shorter method names
than <B>Enumeration</B>: <B>hasNext(&#160;)</B> instead of
<B>hasMoreElements(&#160;)</B>, and <B>next(&#160;)</B> instead of
<B>nextElement(&#160;)</B>.</FONT><LI><FONT FACE="Georgia">	It adds a new
method, <B>remove(&#160;)</B>, which removes the last element produced by the
<B>Iterator</B>. So you can call <B>remove(&#160;)</B> only once for every time
you call
<B>next(&#160;)</B>.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In
<B>SimpleCollection.java</B>, you can see that an <B>Iterator</B> is created and
used to traverse the <B>Collection</B>, printing each
element.</FONT><A NAME="_Toc408018578"></A><BR></P></DIV>
<A NAME="Heading262"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using Collections</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following table shows
everything you can do with a <B>Collection</B>, and thus, everything you can do
with a <B>Set</B> or a <B>List.</B> (<B>List</B> also has additional
functionality.) <B>Map</B>s are not inherited from <B>Collection</B>, and will
be treated separately.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Boolean
add(Object)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">*Ensures that the Collection
contains the argument. Returns false if it doesn&#8217;t add the
argument.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Boolean
addAll(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">*Adds all the elements in the
argument. Returns true if any elements were added.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void
clear(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">*Removes all the elements in the
Collection. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Boolean
contains(Object)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">True if the Collection contains the
argument. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Boolean
containsAll(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">True if the Collection contains all
the elements in the argument. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Boolean
isEmpty(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">True if the Collection has no
elements. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Iterator
iterator(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an Iterator that you can
use to move through the elements in the Collection. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Boolean
remove(Object)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">*If the argument is in the
Collection, one instance of that element is removed. Returns true if a removal
occurred.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Boolean
removeAll(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">*Removes all the elements that are
contained in the argument. Returns true if any removals
occurred.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Boolean
retainAll(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">*Retains only elements that are
contained in the argument (an &#8220;intersection&#8221; from set theory).
Returns true if any changes occurred.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>int
size(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns the number of elements in
the Collection. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Object[]
toArray(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an array containing all the
elements in the Collection.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Object[] toArray(Object[]
a)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an array containing all the
elements in the Collection, whose type is that of the array <B>a</B> rather than
plain <B>Object</B> (you must cast the array to the right
type).</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">*This is an &#8220;optional&#8221;
method, which means it might not be implemented by a particular Collection. If
not, that method throws an <B>UnsupportedOperationException</B>. Exceptions will
be covered in Chapter 9.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example demonstrates
all of these methods. Again, these work with anything that inherits from
<B>Collection</B>; an <B>ArrayList</B> is used as a kind of &#8220;least-common
denominator&#8221;:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Collection1.java</font>
<font color=#009900>// Things you can do with all Collections</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Collection1 {
  <font color=#009900>// Fill with 'size' elements, start</font>
  <font color=#009900>// counting at 'start':</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Collection 
  fill(Collection c, <font color=#0000ff>int</font> start, <font color=#0000ff>int</font> size) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = start; i &lt; start + size; i++)
      c.add(Integer.toString(i));
    <font color=#0000ff>return</font> c;
  }
  <font color=#009900>// Default to a "start" of 0:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Collection 
  fill(Collection c, <font color=#0000ff>int</font> size) {
    <font color=#0000ff>return</font> fill(c, 0, size);
  }
  <font color=#009900>// Default to 10 elements:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Collection fill(Collection c) {
    <font color=#0000ff>return</font> fill(c, 0, 10);
  }
  <font color=#009900>// Create &amp; upcast to Collection:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Collection newCollection() {
    <font color=#0000ff>return</font> fill(<font color=#0000ff>new</font> ArrayList());
    <font color=#009900>// ArrayList is used for simplicity, but it's</font>
    <font color=#009900>// only seen as a generic Collection </font>
    <font color=#009900>// everywhere else in the program.</font>
  }
  <font color=#009900>// Fill a Collection with a range of values:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Collection 
  newCollection(<font color=#0000ff>int</font> start, <font color=#0000ff>int</font> size) {
    <font color=#0000ff>return</font> fill(<font color=#0000ff>new</font> ArrayList(), start, size);
  }
  <font color=#009900>// Moving through a List with an iterator:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(Collection c) {
    <font color=#0000ff>for</font>(Iterator x = c.iterator(); x.hasNext();)
      System.out.print(x.next() + <font color=#004488>" "</font>);
    System.out.println();
  }    
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = newCollection();
    c.add(<font color=#004488>"ten"</font>);
    c.add(<font color=#004488>"eleven"</font>);
    print(c);
    <font color=#009900>// Make an array from the List:</font>
    Object[] array = c.toArray(); 
    <font color=#009900>// Make a String array from the List:</font>
    String[] str = 
      (String[])c.toArray(<font color=#0000ff>new</font> String[1]);
    <font color=#009900>// Find max and min elements; this means</font>
    <font color=#009900>// different things depending on the way</font>
    <font color=#009900>// the Comparable interface is implemented:</font>
    System.out.println(<font color=#004488>"Collections.max(c) = "</font> +
      Collections.max(c));
    System.out.println(<font color=#004488>"Collections.min(c) = "</font> +
      Collections.min(c));
    <font color=#009900>// Add a Collection to another Collection</font>
    c.addAll(newCollection());
    print(c);
    c.remove(<font color=#004488>"3"</font>); <font color=#009900>// Removes the first one</font>
    print(c);
    c.remove(<font color=#004488>"3"</font>); <font color=#009900>// Removes the second one</font>
    print(c);
    <font color=#009900>// Remove all components that are in the</font>
    <font color=#009900>// argument collection:</font>
    c.removeAll(newCollection());
    print(c);
    c.addAll(newCollection());
    print(c);
    <font color=#009900>// Is an element in this Collection?</font>
    System.out.println(
      <font color=#004488>"c.contains(\"</font>4\<font color=#004488>") = "</font> + c.contains(<font color=#004488>"4"</font>));
    <font color=#009900>// Is a Collection in this Collection?</font>
    System.out.println(
      <font color=#004488>"c.containsAll(newCollection()) = "</font> + 
      c.containsAll(newCollection()));
    Collection c2 = newCollection(5, 3);
    <font color=#009900>// Keep all the elements that are in both</font>
    <font color=#009900>// c and c2 (an intersection of sets):</font>
    c.retainAll(c2);
    print(c);
    <font color=#009900>// Throw away all the elements in c that</font>
    <font color=#009900>// also appear in c2:</font>
    c.removeAll(c2);
    System.out.println(<font color=#004488>"c.isEmpty() = "</font> +
      c.isEmpty());
    c = newCollection();
    print(c);
    c.clear(); <font color=#009900>// Remove all elements</font>
    System.out.println(<font color=#004488>"after c.clear():"</font>);
    print(c);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first methods provide a way to
fill any <B>Collection</B> with test data, in this case just <B>int</B>s
converted to <B>String</B>s. The second method will be used frequently
throughout the rest of this chapter.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The two versions of
<B>newCollection(&#160;)</B> create <B>ArrayList</B>s containing different sets
of data and return them as <B>Collection</B> objects, so it&#8217;s clear that
nothing other than the <B>Collection</B> interface is being
used.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>print(&#160;)</B> method
will also be used throughout the rest of this section. Since it moves through a
<B>Collection</B> using an <B>Iterator</B>, which any <B>Collection</B> can
produce, it will work with <B>List</B>s and <B>Set</B>s and any
<B>Collection</B> that a <B>Map</B> produces.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>main(&#160;)</B> uses simple
exercises to show all of the methods in <B>Collection</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following sections compare the
various implementations of <B>List</B>, <B>Set,</B> and <B>Map</B> and indicate
in each case (with an asterisk) which one should be your default choice.
You&#8217;ll notice that the legacy classes <B>Vector</B>, <B>Stack</B>, and
<B>Hashtable</B> are <I>not</I> included because in all cases there are
preferred classes within the new
collections.</FONT><A NAME="_Toc408018579"></A><BR></P></DIV>
<A NAME="Heading263"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using
Lists<A NAME="Index851"></A><A NAME="Index852"></A><A NAME="Index853"></A><A NAME="Index854"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>List</B>
(interface)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Order is the most important feature
of a <B>List</B>; it promises to maintain elements in a particular sequence.
<B>List</B> adds a number of methods to <B>Collection</B> that allow<B>
</B>insertion and removal of elements in the middle of a <B>List. </B>(This is
recommended only for a <B>LinkedList.</B>)<B> </B>A <B>List </B>will produce a
<B>ListIterator</B>, and using this you can traverse the <B>List</B> in both
directions, as well as insert and remove elements in the middle of the list
(again, recommended only for a <B>LinkedList</B>).</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ArrayList*</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>List </B>backed by an array.
Use instead of <B>Vector</B> as a general-purpose object holder. Allows rapid
random access to elements, but is slow when inserting and removing elements from
the middle of a list. <B>ListIterator</B> should be used only for back-and-forth
traversal of an <B>ArrayList</B>, but not for inserting and removing elements,
which is expensive compared to <B>LinkedList</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LinkedList</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Provides optimal sequential access,
with inexpensive insertions and deletions from the middle of the list.
Relatively slow for random access. (Use <B>ArrayList</B> instead.) Also has
<B>addFirst(&#160;)</B>, <B>addLast(&#160;)</B>, <B>getFirst(&#160;)</B>,
<B>getLast(&#160;)</B>, <B>removeFirst(&#160;)</B>, and
<B>removeLast(&#160;)</B> (which are not defined in any interfaces or base
classes) to allow it to be used as a stack, a queue, and a
dequeue.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The methods in the following
example each cover a different group of activities: things that every list can
do (<B>basicTest(&#160;)</B>), moving around with an <B>Iterator</B>
(<B>iterMotion(&#160;)</B>)<B> </B>versus changing things with an
<B>Iterator</B> (<B>iterManipulation(&#160;)</B>), seeing the effects of
<B>List</B> manipulation (<B>testVisual(&#160;)</B>), and operations available
only to <B>LinkedList</B>s.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: List1.java</font>
<font color=#009900>// Things you can do with Lists</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> List1 {
  <font color=#009900>// Wrap Collection1.fill() for convenience:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> List fill(List a) {
    <font color=#0000ff>return</font> (List)Collection1.fill(a);
  }
  <font color=#009900>// You can use an Iterator, just as with a</font>
  <font color=#009900>// Collection, but you can also use random</font>
  <font color=#009900>// access with get():</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(List a) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.size(); i++)
      System.out.print(a.get(i) + <font color=#004488>" "</font>);
    System.out.println();
  }
  <font color=#0000ff>static</font> <font color=#0000ff>boolean</font> b;
  <font color=#0000ff>static</font> Object o;
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>static</font> Iterator it;
  <font color=#0000ff>static</font> ListIterator lit;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> basicTest(List a) {
    a.add(1, <font color=#004488>"x"</font>); <font color=#009900>// Add at location 1</font>
    a.add(<font color=#004488>"x"</font>); <font color=#009900>// Add at end</font>
    <font color=#009900>// Add a collection:</font>
    a.addAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Add a collection starting at location 3:</font>
    a.addAll(3, fill(<font color=#0000ff>new</font> ArrayList())); 
    b = a.contains(<font color=#004488>"1"</font>); <font color=#009900>// Is it in there?</font>
    <font color=#009900>// Is the entire collection in there?</font>
    b = a.containsAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Lists allow random access, which is cheap</font>
    <font color=#009900>// for ArrayList, expensive for LinkedList:</font>
    o = a.get(1); <font color=#009900>// Get object at location 1</font>
    i = a.indexOf(<font color=#004488>"1"</font>); <font color=#009900>// Tell index of object</font>
    <font color=#009900>// indexOf, starting search at location 2:</font>
    i = a.indexOf(<font color=#004488>"1"</font>, 2);
    b = a.isEmpty(); <font color=#009900>// Any elements inside?</font>
    it = a.iterator(); <font color=#009900>// Ordinary Iterator</font>
    lit = a.listIterator(); <font color=#009900>// ListIterator</font>
    lit = a.listIterator(3); <font color=#009900>// Start at loc 3</font>
    i = a.lastIndexOf(<font color=#004488>"1"</font>); <font color=#009900>// Last match </font>
    i = a.lastIndexOf(<font color=#004488>"1"</font>, 2); <font color=#009900>// ...after loc 2</font>
    a.remove(1); <font color=#009900>// Remove location 1</font>
    a.remove(<font color=#004488>"3"</font>); <font color=#009900>// Remove this object</font>
    a.set(1, <font color=#004488>"y"</font>); <font color=#009900>// Set location 1 to "y"</font>
    <font color=#009900>// Keep everything that's in the argument</font>
    <font color=#009900>// (the intersection of the two sets):</font>
    a.retainAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Remove elements in this range:</font>
    a.removeRange(0, 2);
    <font color=#009900>// Remove everything that's in the argument:</font>
    a.removeAll(fill(<font color=#0000ff>new</font> ArrayList()));
    i = a.size(); <font color=#009900>// How big is it?</font>
    a.clear(); <font color=#009900>// Remove all elements</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> iterMotion(List a) {
    ListIterator it = a.listIterator();
    b = it.hasNext();
    b = it.hasPrevious();
    o = it.next();
    i = it.nextIndex();
    o = it.previous();
    i = it.previousIndex();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> iterManipulation(List a) {
    ListIterator it = a.listIterator();
    it.add(<font color=#004488>"47"</font>);
    <font color=#009900>// Must move to an element after add():</font>
    it.next();
    <font color=#009900>// Remove the element that was just produced:</font>
    it.remove(); 
    <font color=#009900>// Must move to an element after remove():</font>
    it.next();
    <font color=#009900>// Change the element that was just produced:</font>
    it.set(<font color=#004488>"47"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testVisual(List a) {
    print(a);
    List b = <font color=#0000ff>new</font> ArrayList();
    fill(b);
    System.out.print(<font color=#004488>"b = "</font>);
    print(b);
    a.addAll(b);
    a.addAll(fill(<font color=#0000ff>new</font> ArrayList()));
    print(a);
    <font color=#009900>// Shrink the list by removing all the </font>
    <font color=#009900>// elements beyond the first 1/2 of the list</font>
    System.out.println(a.size());
    System.out.println(a.size()/2);
    a.removeRange(a.size()/2, a.size()/2 + 2);
    print(a);
    <font color=#009900>// Insert, remove, and replace elements</font>
    <font color=#009900>// using a ListIterator:</font>
    ListIterator x = a.listIterator(a.size()/2);
    x.add(<font color=#004488>"one"</font>); 
    print(a);
    System.out.println(x.next());
    x.remove();
    System.out.println(x.next());
    x.set(<font color=#004488>"47"</font>);
    print(a);
    <font color=#009900>// Traverse the list backwards:</font>
    x = a.listIterator(a.size());
    <font color=#0000ff>while</font>(x.hasPrevious())
      System.out.print(x.previous() + <font color=#004488>" "</font>);
    System.out.println();
    System.out.println(<font color=#004488>"testVisual finished"</font>);
  }
  <font color=#009900>// There are some things that only</font>
  <font color=#009900>// LinkedLists can do:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testLinkedList() {
    LinkedList ll = <font color=#0000ff>new</font> LinkedList();
    Collection1.fill(ll, 5);
    print(ll);
    <font color=#009900>// Treat it like a stack, pushing:</font>
    ll.addFirst(<font color=#004488>"one"</font>);
    ll.addFirst(<font color=#004488>"two"</font>);
    print(ll);
    <font color=#009900>// Like "peeking" at the top of a stack:</font>
    System.out.println(ll.getFirst());
    <font color=#009900>// Like popping a stack:</font>
    System.out.println(ll.removeFirst());
    System.out.println(ll.removeFirst());
    <font color=#009900>// Treat it like a queue, pulling elements</font>
    <font color=#009900>// off the tail end:</font>
    System.out.println(ll.removeLast());
    <font color=#009900>// With the above operations, it's a dequeue!</font>
    print(ll);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    <font color=#009900>// Make and fill a new list each time:</font>
    basicTest(fill(<font color=#0000ff>new</font> LinkedList()));
    basicTest(fill(<font color=#0000ff>new</font> ArrayList()));
    iterMotion(fill(<font color=#0000ff>new</font> LinkedList()));
    iterMotion(fill(<font color=#0000ff>new</font> ArrayList()));
    iterManipulation(fill(<font color=#0000ff>new</font> LinkedList()));
    iterManipulation(fill(<font color=#0000ff>new</font> ArrayList()));
    testVisual(fill(<font color=#0000ff>new</font> LinkedList()));
    testLinkedList();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>basicTest(&#160;)</B> and
<B>iterMotion(&#160;)</B> the calls are simply made to show the proper syntax,
and while the return value is captured, it is not used. In some cases, the
return value isn&#8217;t captured since it isn&#8217;t typically used. You
should look up the full usage of each of these methods in your online
documentation before you use them.</FONT><A NAME="_Toc408018580"></A><BR></P></DIV>
<A NAME="Heading264"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using Sets<BR><A NAME="Index855"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Set</B> has exactly the same
interface as <B>Collection</B>, so there isn&#8217;t any extra functionality as
there is with the two different <B>List</B>s. Instead, the <B>Set</B> is exactly
a <B>Collection</B>, it just has different behavior. (This is the ideal use of
inheritance and polymorphism: to express different behavior.) A <B>Set</B>
allows only one instance of each object value to exist (what constitutes the
&#8220;value&#8221; of an object is more complex, as you shall see).
<A NAME="Index856"></A><A NAME="Index857"></A><A NAME="Index858"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Set
</B>(interface)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each element that you add to the
<B>Set</B> must be unique; otherwise the <B>Set</B> doesn&#8217;t add the
duplicate element. Objects added to a <B>Set</B> must define
<B>equals(&#160;)</B> to establish object uniqueness. <B>Set</B> has exactly the
same interface as <B>Collection</B>. The <B>Set</B> interface does not guarantee
it will maintain its elements in any particular order.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>HashSet*</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For <B>Set</B>s where fast lookup
time is important. Objects must also define
<B>hashCode(&#160;)</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TreeSet</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An ordered <B>Set</B> backed by a
red-black tree. This way, you can extract an ordered sequence from a
<B>Set</B>.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example does
<I>not</I> show everything you can do with a <B>Set</B>, since the interface is
the same as <B>Collection</B> and so was exercised in the previous example.
Instead, this demonstrates the behavior that makes a <B>Set</B>
unique:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Set1.java</font>
<font color=#009900>// Things you can do with Sets</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Set1 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testVisual(Set a) {
    Collection1.fill(a);
    Collection1.fill(a);
    Collection1.fill(a);
    Collection1.print(a); <font color=#009900>// No duplicates!</font>
    <font color=#009900>// Add another set to this one:</font>
    a.addAll(a);
    a.add(<font color=#004488>"one"</font>); 
    a.add(<font color=#004488>"one"</font>); 
    a.add(<font color=#004488>"one"</font>);
    Collection1.print(a);
    <font color=#009900>// Look something up:</font>
    System.out.println(<font color=#004488>"a.contains(\"</font>one\<font color=#004488>"): "</font> +
      a.contains(<font color=#004488>"one"</font>));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    testVisual(<font color=#0000ff>new</font> HashSet());
    testVisual(<font color=#0000ff>new</font> TreeSet());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Duplicate values are added to the
<B>Set</B>, but when it is printed you&#8217;ll see the <B>Set</B> has accepted
only one instance of each value.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program
you&#8217;ll notice that the order maintained by the <B>HashSet</B> is different
from <B>TreeSet</B>, since each has a different way of storing elements so they
can be located later. (<B>TreeSet</B> keeps them sorted, while <B>HashSet</B>
uses a hashing function, which is designed specifically for rapid lookups.) When
creating your own types, be aware that a <B>Set</B> needs a way to maintain a
storage order, just as with the &#8220;groundhog&#8221; examples shown earlier
in this chapter. To implement comparability with the new collections, however,
you must implement the <B>Comparable </B>interface and define the
<B>compareTo(&#160;) </B>method (this will be described more fully later).
Here&#8217;s an example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Set2.java</font>
<font color=#009900>// Putting your own type in a Set</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> MyType <font color=#0000ff>implements</font> Comparable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>public</font> MyType(<font color=#0000ff>int</font> n) { i = n; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> 
      (o <font color=#0000ff>instanceof</font> MyType) 
      &amp;&amp; (i == ((MyType)o).i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> i + <font color=#004488>" "</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object o) {
    <font color=#0000ff>int</font> i2 = ((MyType) o).i;
    <font color=#0000ff>return</font> (i2 &lt; i ? -1 : (i2 == i ? 0 : 1));
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Set2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Set fill(Set a, <font color=#0000ff>int</font> size) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
      a.add(<font color=#0000ff>new</font> MyType(i));
    <font color=#0000ff>return</font> a;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Set fill(Set a) {
    <font color=#0000ff>return</font> fill(a, 10);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Set a) {
    fill(a);
    fill(a); <font color=#009900>// Try to add duplicates</font>
    fill(a);
    a.addAll(fill(<font color=#0000ff>new</font> TreeSet()));
    System.out.println(a);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    test(<font color=#0000ff>new</font> HashSet());
    test(<font color=#0000ff>new</font> TreeSet());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The definitions for
<A NAME="Index859"></A><B>equals(&#160;)</B> and <B>hashCode(&#160;)</B> follow
the form given in the &#8220;groundhog&#8221; examples. You must define an
<B>equals(&#160;)</B> in both cases, but the <B>hashCode(&#160;)</B> is
absolutely necessary only if the class will be placed in a <B>HashSet</B> (which
is likely, since that should generally be your first choice as a <B>Set</B>
implementation). However, as a programming style you should always override
<B>hashCode(&#160;)</B> when you override
<B>equals(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the <B>compareTo(&#160;)</B>,
note that I did <I>not</I> use the &#8220;simple and obvious&#8221; form
<B>return i-i2</B>. Although this is a common programming error, it would only
work properly if <B>i</B> and <B>i2</B> were <B>unsigned int</B>s (if Java
<I>had </I>an &#8220;unsigned&#8221; keyword, which it does not). It breaks for
Java&#8217;s signed <B>int</B>, which are not big enough to represent the
difference of two signed <B>int</B>s. If <B>i</B> is a large positive integer
and <B>j</B> is a large negative integer, <B>i-j</B> will overflow and return a
negative value, which will not work.
</FONT><A NAME="_Toc408018581"></A><BR></P></DIV>
<A NAME="Heading265"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using
Maps<A NAME="Index860"></A><A NAME="Index861"></A><A NAME="Index862"></A><A NAME="Index863"></A><A NAME="Index864"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Map
</B>(interface)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Maintains key-value associations
(pairs), so you can look up a value using a key.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>HashMap*</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Implementation based on a hash
table. (Use this instead of <B>Hashtable.</B>) Provides constant-time
performance for inserting and locating pairs. Performance can be adjusted via
constructors that allow you to set the <I>capacity</I> and <I>load factor</I> of
the hash table.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TreeMap</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Implementation based on a red-black
tree. When you view the keys or the pairs, they will be in sorted order
(determined by <B>Comparable</B> or <B>Comparator</B>, discussed later). The
point of a <B>TreeMap</B> is that you get the results in sorted order.
<B>TreeMap </B>is the only <B>Map </B>with the <B>subMap(&#160;)</B> method,
which allows you to return a portion of the tree.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example contains two
sets of test data and a <B>fill(&#160;)</B> method that allows you to fill any
map with any two-dimensional array of <B>Object</B>s. These tools will be used
in other <B>Map</B> examples, as well.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Map1.java</font>
<font color=#009900>// Things you can do with Maps</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Map1 {
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> String[][] testData1 = {
    { <font color=#004488>"Happy"</font>, <font color=#004488>"Cheerful disposition"</font> },
    { <font color=#004488>"Sleepy"</font>, <font color=#004488>"Prefers dark, quiet places"</font> },
    { <font color=#004488>"Grumpy"</font>, <font color=#004488>"Needs to work on attitude"</font> },
    { <font color=#004488>"Doc"</font>, <font color=#004488>"Fantasizes about advanced degree"</font>},
    { <font color=#004488>"Dopey"</font>, <font color=#004488>"'A' for effort"</font> },
    { <font color=#004488>"Sneezy"</font>, <font color=#004488>"Struggles with allergies"</font> },
    { <font color=#004488>"Bashful"</font>, <font color=#004488>"Needs self-esteem workshop"</font>},
  };
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> String[][] testData2 = {
    { <font color=#004488>"Belligerent"</font>, <font color=#004488>"Disruptive influence"</font> },
    { <font color=#004488>"Lazy"</font>, <font color=#004488>"Motivational problems"</font> },
    { <font color=#004488>"Comatose"</font>, <font color=#004488>"Excellent behavior"</font> }
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Map fill(Map m, Object[][] o) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; o.length; i++)
      m.put(o[i][0], o[i][1]);
    <font color=#0000ff>return</font> m;
  }
  <font color=#009900>// Producing a Set of the keys:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> printKeys(Map m) {
    System.out.print(<font color=#004488>"Size = "</font> + m.size() +<font color=#004488>", "</font>);
    System.out.print(<font color=#004488>"Keys: "</font>);
    Collection1.print(m.keySet());
  }
  <font color=#009900>// Producing a Collection of the values:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> printValues(Map m) {
    System.out.print(<font color=#004488>"Values: "</font>);
    Collection1.print(m.values());
  }
  <font color=#009900>// Iterating through Map.Entry objects (pairs):</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(Map m) {
    Collection entries = m.entries();
    Iterator it = entries.iterator();
    <font color=#0000ff>while</font>(it.hasNext()) {
      Map.Entry e = (Map.Entry)it.next();
      System.out.println(<font color=#004488>"Key = "</font> + e.getKey() +
        <font color=#004488>", Value = "</font> + e.getValue());
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Map m) {
    fill(m, testData1);
    <font color=#009900>// Map has 'Set' behavior for keys:</font>
    fill(m, testData1);
    printKeys(m);
    printValues(m);
    print(m);
    String key = testData1[4][0];
    String value = testData1[4][1];
    System.out.println(<font color=#004488>"m.containsKey(\"</font>" + key +
      <font color=#004488>"\"</font>): " + m.containsKey(key));
    System.out.println(<font color=#004488>"m.get(\"</font><font color=#004488>" + key + "</font>\<font color=#004488>"): "</font>
      + m.get(key));
    System.out.println(<font color=#004488>"m.containsValue(\"</font>" 
      + value + <font color=#004488>"\"</font>): " + 
      m.containsValue(value)); 
    Map m2 = fill(<font color=#0000ff>new</font> TreeMap(), testData2);
    m.putAll(m2);
    printKeys(m);
    m.remove(testData2[0][0]);
    printKeys(m);
    m.clear();
    System.out.println(<font color=#004488>"m.isEmpty(): "</font> 
      + m.isEmpty());
    fill(m, testData1);
    <font color=#009900>// Operations on the Set change the Map:</font>
    m.keySet().removeAll(m.keySet());
    System.out.println(<font color=#004488>"m.isEmpty(): "</font> 
      + m.isEmpty());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    System.out.println(<font color=#004488>"Testing HashMap"</font>);
    test(<font color=#0000ff>new</font> HashMap());
    System.out.println(<font color=#004488>"Testing TreeMap"</font>);
    test(<font color=#0000ff>new</font> TreeMap());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>printKeys(&#160;)</B>,
<B>printValues(&#160;),</B> and <B>print(&#160;)</B> methods are not only useful
utilities, they also demonstrate the production of <B>Collection</B> views of a
<B>Map</B>. The <B>keySet(&#160;)</B> method produces a <B>Set</B> backed by the
keys in the <B>Map</B>; here, it is treated as only a <B>Collection</B>. Similar
treatment is given to <B>values(&#160;)</B>, which produces a <B>List</B>
containing all the values in the <B>Map.</B> (Note that keys must be unique,
while values can contain duplicates.) Since these <B>Collection</B>s are backed
by the <B>Map</B>, any changes in a <B>Collection</B> will be reflected in the
associated <B>Map</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>print(&#160;)</B> method
grabs the <B>Iterator</B> produced by <B>entries</B> and uses it to print both
the key and value for each pair. The rest of the program provides simple
examples of each <B>Map</B> operation, and tests each type of
<B>Map</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When creating your own class to use
as a key in a <B>Map</B>, you must deal with the same issues discussed
previously for <B>Set</B>s.</FONT><A NAME="_Toc408018582"></A><BR></P></DIV>
<A NAME="Heading266"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Choosing an implementation</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">From the previous diagram, you can
see that there are really only three collection components: <B>Map</B>,
<B>List</B>, and <B>Set</B>, and only two or three implementations of each
interface. If you need to use the functionality offered by a particular
<B>interface</B>, how do you decide which particular implementation to
use?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To understand the answer, you must
be aware that each different implementation has its own features, strengths, and
weaknesses. For example, you can see in the diagram that the
&#8220;feature&#8221; of <B>Hashtable</B>, <B>Vector</B>, and <B>Stack</B> is
that they are legacy classes, so that existing code doesn&#8217;t break. On the
other hand, it&#8217;s best if you don&#8217;t use those for new (Java 1.2)
code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The distinction between the other
collections often comes down to what they are &#8221;backed by;&#8221; that is,
the data structures that physically implement your desired <B>interface</B>.
This means that, for example, <B>ArrayList, LinkedList</B>, and <B>Vector</B>
(which is roughly equivalent to <B>ArrayList</B>)<B> </B>all implement the
<B>List</B> interface so your program will produce the same results regardless
of the one you use. However, <B>ArrayList</B> (and <B>Vector</B>)<B> </B>is
backed by an array, while the <B>LinkedList</B> is implemented in the usual way
for a doubly-linked list, as individual objects each containing data along with
handles to the previous and next elements in the list. Because of this, if you
want to do many insertions and removals in the middle of a list a
<B>LinkedList</B> is the appropriate choice. (<B>LinkedList</B> also has
additional functionality that is established in
<A NAME="Index865"></A><B>AbstractSequentialList</B>.) If not, an
<B>ArrayList</B> is probably faster.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As another example, a <B>Set</B>
can be implemented as either an <B>TreeSet</B> or a <B>HashSet</B>. A
<B>TreeSet</B> is backed by a <B>TreeMap</B> and is designed to produce a
constantly-sorted set. However, if you&#8217;re going to have larger quantities
in your <B>Set</B>, the performance of <B>TreeSet</B> insertions will get slow.
When you&#8217;re writing a program that needs a <B>Set</B>, you should choose
<B>HashSet</B> by default, and change to <B>TreeSet</B> when it's more important
to have a constantly-sorted set.</FONT><BR></P></DIV>
<A NAME="Heading267"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Choosing between Lists</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most convincing way to see the
differences between the implementations of <B>List</B> is with a performance
test. The following code establishes an inner base class to use as a test
framework, then creates an
<A NAME="Index866"></A><A NAME="Index867"></A>anonymous inner class for each
different test. Each of these inner classes is called by the <B>test(&#160;)</B>
method. This approach allows you to easily add and remove new kinds of
tests.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ListPerformance.java</font>
<font color=#009900>// Demonstrates performance differences in Lists</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> REPS = 100;
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    <font color=#0000ff>int</font> size; <font color=#009900>// Test quantity</font>
    Tester(String name, <font color=#0000ff>int</font> size) { 
      <font color=#0000ff>this</font>.name = name;
      <font color=#0000ff>this</font>.size = size;
    }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(List a);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"get"</font>, 300) { 
      <font color=#0000ff>void</font> test(List a) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; REPS; i++) {
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a.size(); j++)
            a.get(j);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>, 300) { 
      <font color=#0000ff>void</font> test(List a) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; REPS; i++) {
          Iterator it = a.iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"insert"</font>, 1000) { 
      <font color=#0000ff>void</font> test(List a) {
        <font color=#0000ff>int</font> half = a.size()/2;
        String s = <font color=#004488>"test"</font>;
        ListIterator it = a.listIterator(half);
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size * 10; i++)
          it.add(s);
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"remove"</font>, 5000) { 
      <font color=#0000ff>void</font> test(List a) {
        ListIterator it = a.listIterator(3);
        <font color=#0000ff>while</font>(it.hasNext()) {
          it.next();
          it.remove();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(List a) {
    <font color=#009900>// A trick to print out the class name:</font>
    System.out.println(<font color=#004488>"Testing "</font> + 
      a.getClass().getName());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      Collection1.fill(a, tests[i].size);
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(a);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + (t2 - t1));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    test(<font color=#0000ff>new</font> ArrayList());
    test(<font color=#0000ff>new</font> LinkedList());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The inner class <B>Tester</B> is
<B>abstract</B>, to provide a base class for the specific tests. It contains a
<B>String</B> to be printed when the test starts, a <B>size </B>parameter to be
used by the test for quantity of elements or repetitions of tests, a constructor
to initialize the fields, and an <B>abstract</B> method <B>test(&#160;)</B> that
does the work. All the different types of tests are collected in one place, the
array <B>tests</B>, which is initialized with different anonymous inner classes
that inherit from <B>Tester</B>. To add or remove tests, simply add or remove an
inner class definition from the array, and everything else happens
automatically.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>List</B> that&#8217;s handed
to <B>test(&#160;)</B> is first filled with elements, then each test in the
<B>tests</B> array is timed. The results will vary from machine to machine; they
are intended to give only an order of magnitude comparison between the
performance of the different collections. Here is a summary of one
run:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Type</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Get</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Iteration</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Insert</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Remove</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ArrayList</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">110</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">490</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">3790</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">8730</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LinkedList</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1980</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">220</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">110</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">110</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that random accesses
(<B>get(&#160;)</B>) are cheap for <B>ArrayList</B>s and expensive for
<B>LinkedList</B>s. (Oddly, iteration is <I>faster</I> for a <B>LinkedList</B>
than an <B>ArrayList</B>, which is counter-intuitive.) On the other hand,
insertions and removals from the middle of a list are dramatically cheaper for a
<B>LinkedList</B> than for an <B>ArrayList</B>. The best approach is probably to
choose an <B>ArrayList</B> as your default and to change to a <B>LinkedList</B>
if you discover performance problems because of many insertions and removals
from the middle of the list.</FONT><BR></P></DIV>
<A NAME="Heading268"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Choosing between Sets</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can choose between an
<B>TreeSet </B>and a <B>HashSet</B>, depending on the size of the <B>Set</B> (if
you need to produce an ordered sequence from a <B>Set</B>, use
<B>TreeSet</B>).<B> </B>The following test program gives an indication of this
tradeoff:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SetPerformance.java</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SetPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> REPS = 200;
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"add"</font>) { 
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; REPS; i++) {
          s.clear();
          Collection1.fill(s, size);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"contains"</font>) { 
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; REPS; i++)
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; size; j++)
            s.contains(Integer.toString(j));
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>) { 
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; REPS * 10; i++) {
          Iterator it = s.iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size) {
    <font color=#009900>// A trick to print out the class name:</font>
    System.out.println(<font color=#004488>"Testing "</font> + 
      s.getClass().getName() + <font color=#004488>" size "</font> + size);
    Collection1.fill(s, size);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(s, size);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + 
        ((<font color=#0000ff>double</font>)(t2 - t1)/(<font color=#0000ff>double</font>)size));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Small:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 10);
    test(<font color=#0000ff>new</font> HashSet(), 10);
    <font color=#009900>// Medium:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 100);
    test(<font color=#0000ff>new</font> HashSet(), 100);
    <font color=#009900>// Large:</font>
    test(<font color=#0000ff>new</font> HashSet(), 1000);
    test(<font color=#0000ff>new</font> TreeSet(), 1000);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following table shows the
results of one run (using Beta3 software on one particular platform; you should
run the test yourself as well):</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Type</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Test size</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Add</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Contains</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Iteration</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">22.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">11.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">16.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">TreeSet </FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">22.5</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">13.2</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">12.1</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">31.1</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">18.7</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">11.8</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">5.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">6.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">27.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">HashSet </FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">6.6</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">6.6</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10.9</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">7.4</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">6.6</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">9.5</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>HashSet</B> is generally
superior to <B>TreeSet</B> for all operations, and the performance is
effectively independent of size.</FONT><BR></P></DIV>
<A NAME="Heading269"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Choosing between Maps</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When choosing between
implementations of <B>Map</B>, the size of the <B>Map</B> is what most strongly
affects performance, and the following test program gives an indication of this
tradeoff:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MapPerformance.java</font>
<font color=#009900>// Demonstrates performance differences in Maps</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MapPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> REPS = 200;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Map fill(Map m, <font color=#0000ff>int</font> size) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++) {
      String x = Integer.toString(i);
      m.put(x, x);
    }
    <font color=#0000ff>return</font> m;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"put"</font>) { 
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; REPS; i++) {
          m.clear();
          fill(m, size);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"get"</font>) { 
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; REPS; i++)
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; size; j++)
            m.get(Integer.toString(j));
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>) { 
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; REPS * 10; i++) {
          Iterator it = m.entries().iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size) {
    <font color=#009900>// A trick to print out the class name:</font>
    System.out.println(<font color=#004488>"Testing "</font> + 
      m.getClass().getName() + <font color=#004488>" size "</font> + size);
    fill(m, size);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(m, size);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + 
        ((<font color=#0000ff>double</font>)(t2 - t1)/(<font color=#0000ff>double</font>)size));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Small:</font>
    test(<font color=#0000ff>new</font> Hashtable(), 10);
    test(<font color=#0000ff>new</font> HashMap(), 10);
    test(<font color=#0000ff>new</font> TreeMap(), 10);
    <font color=#009900>// Medium:</font>
    test(<font color=#0000ff>new</font> Hashtable(), 100);
    test(<font color=#0000ff>new</font> HashMap(), 100);
    test(<font color=#0000ff>new</font> TreeMap(), 100);
    <font color=#009900>// Large:</font>
    test(<font color=#0000ff>new</font> HashMap(), 1000);
    test(<font color=#0000ff>new</font> Hashtable(), 1000);
    test(<font color=#0000ff>new</font> TreeMap(), 1000);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because the size of the map is the
issue, you&#8217;ll see that the timing tests divide the time by the size to
normalize each measurement. Here is one set of results. (Yours will probably be
different.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=63 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Type </FONT><BR></P></DIV>
</TH>
<TH WIDTH=54 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Test size</FONT><BR></P></DIV>
</TH>
<TH WIDTH=45 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Put</FONT><BR></P></DIV>
</TH>
<TH WIDTH=45 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Get</FONT><BR></P></DIV>
</TH>
<TH WIDTH=54 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Iteration</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"> </FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">11.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">5.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">44.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Hashtable</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">7.7</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">7.7</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">16.5</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">8.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">8.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">14.4</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"> </FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">16.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">11.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">22.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TreeMap</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">25.8</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">15.4</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">13.2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">33.8</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">20.9</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">13.6</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"> </FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">11.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">6.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">33.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>HashMap</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">8.2</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">7.7</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">13.7</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">8.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">7.8</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">11.9</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you might expect,
<B>Hashtable</B> performance is roughly equivalent to <B>HashMap</B> (you can
also see that <B>HashMap</B> is generally a bit faster. Remember that
<B>HashMap</B> is intended to replace <B>Hashtable</B>). The <B>TreeMap </B>is
generally slower than the <B>HashMap</B>, so why would you use it? So you could
use it not as a <B>Map</B>,<B> </B>but as a way to create an ordered list. The
behavior of a tree is such that it&#8217;s always in order and doesn&#8217;t
have to be specially sorted. (The <I>way</I> it is ordered will be discussed
later.) Once you fill a <B>TreeMap</B>, you can call
<A NAME="Index868"></A><B>keySet(&#160;)</B> to get a <B>Set</B> view of the
keys, then <A NAME="Index869"></A><B>toArray(&#160;)</B> to produce an array of
those keys. You can then use the <B>static </B>method
<B>Arrays.binarySearch(&#160;)</B> (discussed later) to rapidly find objects in
your sorted array. Of course, you would probably only do this if, for some
reason, the behavior of a <B>HashMap</B> was unacceptable, since <B>HashMap
</B>is designed to rapidly find things. In the end, when you&#8217;re using a
<B>Map </B>your first choice should be <B>HashMap</B>, and only if you need a
constantly-sorted <B>Map</B> will you need <B>TreeMap</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is another performance issue
that the above table does not address, and that is speed of creation. The
following program tests creation speed for different types of
<B>Map</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MapCreation.java</font>
<font color=#009900>// Demonstrates time differences in Map creation</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MapCreation {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>final</font> <font color=#0000ff>long</font> REPS = 100000;
    <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
    System.out.print(<font color=#004488>"Hashtable"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; REPS; i++)
      <font color=#0000ff>new</font> Hashtable();
    <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
    System.out.println(<font color=#004488>": "</font> + (t2 - t1));
    t1 = System.currentTimeMillis();
    System.out.print(<font color=#004488>"TreeMap"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; REPS; i++)
      <font color=#0000ff>new</font> TreeMap();
    t2 = System.currentTimeMillis();
    System.out.println(<font color=#004488>": "</font> + (t2 - t1));
    t1 = System.currentTimeMillis();
    System.out.print(<font color=#004488>"HashMap"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; REPS; i++)
      <font color=#0000ff>new</font> HashMap();
    t2 = System.currentTimeMillis();
    System.out.println(<font color=#004488>": "</font> + (t2 - t1));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At the time this program was
written, the creation speed of <B>TreeMap</B> was dramatically faster than the
other two types. This, along with the acceptable and consistent
<B>put(&#160;)</B> performance of <B>TreeMap</B>, suggests a possible strategy
if you&#8217;re creating many <B>Map</B>s, and only later in your program doing
many lookups: Create and fill <B>TreeMap</B>s, and when you start looking things
up, convert the important <B>TreeMap</B>s into <B>HashMap</B>s using the
<B>HashMap(Map)</B> constructor. Again, you should only worry about this sort of
thing after it&#8217;s been proven that you have a performance bottleneck.
(&#8220;First make it work, then make it fast &#8211; if you
must.&#8221;)</FONT><A NAME="_Toc408018583"></A><BR></P></DIV>
<A NAME="Heading270"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Unsupported operations</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s possible to turn an
array into a <B>List</B> with the <B>static Arrays.toList(&#160;)</B>
method:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Unsupported.java</font>
<font color=#009900>// Sometimes methods defined in the Collection</font>
<font color=#009900>// interfaces don't work!</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Unsupported {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> String[] s = {
    <font color=#004488>"one"</font>, <font color=#004488>"two"</font>, <font color=#004488>"three"</font>, <font color=#004488>"four"</font>, <font color=#004488>"five"</font>,
    <font color=#004488>"six"</font>, <font color=#004488>"seven"</font>, <font color=#004488>"eight"</font>, <font color=#004488>"nine"</font>, <font color=#004488>"ten"</font>,
  };
  <font color=#0000ff>static</font> List a = Arrays.toList(s);
  <font color=#0000ff>static</font> List a2 = Arrays.toList(
    <font color=#0000ff>new</font> String[] { s[3], s[4], s[5] });
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection1.print(a); <font color=#009900>// Iteration</font>
    System.out.println(
      <font color=#004488>"a.contains("</font> + s[0] + <font color=#004488>") = "</font> + 
      a.contains(s[0]));
    System.out.println(
      <font color=#004488>"a.containsAll(a2) = "</font> + 
      a.containsAll(a2));
    System.out.println(<font color=#004488>"a.isEmpty() = "</font> +
      a.isEmpty());
    System.out.println(
      <font color=#004488>"a.indexOf("</font> + s[5] + <font color=#004488>") = "</font> + 
      a.indexOf(s[5]));
    <font color=#009900>// Traverse backwards:</font>
    ListIterator lit = a.listIterator(a.size());
    <font color=#0000ff>while</font>(lit.hasPrevious())
      System.out.print(lit.previous());
    System.out.println();
    <font color=#009900>// Set the elements to different values:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.size(); i++)
      a.set(i, <font color=#004488>"47"</font>);
    Collection1.print(a);
    <font color=#009900>// Compiles, but won't run:</font>
    lit.add(<font color=#004488>"X"</font>); <font color=#009900>// Unsupported operation</font>
    a.clear(); <font color=#009900>// Unsupported</font>
    a.add(<font color=#004488>"eleven"</font>); <font color=#009900>// Unsupported</font>
    a.addAll(a2); <font color=#009900>// Unsupported</font>
    a.retainAll(a2); <font color=#009900>// Unsupported</font>
    a.remove(s[0]); <font color=#009900>// Unsupported</font>
    a.removeAll(a2); <font color=#009900>// Unsupported</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll discover that only a
portion of the <B>Collection</B> and <B>List </B>interfaces are actually
implemented. The rest of the methods cause the unwelcome appearance of something
called an <A NAME="Index870"></A><B>UnsupportedOperationException</B>.
You&#8217;ll learn all about exceptions in the next chapter, but the short story
is that the <B>Collection</B> <B>interface</B>, as well as some of the other
<B>interface</B>s in the new collections library, contain
<A NAME="Index871"></A>&#8220;optional&#8221; methods, which might or might not
be &#8220;supported&#8221; in the concrete class that <B>implements</B> that
<B>interface</B>. Calling an <A NAME="Index872"></A>unsupported method causes an
<B>UnsupportedOperationException</B> to indicate a programming
error.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">&#8220;What?!?&#8221; you say,
incredulous. &#8220;The whole point of <B>interface</B>s and base classes is
that they promise these methods will do something meaningful! This breaks that
promise &#8211; it says that not only will calling some methods <I>not</I>
perform a meaningful behavior, they will stop the program! Type safety was just
thrown out the window!&#8221; It&#8217;s not quite that bad. With a
<B>Collection</B>, <B>List</B>, <B>Set</B>, or <B>Map</B>, the compiler still
restricts you to calling only the methods in that <B>interface</B>, so
it&#8217;s not like Smalltalk (in which you can call any method for any object,
and find out only when you run the program whether your call does anything). In
addition, most methods that take a <B>Collection</B> as an argument only read
from that <B>Collection</B> &#8211;all the &#8220;read&#8221; methods of
<B>Collection </B>are <I>not</I> optional.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This approach prevents an explosion
of interfaces in the design. Other designs for collection libraries always seem
to end up with a confusing plethora of interfaces to describe each of the
variations on the main theme and are thus difficult to learn. It&#8217;s not
even possible to capture all of the special cases in <B>interface</B>s, because
someone can always invent a new <B>interface</B>. The &#8220;unsupported
operation&#8221; approach achieves an important goal of the new collections
library: it is simple to learn and use. For this approach to work,
however:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	The <B>UnsupportedOperationException</B> must be
a rare event. That is, for most classes all operations should work, and only in
special cases should an operation be unsupported. This is true in the new
collections library, since the classes you&#8217;ll use 99 percent of the time
&#8211; <B>ArrayList</B>, <B>LinkedList</B>, <B>HashSet</B>, and <B>HashMap</B>,
as well as the other concrete implementations &#8211; support all of the
operations. The design does provide a &#8220;back door&#8221; if you want to
create a new <B>Collection</B> without providing meaningful definitions for all
the methods in the <B>Collection</B> <B>interface</B>, and yet still fit it into
the existing library.</FONT><LI><FONT FACE="Georgia">	When an operation
<I>is</I> unsupported, there should be reasonable likelihood that an
<B>UnsupportedOperationException</B> will appear at implementation time, rather
than after you&#8217;ve shipped the product to the customer. After all, it
indicates a programming error: you&#8217;ve used a class incorrectly. This point
is less certain, and is where the experimental nature of this design comes into
play. Only over time will we find out how well it
works.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the example
above, <A NAME="Index873"></A><B>Arrays.toList(&#160;)</B> produces a
<B>List</B> that is backed by a fixed-size array. Therefore it makes sense that
the only supported operations are the ones that don&#8217;t change the size of
the array. If, on the other hand, a new <B>interface</B> were required to
express this different kind of behavior (called, perhaps,
&#8220;<B>FixedSizeList</B>&#8221;), it would throw open the door to complexity
and soon you wouldn&#8217;t know where to start when trying to use the
library.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The documentation for a method that
takes a <B>Collection</B>, <B>List</B>, <B>Set</B>, or <B>Map</B> as an argument
should specify which of the optional methods must be implemented. For example,
sorting requires the <B>set</B>(&#160;) and <B>Iterator.set(&#160;) </B>methods
but not <B>add(&#160;)</B> and <B>remove(&#160;)</B>.
</FONT><A NAME="_Toc408018584"></A><BR></P></DIV>
<A NAME="Heading271"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Sorting and searching</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.2 adds utilities to perform
sorting and searching for <A NAME="Index874"></A>arrays or <B>List</B>s. These
utilities are <B>static </B>methods of two new classes:
<A NAME="Index875"></A><B>Arrays</B> for sorting and searching arrays, and
<A NAME="Index876"></A><B>Collections</B> for sorting and searching
<B>List</B>s.</FONT><BR></P></DIV>
<A NAME="Heading272"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Arrays</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Arrays </B>class has an
overloaded <A NAME="Index877"></A><B>sort(&#160;)</B> and
<A NAME="Index878"></A><B>binarySearch(&#160;)</B> for arrays of all the
primitive types, as well as for <B>String</B> and <B>Object</B>. Here&#8217;s an
example that shows sorting and searching an array of <B>byte</B> (all the other
primitives look the same) and an array of <B>String</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Array1.java</font>
<font color=#009900>// Testing the sorting &amp; searching in Arrays</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Array1 {
  <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>static</font> String ssource = 
    <font color=#004488>"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</font> +
    <font color=#004488>"abcdefghijklmnopqrstuvwxyz"</font>;
  <font color=#0000ff>static</font> <font color=#0000ff>char</font>[] src = ssource.toCharArray();
  <font color=#009900>// Create a random String</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String randString(<font color=#0000ff>int</font> length) {
    <font color=#0000ff>char</font>[] buf = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[length];
    <font color=#0000ff>int</font> rnd;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; length; i++) {
      rnd = Math.abs(r.nextInt()) % src.length;
      buf[i] = src[rnd];
    }
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> String(buf);
  }
  <font color=#009900>// Create a random array of Strings:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> 
  String[] randStrings(<font color=#0000ff>int</font> length, <font color=#0000ff>int</font> size) {
    String[] s = <font color=#0000ff>new</font> String[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
      s[i] = randString(length);
    <font color=#0000ff>return</font> s;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>byte</font>[] b) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; b.length; i++)
      System.out.print(b[i] + <font color=#004488>" "</font>);
    System.out.println();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(String[] s) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
      System.out.print(s[i] + <font color=#004488>" "</font>);
    System.out.println();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>byte</font>[] b = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[15];
    r.nextBytes(b); <font color=#009900>// Fill with random bytes</font>
    print(b);
    Arrays.sort(b);
    print(b);
    <font color=#0000ff>int</font> loc = Arrays.binarySearch(b, b[10]);
    System.out.println(<font color=#004488>"Location of "</font> + b[10] +
      <font color=#004488>" = "</font> + loc);
    <font color=#009900>// Test String sort &amp; search:</font>
    String[] s = randStrings(4, 10);
    print(s);
    Arrays.sort(s);
    print(s);
    loc = Arrays.binarySearch(s, s[4]);
    System.out.println(<font color=#004488>"Location of "</font> + s[4] +
      <font color=#004488>" = "</font> + loc);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first part of the class
contains utilities to generate random <B>String</B> objects using an array of
characters from which random letters can be selected. <B>randString(&#160;)</B>
returns a string of any length, and <B>randStrings(&#160;) </B>creates an array
of random <B>String</B>s, given the length of each <B>String </B>and the desired
size of the array.<B> </B>The two <B>print(&#160;)</B> methods simplify the
display of the sample arrays. In <B>main(&#160;)</B>,
<A NAME="Index879"></A><B>Random</B>.<B>nextBytes(&#160;)</B> fills the array
argument with randomly-selected <B>byte</B>s. (There are no corresponding
<B>Random </B>methods to create arrays of the other primitive data types.) Once
you have an array, you can see that it&#8217;s only a single method call to
perform a <B>sort(&#160;)</B> or <B>binarySearch(&#160;)</B>. There&#8217;s an
important warning concerning <B>binarySearch(&#160;)</B>: If you do not call
<B>sort(&#160;)</B> before you perform a <B>binarySearch(&#160;)</B>,
unpredictable behavior can occur, including infinite loops.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sorting and searching with
<B>String</B>s looks the same, but when you run the program you&#8217;ll notice
something interesting: the sorting is <A NAME="Index880"></A>lexicographic, so
uppercase letters precede lowercase letters in the character set. Thus, all the
capital letters are at the beginning of the list, followed by the lowercase
letters, so &#8216;Z&#8217; precedes &#8216;a&#8217;. It turns out that even
telephone books are typically sorted this way.</FONT><BR></P></DIV>
<A NAME="Heading273"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Comparable and Comparator</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What if this isn&#8217;t what you
want? For example, the index in this book would not be too useful if you had to
look in two places for everything that begins with &#8216;A&#8217; or
&#8216;a&#8217;. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you want to sort an array of
<B>Object</B>, there&#8217;s a problem. What determines the ordering of two
<B>Object</B>s? Unfortunately, the original Java designers didn&#8217;t consider
this an important problem, or it would have been defined in the root class
<B>Object</B>. As a result, ordering must be imposed on <B>Object</B>s from the
outside, and the new collections library provides a standard way to do this
(which is almost as good as defining it in <B>Object</B>).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is a <B>sort(&#160;)</B> for
arrays of <B>Object </B>(and <B>String</B>, of course, is an <B>Object</B>)<B>
</B>that takes a second argument: an object that implements the
<A NAME="Index881"></A><B>Comparator</B> interface (part of the new collections
library) and performs comparisons with its single
<A NAME="Index882"></A><B>compare(&#160;)</B> method. This method takes the two
objects to be compared as its arguments and returns a negative integer if the
first argument is less than the second, zero if they&#8217;re equal, and a
positive integer if the first argument is greater than the second. With this
knowledge, the <B>String</B> portion of the example above can be re-implemented
to perform an alphabetic sort:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: AlphaComp.java</font>
<font color=#009900>// Using Comparator to perform an alphabetic sort</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphaComp <font color=#0000ff>implements</font> Comparator {
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compare(Object o1, Object o2) {
    <font color=#009900>// Assume it's used only for Strings...</font>
    String s1 = ((String)o1).toLowerCase();
    String s2 = ((String)o2).toLowerCase();
    <font color=#0000ff>return</font> s1.compareTo(s2);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] s = Array1.randStrings(4, 10);
    Array1.print(s);
    AlphaComp ac = <font color=#0000ff>new</font> AlphaComp();
    Arrays.sort(s, ac);
    Array1.print(s);
    <font color=#009900>// Must use the Comparator to search, also:</font>
    <font color=#0000ff>int</font> loc = Arrays.binarySearch(s, s[3], ac);
    System.out.println(<font color=#004488>"Location of "</font> + s[3] +
     <font color=#004488>" = "</font> + loc);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By casting to <B>String</B>,<B>
</B>the <B>compare(&#160;)</B> method implicitly tests to ensure that it is used
only with <B>String </B>objects &#8211; the run-time system will catch any
discrepancies. After forcing both <B>String</B>s to lower case, the
<B>String.compareTo(&#160;)</B> method produces the desired
results.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you use your own
<B>Comparator</B> to perform a <B>sort(&#160;)</B>, you must use that same
<B>Comparator</B> when using <B>binarySearch(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Arrays</B> class has another
<B>sort(&#160;)</B> method that takes a single argument: an array of
<B>Object</B>, but with no <B>Comparator</B>. This <B>sort(&#160;)</B> method
must also have some way to compare two <B>Object</B>s. It uses the
<A NAME="Index883"></A><A NAME="Index884"></A><I>natural comparison method</I>
that is imparted to a class by implementing the
<A NAME="Index885"></A><B>Comparable</B> <B>interface</B>. This <B>interface</B>
has a single method, <A NAME="Index886"></A><B>compareTo(&#160;)</B>, which
compares the object to its argument and returns negative, zero, or positive
depending on whether it is less than, equal to, or greater than the argument. A
simple example demonstrates this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CompClass.java</font>
<font color=#009900>// A class that implements Comparable</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CompClass <font color=#0000ff>implements</font> Comparable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>public</font> CompClass(<font color=#0000ff>int</font> ii) { i = ii; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object o) {
    <font color=#009900>// Implicitly tests for correct type:</font>
    <font color=#0000ff>int</font> argi = ((CompClass)o).i;
    <font color=#0000ff>if</font>(i == argi) <font color=#0000ff>return</font> 0;
    <font color=#0000ff>if</font>(i &lt; argi) <font color=#0000ff>return</font> -1;
    <font color=#0000ff>return</font> 1;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(Object[] a) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++)
      System.out.print(a[i] + <font color=#004488>" "</font>);
    System.out.println();
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> i + <font color=#004488>""</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompClass[] a = <font color=#0000ff>new</font> CompClass[20];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++)
      a[i] = <font color=#0000ff>new</font> CompClass(
        (<font color=#0000ff>int</font>)(Math.random() *100));
    print(a);
    Arrays.sort(a);
    print(a);
    <font color=#0000ff>int</font> loc = Arrays.binarySearch(a, a[3]);
    System.out.println(<font color=#004488>"Location of "</font> + a[3] +
     <font color=#004488>" = "</font> + loc);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, your
<B>compareTo(&#160;)</B> method can be as complex as necessary.</FONT><BR></P></DIV>
<A NAME="Heading274"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Lists</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index887"></A><B>List</B> can be sorted and searched in the same
fashion as an array. The <B>static</B> methods to sort and search a <B>List</B>
are contained in the class <B>Collections</B>, but they have similar signatures
as the ones in <B>Arrays</B>: <B>sort(List)</B> to sort a <B>List</B> of objects
that implement <B>Comparable</B>, <B>binarySearch(List</B>, <B>Object)</B> to
find an object in the list, <B>sort(List, Comparator)</B> to sort a <B>List</B>
using a <B>Comparator</B>, and <B>binarySearch(List, Object, Comparator)</B> to
find an object in that
list.</FONT><A NAME="fnB37" HREF="#fn37">[37]</A><FONT FACE="Georgia">
This example uses the previously-defined <B>CompClass</B> and <B>AlphaComp</B>
to demonstrate the sorting tools in
<A NAME="Index888"></A><B>Collections</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ListSort.java</font>
<font color=#009900>// Sorting and searching Lists with 'Collections'</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListSort {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>final</font> <font color=#0000ff>int</font> SZ = 20;
    <font color=#009900>// Using "natural comparison method":</font>
    List a = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; SZ; i++)
      a.add(<font color=#0000ff>new</font> CompClass(
        (<font color=#0000ff>int</font>)(Math.random() *100)));
    Collection1.print(a);
    Collections.sort(a);
    Collection1.print(a);
    Object find = a.get(SZ/2);
    <font color=#0000ff>int</font> loc = Collections.binarySearch(a, find);
    System.out.println(<font color=#004488>"Location of "</font> + find +
     <font color=#004488>" = "</font> + loc);
    <font color=#009900>// Using a Comparator:</font>
    List b = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; SZ; i++)
      b.add(Array1.randString(4));
    Collection1.print(b);
    AlphaComp ac = <font color=#0000ff>new</font> AlphaComp();
    Collections.sort(b, ac);
    Collection1.print(b);
    find = b.get(SZ/2);
    <font color=#009900>// Must use the Comparator to search, also:</font>
    loc = Collections.binarySearch(b, find, ac);
    System.out.println(<font color=#004488>"Location of "</font> + find +
     <font color=#004488>" = "</font> + loc);
  }
} <font color=#009900>///:~ </font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of these methods is
identical to the ones in <B>Arrays</B>, but you&#8217;re using a <B>List</B>
instead of an array.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>TreeMap</B> must also order
its objects according to <B>Comparable</B> or
<B>Comparator</B>.</FONT><A NAME="_Toc408018585"></A><BR></P></DIV>
<A NAME="Heading275"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Utilities</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are a number of other useful
utilities in the <B>Collections</B> class:
<A NAME="Index889"></A><A NAME="Index890"></A><A NAME="Index891"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>enumeration(Collection)
</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces an old-style
<B>Enumeration</B> for the argument.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>max(Collection)
</B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>min(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces the maximum or minimum
element in the argument using the natural comparison method of the objects in
the <B>Collection</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>max(Collection, Comparator)
</B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>min(Collection,
Comparator)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces the maximum or minimum
element in the <B>Collection</B> using the <B>Comparator</B>. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>nCopies(int n, Object o)
</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an immutable <B>List</B> of
size <B>n</B> whose handles all point to <B>o</B>. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>subList(List, int min, int max)
</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns a new <B>List</B> backed by
the specified argument <B>List</B> that is a window into that argument with
indexes starting at <B>min</B> and stopping just before <B>max</B>.
</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>min(&#160;)</B> and
<B>max(&#160;)</B> work with <B>Collection</B> objects, not with <B>List</B>s,
so you don&#8217;t need to worry about whether the <B>Collection</B> should be
sorted or not. (As mentioned earlier, you <I>do</I> need to <B>sort(&#160;)</B>
a <B>List</B> or an array before performing a
<B>binarySearch(&#160;)</B>.)</FONT><BR></P></DIV>
<A NAME="Heading276"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Making a Collection or Map unmodifiable</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Often it is convenient to create a
read-only version of a <B>Collection</B> or <B>Map</B>. The <B>Collections</B>
class allows you to do this by passing the original container into a method that
hands back a read-only version. There are four variations on this method, one
each for <B>Collection</B> (if you don&#8217;t want to treat a <B>Collection
</B>as a more specific type), <B>List</B>, <B>Set,</B> and <B>Map</B>. This
example shows the proper way to build read-only versions of
each:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ReadOnly.java</font>
<font color=#009900>// Using the Collections.unmodifiable methods</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ReadOnly {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Collection1.fill(c); <font color=#009900>// Insert useful data</font>
    c = Collections.unmodifiableCollection(c);
    Collection1.print(c); <font color=#009900>// Reading is OK</font>
    <font color=#009900>//! c.add("one"); // Can't change it</font>
    
    List a = <font color=#0000ff>new</font> ArrayList();
    Collection1.fill(a);
    a = Collections.unmodifiableList(a);
    ListIterator lit = a.listIterator();
    System.out.println(lit.next()); <font color=#009900>// Reading OK</font>
    <font color=#009900>//! lit.add("one"); // Can't change it</font>

    Set s = <font color=#0000ff>new</font> HashSet();
    Collection1.fill(s);
    s = Collections.unmodifiableSet(s);
    Collection1.print(s); <font color=#009900>// Reading OK</font>
    <font color=#009900>//! s.add("one"); // Can't change it</font>
    
    Map m = <font color=#0000ff>new</font> HashMap();
    Map1.fill(m, Map1.testData1);
    m = Collections.unmodifiableMap(m);
    Map1.print(m); <font color=#009900>// Reading OK</font>
    <font color=#009900>//! m.put("Ralph", "Howdy!");</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In each case, you must fill the
container with meaningful data <I>before</I> you make it read-only. Once it is
loaded, the best approach is to replace the existing handle with the handle that
is produced by the &#8220;<A NAME="Index892"></A>unmodifiable&#8221; call. That
way, you don&#8217;t run the risk of accidentally changing the contents once
you&#8217;ve made it unmodifiable. On the other hand, this tool also allows you
to keep a modifiable container as <B>private</B> within a class and to return a
read-only handle to that container from a method call. So you can change it from
within the class but everyone else can only read it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Calling the
&#8220;unmodifiable&#8221; method for a particular type does not cause
compile-time checking, but once the transformation has occurred, any calls to
methods that modify the contents of a particular container will produce an
<B>UnsupportedOperationException</B>.</FONT><BR></P></DIV>
<A NAME="Heading277"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Synchronizing a Collection or Map</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index893"></A><B>synchronized</B> keyword is an important part of the
subject of <A NAME="Index894"></A><I>multithreading</I>, a more complicated
topic that will not be introduced until Chapter 14. Here, I shall note only that
the <B>Collections</B> class contains a way to automatically synchronize an
entire container. The syntax is similar to the &#8220;unmodifiable&#8221;
methods:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Synchronization.java</font>
<font color=#009900>// Using the Collections.synchronized methods</font>
<font color=#0000ff>package</font> c08.newcollections;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Synchronization {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = 
      Collections.synchronizedCollection(
        <font color=#0000ff>new</font> ArrayList());
    List list = Collections.synchronizedList(
      <font color=#0000ff>new</font> ArrayList());
    Set s = Collections.synchronizedSet(
      <font color=#0000ff>new</font> HashSet());
    Map m = Collections.synchronizedMap(
      <font color=#0000ff>new</font> HashMap());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this case, you immediately pass
the new container through the appropriate &#8220;synchronized&#8221; method;
that way there&#8217;s no chance of accidentally exposing the unsynchronized
version.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The new collections also have a
mechanism to prevent more than one process from modifying the contents of a
container. The problem occurs if you&#8217;re iterating through a container and
some other process steps in and inserts, removes, or changes an object in that
container. Maybe you&#8217;ve already passed that object, maybe it&#8217;s ahead
of you, maybe the size of the container shrinks after you call
<B>size(&#160;)</B> &#8211; there are many scenarios for disaster. The new
collections library incorporates a <A NAME="Index895"></A><I>fail fast</I>
mechanism that looks for any changes to the container other than the ones your
process is personally responsible for. If it detects that someone else is
modifying the container, it immediately produces a
<A NAME="Index896"></A><B>ConcurrentModificationException</B>. This is the
&#8220;fail-fast&#8221; aspect &#8211; it doesn&#8217;t try to detect a problem
later on using a more complex
algorithm.</FONT><A NAME="_Toc408018586"></A><BR></P></DIV>
<A NAME="Heading278"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To review the collections provided
in the standard Java (1.0 and 1.1) library (<B>BitSet</B> is not included here
since it&#8217;s more of a special-purpose class):
<A NAME="Index897"></A><A NAME="Index898"></A><A NAME="Index899"></A><A NAME="Index900"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	An array associates numerical indices to
objects. It holds objects of a known type so you don&#8217;t have to cast the
result when you&#8217;re looking up an object. It can be multidimensional, and
it can hold primitives. However, its size cannot be changed once you create
it.</FONT><LI><FONT FACE="Georgia">	A <B>Vector</B> also associates
numerical indices to objects &#8211; you can think of arrays and <B>Vector</B>s
as random-access collections. The <B>Vector</B> automatically resizes itself as
you add more elements. But a <B>Vector</B> can hold only <B>Object</B> handles,
so it won&#8217;t hold primitives and you must always cast the result when you
pull an <B>Object</B> handle out of a
collection.</FONT><LI><FONT FACE="Georgia">	A <B>Hashtable</B> is a type
of <B>Dictionary</B>, which is a way to associate, not numbers, but
<I>objects</I> with other objects. A <B>Hashtable</B> also supports random
access to objects, in fact, its whole design is focused around rapid
access.</FONT><LI><FONT FACE="Georgia">	A <B>Stack</B> is a last-in,
first-out (LIFO)
queue.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re
familiar with data structures, you might wonder why there&#8217;s not a larger
set of collections. From a functionality standpoint, do you really <I>need</I> a
larger set of collections? With a <B>Hashtable,</B> you can put things in and
find them quickly, and with an <B>Enumeration</B>, you can iterate through the
sequence and perform an operation on every element in the sequence. That&#8217;s
a powerful tool, and maybe it should be enough.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But a <B>Hashtable </B>has no
concept of order. <B>Vector</B>s and arrays give you a linear order, but
it&#8217;s expensive to insert an element into the middle of either one. In
addition, queues, dequeues, priority queues, and trees are about <I>ordering</I>
the elements, not just putting them in and later finding them or moving through
them linearly. These data structures are also useful, and that&#8217;s why they
were included in Standard C++. For this reason, you should consider the
collections in the standard Java library only as a starting point, and, if you
must use Java 1.0 or 1.1, use the JGL when your needs go beyond
that.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you can use Java 1.2 you should
use only the new collections, which are likely to satisfy all your needs. Note
that the bulk of this book was created using Java 1.1, so you&#8217;ll see that
the collections used through the rest of the book are the ones that are
available only in Java 1.1: <B>Vector</B> and <B>Hashtable</B>. This is a
somewhat painful restriction at times, but it provides better backward
compatibility with older Java code. If you&#8217;re writing new code in Java
1.2, the new collections will serve you much
better.</FONT><A NAME="_Toc375545360"></A><A NAME="_Toc408018587"></A><BR></P></DIV>
<A NAME="Heading279"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
a new class called <B>Gerbil</B> with an <B>int gerbilNumber </B>that&#8217;s
initialized in the constructor (similar to the <B>Mouse </B>example in this
chapter). Give it a method called <B>hop(&#160;)</B> that prints out which
gerbil number this is and that it&#8217;s hopping. Create a <B>Vector</B> and
add a bunch of <B>Gerbil</B> objects to the <B>Vector</B>. Now use the
<B>elementAt(&#160;)</B> method to move through the <B>Vector</B> and call
<B>hop(&#160;)</B> for each
<B>Gerbil</B>.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Modify
Exercise 1 so you use an <B>Enumeration</B> to move through the <B>Vector</B>
while calling
<B>hop(&#160;)</B>.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">In
<B>AssocArray.java</B>, change the example so it uses a <B>Hashtable</B> instead
of an
<B>AssocArray</B>.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Take
the <B>Gerbil</B> class in Exercise 1 and put it into a <B>Hashtable</B>
instead, associating the name of the <B>Gerbil</B> as a <B>String</B> (the key)
for each <B>Gerbil </B>(the value) you put in the table. Get an
<B>Enumeration</B> for the <B>keys(&#160;)</B> and use it to move through the
<B>Hashtable</B>, looking up the <B>Gerbil</B> for each key and printing out the
key and telling the <B>gerbil</B> to
<B>hop(&#160;)</B>.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Change
Exercise 1 in Chapter 7 to use a <B>Vector</B> to hold the <B>Rodent</B>s and an
<B>Enumeration</B> to move through the sequence of <B>Rodent</B>s. Remember that
a <B>Vector</B> holds only <B>Object</B>s so you must use a cast (i.e.: RTTI)
when accessing individual
<B>Rodent</B>s.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">(Intermediate)
In Chapter 7, locate the <B>GreenhouseControls.java</B> example, which consists
of three files. In <B>Controller.java</B>, the class <B>EventSet</B> is just a
collection. Change the code to use a <B>Stack</B> instead of an <B>EventSet</B>.
This will require more than just replacing <B>EventSet</B> with <B>Stack</B>;
you&#8217;ll also need to use an <B>Enumeration</B> to cycle through the set of
events. You&#8217;ll probably find it easier if at times you treat the
collection as a <B>Stack</B> and at other times as a
<B>Vector</B>.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">(Challenging).
Find the source code for <B>Vector</B> in the Java source code library that
comes with all Java distributions. Copy this code and make a special version
called <B>intVector</B> that holds only <B>int</B>s. Consider what it would take
to make a special version of <B>Vector</B> for all the primitive types. Now
consider what happens if you want to make a linked list class that works with
all the primitive types. If parameterized types are ever implemented in Java,
they will provide a way to do this work for you automatically (as well as many
other
benefits).</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT></OL><HR><DIV ALIGN="LEFT"><P><A NAME="fn32" HREF="#fnB32">[32]</A><FONT FACE="Georgia" SIZE=2>
This is one of the places where C++ is distinctly superior to Java, since C++
supports <I>parameterized types</I> with the <B>template</B>
keyword.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn33" HREF="#fnB33">[33]</A><FONT FACE="Georgia" SIZE=2>
The term <I>iterator </I>is common in C++ and elsewhere in OOP, so it&#8217;s
difficult to know why the Java team used a strange name. The collections library
in Java 1.2 fixes this as well as many other problems.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn34" HREF="#fnB34">[34]</A><FONT FACE="Georgia" SIZE=2>
If you plan to use RMI (described in Chapter 15), you should be aware that
there&#8217;s a problem when putting remote objects into a <B>Hashtable</B>.
(See <I>Core Java</I>, by Cornell &amp; Horstmann, Prentice-Hall
1997).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn35" HREF="#fnB35">[35]</A><FONT FACE="Georgia" SIZE=2>
If these speedups still don&#8217;t meet your performance needs, you can further
accelerate table lookup by writing your own hash table routine. This avoids
delays due to casting to and from <B>Object</B>s and synchronization built into
the Java Class Library hash table routine. To reach even higher levels of
performance, speed enthusiasts can use Donald Knuth&#8217;s <I>The Art of
Computer Programming, Volume 3: Sorting and Searching, Second Edition</I> to
replace overflow bucket lists with arrays that have two additional benefits:
they can be optimized for disk storage characteristics and they can save most of
the time of creating and garbage collecting individual
records</FONT><FONT FACE="Georgia">.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn36" HREF="#fnB36">[36]</A><FONT FACE="Georgia" SIZE=2>
The best reference I know of is <I>Practical Algorithms for Programmers</I>, by
Andrew Binstock and John Rex, Addison-Wesley 1995.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn37" HREF="#fnB37">[37]</A><FONT FACE="Georgia">
</FONT><FONT FACE="Georgia" SIZE=2>At the time of this writing,
<B>Collections.sort(&#160;)</B> has been modified to use a <I>stable sort
algorithm</I></FONT><FONT FACE="Georgia">
</FONT><FONT FACE="Georgia" SIZE=2>(one that does not reorder equal
elements).</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter07.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter09.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/04/2000</P></DIV>

</BODY>

</HTML>
