<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:Tjava14.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/04/2000
Translation Time:23:25:12
Translation Platform:Win32
Number of Output files:27
This File:Chapter09.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>9: Error handling  with exceptions</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/TIJ2/index.html">2nd Edition</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/javaCD2.html">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 1st edition</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;1998 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter08.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter10.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_9"></A><A NAME="_Toc375545361"></A><A NAME="_Toc407441453"></A><A NAME="_Toc408018588"></A><A NAME="Heading280"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
9: Error handling <BR>with exceptions<A NAME="OLE_LINK1"></A></H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>The basic philosophy of
Java is that &#8220;badly-formed code will not be run.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As with C++, the ideal time to
catch the <A NAME="Index901"></A><A NAME="Index902"></A>error is at compile
time, before you even try to run the program. However, not all errors can be
detected at compile time. The rest of the problems must be handled at run-time
through some formality that allows the originator of the error to pass
appropriate information to a recipient who will know how to handle the
difficulty properly.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In C and other earlier languages,
there could be several of these formalities, and they were generally established
by convention and not as part of the programming language. Typically, you
returned a special value or set a flag, and the recipient was supposed to look
at the value or the flag and determine that something was amiss. However, as the
years passed, it was discovered that programmers who use a library tend to think
of themselves as invincible, as in, &#8220;Yes, errors might happen to others
but not in <I>my</I> code.&#8221; So, not too surprisingly, they wouldn&#8217;t
check for the error conditions (and sometimes the error conditions were too
silly to check
for</FONT><A NAME="fnB38" HREF="#fn38">[38]</A><FONT FACE="Georgia">). If
you <I>were</I> thorough enough to check for an error every time you called a
method, your code could turn into an unreadable nightmare. Because programmers
could still coax systems out of these languages they were resistant to admitting
the truth: This approach to handling errors was a major limitation to creating
large, robust, maintainable programs.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution is to take the casual
nature out of error handling and to enforce formality. This actually has a long
history, since implementations of <I>exception handling</I> go back to operating
systems in the 1960s and even to BASIC&#8217;s <B>on error goto</B>. But C++
exception handling was based on Ada, and Java&#8217;s is based primarily on C++
(although it looks even more like Object Pascal).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The word &#8220;exception&#8221; is
meant in the sense of &#8220;I take exception to that.&#8221; At the point where
the problem occurs you might not know what to do with it, but you do know that
you can&#8217;t just continue on merrily; you must stop and somebody, somewhere,
must figure out what to do. But you don&#8217;t have enough information in the
current context to fix the problem. So you hand the problem out to a higher
context where someone is qualified to make the proper decision (much like a
chain of command).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The other rather significant
benefit of exceptions is that they clean up error handling code. Instead of
checking for a particular error and dealing with it at multiple places in your
program, you no longer need to check at the point of the method call (since the
exception will guarantee that someone catches it). And, you need to handle the
problem in only one place, the so-called <A NAME="Index903"></A><I>exception
handler</I>. This saves you code and it separates the code that describes what
you want to do from the code that is executed when things go awry. In general,
reading, writing, and debugging code becomes much clearer with exceptions than
when using the old way.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because exception handling is
enforced by the Java compiler, there are only so many examples that can be
written in this book without learning about exception handling. This chapter
introduces you to the code you need to write to properly handle the exceptions,
and the way you can generate your own exceptions if one of your methods gets
into
trouble.</FONT><A NAME="_Toc375545362"></A><A NAME="_Toc408018589"></A><BR></P></DIV>
<A NAME="Heading281"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Basic exceptions</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An
<A NAME="Index904"></A><I>exceptional condition</I> is a problem that prevents
the continuation of the method or scope that you&#8217;re in. It&#8217;s
important to distinguish an exceptional condition from a normal problem, in
which you have enough information in the current context to somehow cope with
the difficulty. With an exceptional condition, you cannot continue processing
because you don&#8217;t have the information necessary to deal with the problem
<I>in the current context</I>. All you can do is jump out of the current context
and relegate that problem to a higher context. This is what happens when you
throw an exception.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A simple example is a divide. If
you&#8217;re about to divide by zero, it&#8217;s worth checking to make sure you
don&#8217;t go ahead and perform the divide. But what does it mean that the
denominator is zero? Maybe you know, in the context of the problem you&#8217;re
trying to solve in that particular method, how to deal with a zero denominator.
But if it&#8217;s an unexpected value, you can&#8217;t deal with it and so must
throw an exception rather than continuing along that path.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you throw an
<A NAME="Index905"></A>exception, several things happen. First, the exception
object is created in the same way that any Java object is created: on the heap,
with <B>new</B>. Then the current path of execution (the one you couldn&#8217;t
continue, remember) is stopped and the handle for the exception object is
ejected from the current context. At this point the exception-handling mechanism
takes over and begins to look for an appropriate place to continue executing the
program. This appropriate place is the <I>exception handler</I>, whose job is to
recover from the problem so the program can either try another tack or simply
continue.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a simple example of throwing an
exception, consider an object handle called <B>t</B>. It&#8217;s possible that
you might be passed a handle that hasn&#8217;t been initialized, so you might
want to check before trying to call a method using that object handle. You can
send information about the error into a larger context by creating an object
representing your information and &#8220;throwing&#8221; it out of your current
context. This is called <I>throwing an exception</I>. Here&#8217;s what it looks
like:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(t == <font color=#0000ff>null</font>)
  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This throws the exception, which
allows you &#8211; in the current context &#8211; to abdicate responsibility for
thinking about the issue further. It&#8217;s just magically handled somewhere
else. Precisely <I>where </I>will be shown
shortly.</FONT><A NAME="_Toc375545363"></A><A NAME="_Toc408018590"></A><BR></P></DIV>
<A NAME="Heading282"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Exception arguments<BR><A NAME="Index906"></A><A NAME="Index907"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like any object in Java, you always
create exceptions on the heap using <B>new</B> and a constructor gets called.
There are two constructors in all the standard exceptions; the first is the
default constructor, and the second takes a string argument so you can place
pertinent information in the exception:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(t == <font color=#0000ff>null</font>)
  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException(<font color=#004488>"t = null"</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This string can later be extracted
using various methods, as will be shown later.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <A NAME="Index908"></A>keyword
<B>throw</B> causes a number of relatively magical things to happen. First it
executes the <B>new</B>-expression to create<B> </B>an object that isn&#8217;t
there under normal program execution, and of course, the constructor is called
for that object. Then the object is, in effect, &#8220;returned&#8221; from the
method, even though that object type isn&#8217;t normally what the method is
designed to return. A simplistic way to think about exception handling is as an
alternate return mechanism, although you get into trouble if you take that
analogy too far. You can also exit from ordinary scopes by throwing an
exception. But a value is returned, and the method or scope
exits.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any similarity to an ordinary
return from a method ends here, because <I>where</I> you return is someplace
completely different from where you return for a normal method call. (You end up
in an appropriate exception handler that might be miles away &#8211; many levels
lower on the call stack &#8211; from where the exception was
thrown.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, you can throw any type
of <B>Throwable</B> object that you want. Typically, you&#8217;ll throw a
different class of exception for each different type of error. The idea is to
store the information in the exception object <I>and</I> in the type of
exception object chosen, so someone in the bigger context can figure out what to
do with your exception. (Often, the only information is the type of exception
object, and nothing meaningful is stored within the exception
object.)</FONT><A NAME="_Toc305593298"></A><A NAME="_Toc305628770"></A><A NAME="_Toc312374113"></A><A NAME="_Toc375545364"></A><A NAME="_Toc408018591"></A><BR></P></DIV>
<A NAME="Heading283"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Catching an exception<BR><A NAME="Index909"></A><A NAME="Index910"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If a method throws an exception, it
must assume that exception is caught and dealt with. One of the advantages of
Java exception handling is that it allows you to concentrate on the problem
you&#8217;re trying to solve in one place, and then deal with the errors from
that code in another place.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To see how an exception is caught,
you must first understand the concept of a
<A NAME="Index911"></A><A NAME="Index912"></A><I>guarded region</I>, which is a
section of code that might produce exceptions, and is followed by the code to
handle those
exceptions.</FONT><A NAME="_Toc312374114"></A><A NAME="_Toc375545365"></A><A NAME="_Toc408018592"></A><BR></P></DIV>
<A NAME="Heading284"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The try block</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re inside a method and
you throw an exception (or another method you call within this method throws an
exception), that method will exit in the process of throwing. If you don&#8217;t
want a <B>throw </B>to leave a method, you can set up a special block within
that method to capture the exception. This is called the <I>try</I>
<I>block<A NAME="Index913"></A><A NAME="Index914"></A></I> because you
&#8220;try&#8221; your various method calls there. The try block is an ordinary
scope, preceded by the keyword <B>try</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>try</font> {
  <font color=#009900>// Code that might generate exceptions</font>
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you were checking for errors
carefully in a programming language that didn&#8217;t support exception
handling, you&#8217;d have to surround every method call with setup and error
testing code, even if you call the same method several times. With exception
handling, you put everything in a try block and capture all the exceptions in
one place. This means your code is a lot easier to write and easier to read
because the goal of the code is not confused with the error
checking.</FONT><A NAME="_Toc312374115"></A><A NAME="_Toc375545366"></A><A NAME="_Toc408018593"></A><BR></P></DIV>
<A NAME="Heading285"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Exception handlers</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, the thrown exception
must end up someplace. This &#8220;place&#8221; is the <I>exception
handler<A NAME="Index915"></A><A NAME="Index916"></A></I>, and there&#8217;s one
for every exception type you want to catch. Exception handlers immediately
follow the try block and are denoted by the keyword
<B>catch<A NAME="Index917"></A></B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>try</font> {
  <font color=#009900>// Code that might generate exceptions</font>
} <font color=#0000ff>catch</font>(Type1 id1) {
  <font color=#009900>// Handle exceptions of Type1</font>
} <font color=#0000ff>catch</font>(Type2 id2) {
  <font color=#009900>// Handle exceptions of Type2</font>
} <font color=#0000ff>catch</font>(Type3 id3) {
  <font color=#009900>// Handle exceptions of Type3</font>
}

<font color=#009900>// etc...</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each catch clause (exception
handler) is like a little method that takes one and only one argument of a
particular type. The identifier (<B>id1</B>, <B>id2</B>, and so on) can be used
inside the handler, just like a method argument. Sometimes you never use the
identifier because the type of the exception gives you enough information to
deal with the exception, but the identifier must still be
there.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The handlers must appear directly
after the try block. If an exception is thrown, the exception-handling mechanism
goes hunting for the first handler with an argument that matches the type of the
exception. Then it enters that catch clause, and the exception is considered
handled. (The search for handlers stops once the catch clause is finished.) Only
the matching catch clause executes; it&#8217;s not like a <B>switch</B>
statement in which you need a <B>break</B> after each <B>case</B> to prevent the
remaining ones from executing.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that, within the try block, a
number of different method calls might generate the same exception, but you need
only one handler.</FONT><BR></P></DIV>
<A NAME="Heading286"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Termination vs.
resumption<BR><A NAME="Index918"></A><A NAME="Index919"></A><A NAME="Index920"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are two basic models in
exception-handling theory. In <I>termination</I> (which is what Java and C++
support), you assume the error is so critical there&#8217;s no way to get back
to where the exception occurred. Whoever threw the exception decided that there
was no way to salvage the situation, and they don&#8217;t <I>want</I> to come
back.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The alternative is called
<I>resumption</I>. It means that the exception handler is expected to do
something to rectify the situation, and then the faulting method is retried,
presuming success the second time. If you want resumption, it means you still
hope to continue execution after the exception is handled. In this case, your
exception is more like a method call &#8211; which is how you should set up
situations in Java in which you want resumption-like behavior. (That is,
don&#8217;t throw an exception; call a method that fixes the problem.)
Alternatively, place your <B>try</B> block inside a <B>while</B> loop that keeps
reentering the <B>try</B> block until the result is
satisfactory.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Historically, programmers using
operating systems that supported resumptive exception handling eventually ended
up using termination-like code and skipping resumption. So although resumption
sounds attractive at first, it seems it isn&#8217;t quite so useful in practice.
The dominant reason is probably the <A NAME="Index921"></A><I>coupling </I>that
results: your handler must often be aware of where the exception is thrown from
and contain non-generic code specific to the throwing location. This makes the
code difficult to write and maintain, especially for large systems where the
exception can be generated from many
points.</FONT><A NAME="_Toc312374116"></A><A NAME="_Toc375545367"></A><A NAME="_Toc408018594"></A><BR></P></DIV>
<A NAME="Heading287"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The exception
specification<BR><A NAME="Index922"></A><A NAME="Index923"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Java, you&#8217;re required to
inform the client programmer, who calls your method, of the exceptions that
might be thrown from your method. This is civilized because the caller can know
exactly what code to write to catch all potential exceptions. Of course, if
source code is available, the client programmer could hunt through and look for
<B>throw</B> statements, but often a library doesn&#8217;t come with sources. To
prevent this from being a problem, Java provides syntax (and <I>forces </I>you
to use that syntax) to allow you to politely tell the client programmer what
exceptions this method throws, so the client programmer can handle them. This is
the <I>exception specification</I> and it&#8217;s part of the method
declaration, appearing after the argument list.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The exception specification uses an
additional keyword, <B>throws</B>, followed by a list of all the potential
exception types. So your method definition might look like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> tooBig, tooSmall, divZero { <font color=#009900>//... </font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you say</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> f() { <font color=#009900>// ...</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">it means that no exceptions are
thrown from the method. (<I>Except </I>for the exceptions of type
<B>RuntimeException</B>, which can reasonably be thrown anywhere &#8211; this
will be described later.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can&#8217;t lie about an
exception specification &#8211; if your method causes exceptions and
doesn&#8217;t handle them, the compiler will detect this and tell you that you
must either handle the exception or indicate with an exception specification
that it may be thrown from your method. By enforcing exception specifications
from top to bottom, Java guarantees that exception correctness can be ensured
<I>at compile time</I>.</FONT><A NAME="fnB39" HREF="#fn39">[39]</A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is one place you can lie: you
can claim to throw an exception that you don&#8217;t. The compiler takes your
word for it and forces the users of your method to treat it as if it really does
throw that exception. This has the beneficial effect of being a placeholder for
that exception, so you can actually start throwing the exception later without
requiring changes to existing
code.</FONT><A NAME="_Toc312374118"></A><A NAME="_Toc375545368"></A><A NAME="_Toc408018595"></A><BR></P></DIV>
<A NAME="Heading288"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Catching any exception<BR><A NAME="Index924"></A><A NAME="Index925"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is possible to create a handler
that catches any type of exception. You do this by catching the base-class
exception type <B>Exception</B> (there are other types of base exceptions, but
<B>Exception</B> is the base that&#8217;s pertinent to virtually all programming
activities):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>catch</font>(Exception e) {
  System.out.println(<font color=#004488>"caught an exception"</font>);
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This will catch any exception, so
if you use it you&#8217;ll want to put it at the <I>end</I> of your list of
handlers to avoid pre-empting any exception handlers that might otherwise follow
it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since the <B>Exception</B> class is
the base of all the exception classes that are important to the programmer, you
don&#8217;t get much specific information about the exception, but you can call
the methods that come from <I>its</I> base type
<A NAME="Index926"></A><A NAME="Index927"></A><B>Throwable</B>:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>String
getMessage(&#160;)</B></FONT><BR><FONT FACE="Georgia">Gets the detail
message. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>String
toString(&#160;)</B></FONT><BR><FONT FACE="Georgia">Returns a short
description of the Throwable, including the detail message if there is
one.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void
<A NAME="Index928"></A>printStackTrace(&#160;)
</B></FONT><BR><FONT FACE="Georgia"><B>void printStackTrace(PrintStream)
</B></FONT><BR><FONT FACE="Georgia">Prints the Throwable and the
Throwable&#8217;s call stack trace. The call stack shows the sequence of method
calls that brought you to the point at which the exception was
thrown.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first version prints to
standard error, the second prints to a stream of your choice. If you&#8217;re
working under Windows, you can&#8217;t redirect standard error so you might want
to use the second version and send the results to <B>System.out</B>; that way
the output can be redirected any way you want.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, you get some other
methods from <B>Throwable</B>&#8217;s base type <B>Object</B> (everybody&#8217;s
base type). The one that might come in handy for exceptions is
<A NAME="Index929"></A><A NAME="Index930"></A><B>getClass(&#160;)</B>, which
returns an object representing the class of this object. You can in turn query
this <B>Class</B> object for its name with <B>getName(&#160;)</B> or
<B>toString(&#160;)</B>. You can also do more sophisticated things with
<B>Class</B> objects that aren&#8217;t necessary in exception handling.
<B>Class</B> objects will be studied later in the book.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that shows
the use of the <B>Exception</B> methods: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ExceptionMethods.java</font>
<font color=#009900>// Demonstrating the Exception Methods</font>
<font color=#0000ff>package</font> c09;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ExceptionMethods {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Exception(<font color=#004488>"Here's my Exception"</font>);
    } <font color=#0000ff>catch</font>(Exception e) {
      System.out.println(<font color=#004488>"Caught Exception"</font>);
      System.out.println(
        <font color=#004488>"e.getMessage(): "</font> + e.getMessage());
      System.out.println(
        <font color=#004488>"e.toString(): "</font> + e.toString());
      System.out.println(<font color=#004488>"e.printStackTrace():"</font>);
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output for this program
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Caught Exception
e.getMessage(): Here's my Exception
e.toString(): java.lang.Exception: Here's my Exception
e.printStackTrace():
java.lang.Exception: Here's my Exception
        at ExceptionMethods.main</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the methods
provide successively more information &#8211; each is effectively a superset of
the previous
one.</FONT><A NAME="_Toc312374119"></A><A NAME="_Toc375545369"></A><A NAME="_Toc408018596"></A><BR></P></DIV>
<A NAME="Heading289"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Rethrowing an exception<BR><A NAME="Index931"></A><A NAME="Index932"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sometimes you&#8217;ll want to
rethrow the exception that you just caught, particularly when you use
<B>Exception</B> to catch any exception. Since you already have the handle to
the current exception, you can simply re-throw that handle:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>catch</font>(Exception e) {
  System.out.println(<font color=#004488>"An exception was thrown"</font>);
  <font color=#0000ff>throw</font> e;
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Rethrowing an exception causes the
exception to go to the exception handlers in the next-higher context. Any
further <B>catch</B> clauses for the same <B>try</B> block are still ignored. In
addition, everything about the exception object is preserved, so the handler at
the higher context that catches the specific exception type can extract all the
information from that object.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you simply re-throw the current
exception, the information that you print about that exception in
<A NAME="Index933"></A><A NAME="Index934"></A><B>printStackTrace(&#160;)
</B>will pertain to the exception&#8217;s origin, not the place where you
re-throw it. If you want to install new stack trace information, you can do so
by calling
<A NAME="Index935"></A><A NAME="Index936"></A><B>fillInStackTrace(&#160;)</B>,
which returns an exception object that it creates by stuffing the current stack
information into the old exception object. Here&#8217;s what it looks
like:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Rethrowing.java</font>
<font color=#009900>// Demonstrating fillInStackTrace()</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Rethrowing {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> Exception {
    System.out.println(
      <font color=#004488>"originating the exception in f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Exception(<font color=#004488>"thrown from f()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() <font color=#0000ff>throws</font> Throwable {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.out.println(
        <font color=#004488>"Inside g(), e.printStackTrace()"</font>);
      e.printStackTrace();
      <font color=#0000ff>throw</font> e; <font color=#009900>// 17</font>
      <font color=#009900>// throw e.fillInStackTrace(); // 18</font>
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  main(String[] args) <font color=#0000ff>throws</font> Throwable {
    <font color=#0000ff>try</font> {
      g();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.out.println(
        <font color=#004488>"Caught in main, e.printStackTrace()"</font>);
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The important line numbers are
marked inside of comments. With line 17 un-commented (as shown), the output
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>originating the exception in f()
Inside g(), e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.f(Rethrowing.java:8)
        at Rethrowing.g(Rethrowing.java:12)
        at Rethrowing.main(Rethrowing.java:24)
Caught in main, e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.f(Rethrowing.java:8)
        at Rethrowing.g(Rethrowing.java:12)
        at Rethrowing.main(Rethrowing.java:24)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So the exception stack trace always
remembers its true point of origin, no matter how many times it gets
rethrown.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With line 17 commented and line 18
un-commented, <B>fillInStackTrace(&#160;)</B> is used instead, and the result
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>originating the exception in f()
Inside g(), e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.f(Rethrowing.java:8)
        at Rethrowing.g(Rethrowing.java:12)
        at Rethrowing.main(Rethrowing.java:24)
Caught in main, e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.g(Rethrowing.java:18)
        at Rethrowing.main(Rethrowing.java:24)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because of
<B>fillInStackTrace(&#160;)</B>, line 18 becomes the new
<A NAME="Index937"></A>point of origin of the exception.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class <B>Throwable</B> must
appear in the exception specification for <B>g(&#160;)</B> and
<B>main(&#160;)</B> because <B>fillInStackTrace(&#160;)</B> produces a handle to
a <B>Throwable</B> object. Since <A NAME="Index938"></A><B>Throwable</B> is a
base class of <B>Exception</B>, it&#8217;s possible to get an object
that&#8217;s a <B>Throwable</B> but <I>not</I> an <B>Exception</B>, so the
handler for <B>Exception</B> in <B>main(&#160;) </B>might miss it. To make sure
everything is in order, the compiler forces an exception specification for
<B>Throwable</B>. For example, the exception in the following program is
<I>not</I> caught in <B>main(&#160;)</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ThrowOut.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> ThrowOut {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  main(String[] args) <font color=#0000ff>throws</font> Throwable {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Throwable(); 
    } <font color=#0000ff>catch</font>(Exception e) {
      System.out.println(<font color=#004488>"Caught in main()"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s also possible to rethrow
a different exception from the one you caught. If you do this, you get a similar
effect as when you use <B>fillInStackTrace(&#160;)</B>: the information about
the original site of the exception is lost, and what you&#8217;re left with is
the information pertaining to the new <B>throw</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: RethrowNew.java</font>
<font color=#009900>// Rethrow a different object from the one that</font>
<font color=#009900>// was caught</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> RethrowNew {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> Exception {
    System.out.println(
      <font color=#004488>"originating the exception in f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Exception(<font color=#004488>"thrown from f()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.out.println(
        <font color=#004488>"Caught in main, e.printStackTrace()"</font>);
      e.printStackTrace();
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException(<font color=#004488>"from main"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>originating the exception in f()
Caught in main, e.printStackTrace()
java.lang.Exception: thrown from f()
        at RethrowNew.f(RethrowNew.java:8)
        at RethrowNew.main(RethrowNew.java:13)
java.lang.NullPointerException: from main
        at RethrowNew.main(RethrowNew.java:18)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The final exception knows only that
it came from <B>main(&#160;)</B>, and not from <B>f(&#160;)</B>. Note that
<B>Throwable</B> isn&#8217;t necessary in any of the exception
specifications.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You never have to worry about
cleaning up the previous exception, or any exceptions for that matter.
They&#8217;re all heap-based objects created with <B>new</B>, so the garbage
collector automatically cleans them all
up.</FONT><A NAME="_Toc375545370"></A><A NAME="_Toc408018597"></A><BR></P></DIV>
<A NAME="Heading290"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Standard Java exceptions</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java contains a class called
<B>Throwable</B> that describes anything that can be thrown as an exception.
There are two general types of <B>Throwable</B> objects (&#8220;types of&#8221;
= &#8220;inherited from&#8221;). <A NAME="Index939"></A><B>Error</B> represents
compile-time and system errors that you don&#8217;t worry about catching (except
in special cases). <A NAME="Index940"></A><B>Exception</B> is the basic type
that can be thrown from any of the standard Java library class methods and from
your methods and run-time accidents.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The best way to get an overview of
the exceptions is to browse online Java documentation from
<I>http://java.sun.com.</I> (Of course, it&#8217;s easier to download it first.)
It&#8217;s worth doing this once just to get a feel for the various exceptions,
but you&#8217;ll soon see that there isn&#8217;t anything special between one
exception and the next except for the name. Also, the number of exceptions in
Java keeps expanding; basically it&#8217;s pointless to print them in a book.
Any new library you get from a third-party vendor will probably have its own
exceptions as well. The important thing to understand is the concept and what
you should do with the exceptions.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java.lang.Exception </PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is the basic exception class
your program can catch. Other exceptions are derived from this. The basic idea
is that the name of the exception represents the problem that occurred and the
exception name is intended to be relatively self-explanatory. The exceptions are
not all defined in <B>java.lang</B>; some are created to support other libraries
such as <B>util</B>, <B>net,</B> and <B>io</B>, which you can see from their
full class names or what they are inherited from. For example, all IO exceptions
are inherited from
<B>java.io.IOException</B>.</FONT><A NAME="_Toc375545372"></A><A NAME="_Toc408018598"></A><BR></P></DIV>
<A NAME="Heading291"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The special case of RuntimeException</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first example in this chapter
was</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(t == <font color=#0000ff>null</font>)
  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It can be a bit horrifying to think
that you must check for <B>null</B> on every handle that is passed into a method
(since you can&#8217;t know if the caller has passed you a valid handle).
Fortunately, you don&#8217;t &#8211; this is part of the standard run-time
checking that Java performs for you, and if any call is made to a null handle,
Java will automatically throw a
<A NAME="Index941"></A><A NAME="Index942"></A><B>NullPointerException</B>. So
the above bit of code is always superfluous. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a whole group of
exception types that are in this category. They&#8217;re always thrown
automatically by Java and you don&#8217;t need to include them in your exception
specifications. Conveniently enough, they&#8217;re all grouped together by
putting them under a single base class called <B>RuntimeException</B>, which is
a perfect example of inheritance: it establishes a family of types that have
some characteristics and behaviors in common. Also, you never need to write an
exception specification saying that a method might throw a
<B>RuntimeException</B>, since that&#8217;s just assumed. Because they indicate
bugs, you virtually never catch a
<A NAME="Index943"></A><A NAME="Index944"></A><B>RuntimeException</B> &#8211;
it&#8217;s dealt with automatically. If you were forced to check for
<B>RuntimeException</B>s your code could get messy. Even though you don&#8217;t
typically catch <B>RuntimeExceptions</B>,<B> </B>in your own packages you might
choose to throw some of the <B>RuntimeException</B>s. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What happens when you don&#8217;t
catch such exceptions? Since the compiler doesn&#8217;t enforce exception
specifications for these, it&#8217;s quite plausible that a
<B>RuntimeException</B> could percolate all the way out to your <B>main(&#160;)
</B>method without being caught. To see what happens in this case, try the
following example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: NeverCaught.java</font>
<font color=#009900>// Ignoring RuntimeExceptions</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> NeverCaught {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() {
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(<font color=#004488>"From f()"</font>);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() {
    f();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    g();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can already see that a
<B>RuntimeException </B>(or anything inherited from it) is a special case, since
the compiler doesn&#8217;t require an exception specification for these
types.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java.lang.RuntimeException: From f()
        at NeverCaught.f(NeverCaught.java:9)
        at NeverCaught.g(NeverCaught.java:12)
        at NeverCaught.main(NeverCaught.java:15)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So the answer is: If a
RuntimeException gets all the way out to <B>main(&#160;)</B> without being
caught, <B>printStackTrace(&#160;)</B> is called for that exception as the
program exits.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Keep in mind that it&#8217;s
possible to ignore only <B>RuntimeException</B>s in your coding, since all other
handling is carefully enforced by the compiler. The reasoning is that a
<B>RuntimeException</B> represents a programming error:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	An error you cannot catch (receiving a null
handle handed to your method by a client programmer, for example)
</FONT><LI><FONT FACE="Georgia">	An error that you, as a programmer,
should have checked for in your code (such as
<B>ArrayIndexOutOfBoundsException</B> where you should have paid attention to
the size of the array).
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see what a
tremendous benefit it is to have exceptions in this case, since they help in the
debugging process.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s interesting to notice
that you cannot classify Java exception handling as a single-purpose tool. Yes,
it is designed to handle those pesky run-time errors that will occur because of
forces outside your code&#8217;s control, but it&#8217;s also essential for
certain types of programming bugs that the compiler cannot
detect.</FONT><A NAME="_Toc375545373"></A><A NAME="_Toc408018599"></A><BR></P></DIV>
<A NAME="Heading292"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Creating your own exceptions</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;re not stuck using the
Java <A NAME="Index945"></A>exceptions. This is important because you&#8217;ll
often need to create your own exceptions to denote a special error that your
library is capable of creating, but which was not foreseen when the Java
hierarchy was created.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To create your own exception class,
you&#8217;re forced to inherit from an existing type of exception, preferably
one that is close in meaning to your new exception. Inheriting an exception is
quite simple:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Inheriting.java</font>
<font color=#009900>// Inheriting your own exceptions</font>

<font color=#0000ff>class</font> MyException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> MyException() {}
  <font color=#0000ff>public</font> MyException(String msg) {
    <font color=#0000ff>super</font>(msg);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Inheriting {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> MyException {
    System.out.println(
      <font color=#004488>"Throwing MyException from f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() <font color=#0000ff>throws</font> MyException {
    System.out.println(
      <font color=#004488>"Throwing MyException from g()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException(<font color=#004488>"Originated in g()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(MyException e) {
      e.printStackTrace();
    }
    <font color=#0000ff>try</font> {
      g();
    } <font color=#0000ff>catch</font>(MyException e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The inheritance occurs in the
creation of the new class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> MyException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> MyException() {}
  <font color=#0000ff>public</font> MyException(String msg) {
    <font color=#0000ff>super</font>(msg);
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The key phrase here is <B>extends
Exception</B>, which says &#8220;it&#8217;s everything an <B>Exception</B> is
and more.&#8221; The added code is small &#8211; the addition of two
constructors that define the way <B>MyException</B> is created. Remember that
the compiler automatically calls the base-class default constructor if you
don&#8217;t explicitly call a base-class constructor, as in the
<B>MyException(&#160;)</B> default constructor. In the second constructor, the
base-class constructor with a <B>String</B> argument is explicitly invoked by
using the <B>super</B> keyword.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output of the program
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Throwing MyException from f()
MyException
        at Inheriting.f(Inheriting.java:16)
        at Inheriting.main(Inheriting.java:24)
Throwing MyException from g()
MyException: Originated in g()
        at Inheriting.g(Inheriting.java:20)
        at Inheriting.main(Inheriting.java:29)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see the absence of the
detail message in the <B>MyException</B> thrown from
<B>f(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The process of creating your own
exceptions can be taken further. You can add extra constructors and
members:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Inheriting2.java</font>
<font color=#009900>// Inheriting your own exceptions</font>

<font color=#0000ff>class</font> MyException2 <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> MyException2() {}
  <font color=#0000ff>public</font> MyException2(String msg) {
    <font color=#0000ff>super</font>(msg);
  }
  <font color=#0000ff>public</font> MyException2(String msg, <font color=#0000ff>int</font> x) {
    <font color=#0000ff>super</font>(msg);
    i = x;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> val() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Inheriting2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> MyException2 {
    System.out.println(
      <font color=#004488>"Throwing MyException2 from f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException2();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() <font color=#0000ff>throws</font> MyException2 {
    System.out.println(
      <font color=#004488>"Throwing MyException2 from g()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException2(<font color=#004488>"Originated in g()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> h() <font color=#0000ff>throws</font> MyException2 {
    System.out.println(
      <font color=#004488>"Throwing MyException2 from h()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException2(
      <font color=#004488>"Originated in h()"</font>, 47);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(MyException2 e) {
      e.printStackTrace();
    }
    <font color=#0000ff>try</font> {
      g();
    } <font color=#0000ff>catch</font>(MyException2 e) {
      e.printStackTrace();
    }
    <font color=#0000ff>try</font> {
      h();
    } <font color=#0000ff>catch</font>(MyException2 e) {
      e.printStackTrace();
      System.out.println(<font color=#004488>"e.val() = "</font> + e.val());
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A data member <B>i</B> has been
added, along with a method that reads that value and an additional constructor
that sets it. The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Throwing MyException2 from f()
MyException2
        at Inheriting2.f(Inheriting2.java:22)
        at Inheriting2.main(Inheriting2.java:34)
Throwing MyException2 from g()
MyException2: Originated in g()
        at Inheriting2.g(Inheriting2.java:26)
        at Inheriting2.main(Inheriting2.java:39)
Throwing MyException2 from h()
MyException2: Originated in h()
        at Inheriting2.h(Inheriting2.java:30)
        at Inheriting2.main(Inheriting2.java:44)
e.val() = 47</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since an exception is just another
kind of object, you can continue this process of embellishing the power of your
exception classes. Keep in mind, however, that all this dressing up might be
lost on the client programmers using your packages, since they might simply look
for the exception to be thrown and nothing more. (That&#8217;s the way most of
the Java library exceptions are used.) If this is the case, it&#8217;s possible
to create a new exception type with almost no code at all:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SimpleException.java</font>
<font color=#0000ff>class</font> SimpleException <font color=#0000ff>extends</font> Exception {
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This relies on the compiler to
create the default constructor (which automatically calls the base-class default
constructor). Of course, in this case you don&#8217;t get a
<B>SimpleException(String)</B> constructor, but in practice that isn&#8217;t
used
much.</FONT><A NAME="_Toc375545374"></A><A NAME="_Toc408018600"></A><BR></P></DIV>
<A NAME="Heading293"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exception restrictions<BR><A NAME="Index946"></A><A NAME="Index947"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you override a method, you can
throw only the exceptions that have been specified in the base-class version of
the method. This is a useful restriction, since it means that code that works
with the base class will automatically work with any object derived from the
base class (a fundamental OOP concept, of course), including
exceptions.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example demonstrates the kinds
of restrictions imposed (at compile time) for exceptions:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: StormyInning.java</font>
<font color=#009900>// Overridden methods may throw only the </font>
<font color=#009900>// exceptions specified in their base-class </font>
<font color=#009900>// versions, or exceptions derived from the </font>
<font color=#009900>// base-class exceptions.</font>

<font color=#0000ff>class</font> BaseballException <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> Foul <font color=#0000ff>extends</font> BaseballException {}
<font color=#0000ff>class</font> Strike <font color=#0000ff>extends</font> BaseballException {}

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Inning {
  Inning() <font color=#0000ff>throws</font> BaseballException {}
  <font color=#0000ff>void</font> event () <font color=#0000ff>throws</font> BaseballException {
   <font color=#009900>// Doesn't actually have to throw anything</font>
  }
  <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> atBat() <font color=#0000ff>throws</font> Strike, Foul;
  <font color=#0000ff>void</font> walk() {} <font color=#009900>// Throws nothing</font>
}

<font color=#0000ff>class</font> StormException <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> RainedOut <font color=#0000ff>extends</font> StormException {}
<font color=#0000ff>class</font> PopFoul <font color=#0000ff>extends</font> Foul {}

<font color=#0000ff>interface</font> Storm {
  <font color=#0000ff>void</font> event() <font color=#0000ff>throws</font> RainedOut;
  <font color=#0000ff>void</font> rainHard() <font color=#0000ff>throws</font> RainedOut;
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StormyInning <font color=#0000ff>extends</font> Inning 
    <font color=#0000ff>implements</font> Storm {
  <font color=#009900>// OK to add new exceptions for constructors,</font>
  <font color=#009900>// but you must deal with the base constructor</font>
  <font color=#009900>// exceptions:</font>
  StormyInning() <font color=#0000ff>throws</font> RainedOut, 
    BaseballException {}
  StormyInning(String s) <font color=#0000ff>throws</font> Foul, 
    BaseballException {}
  <font color=#009900>// Regular methods must conform to base class:</font>
<font color=#009900>//! void walk() throws PopFoul {} //Compile error</font>
  <font color=#009900>// Interface CANNOT add exceptions to existing</font>
  <font color=#009900>// methods from the base class:</font>
<font color=#009900>//! public void event() throws RainedOut {}</font>
  <font color=#009900>// If the method doesn't already exist in the</font>
  <font color=#009900>// base class, the exception is OK:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> rainHard() <font color=#0000ff>throws</font> RainedOut {}
  <font color=#009900>// You can choose to not throw any exceptions,</font>
  <font color=#009900>// even if base version does:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> event() {}
  <font color=#009900>// Overridden methods can throw </font>
  <font color=#009900>// inherited exceptions:</font>
  <font color=#0000ff>void</font> atBat() <font color=#0000ff>throws</font> PopFoul {}
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      StormyInning si = <font color=#0000ff>new</font> StormyInning();
      si.atBat();
    } <font color=#0000ff>catch</font>(PopFoul e) {
    } <font color=#0000ff>catch</font>(RainedOut e) {
    } <font color=#0000ff>catch</font>(BaseballException e) {}
    <font color=#009900>// Strike not thrown in derived version.</font>
    <font color=#0000ff>try</font> {
      <font color=#009900>// What happens if you upcast?</font>
      Inning i = <font color=#0000ff>new</font> StormyInning();
      i.atBat();
      <font color=#009900>// You must catch the exceptions from the</font>
      <font color=#009900>// base-class version of the method:</font>
    } <font color=#0000ff>catch</font>(Strike e) {
    } <font color=#0000ff>catch</font>(Foul e) {
    } <font color=#0000ff>catch</font>(RainedOut e) {
    } <font color=#0000ff>catch</font>(BaseballException e) {}
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Inning</B>, you can see that
both the constructor and the <B>event(&#160;)</B> method say they will throw an
exception, but they never do. This is legal because it allows you to force the
user to catch any exceptions that you might add in overridden versions of
<B>event(&#160;)</B>. The same idea holds for <B>abstract</B> methods, as seen
in <B>atBat(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>interface Storm</B> is
interesting because it contains one method (<B>event(&#160;)</B>)that is defined
in <B>Inning</B>, and one method that isn&#8217;t. Both methods throw a new type
of exception, <B>RainedOut</B>. When <B>StormyInning</B> <B>extends Inning</B>
and <B>implements Storm</B>, you&#8217;ll see that the <B>event(&#160;)</B>
method in <B>Storm</B> <I>cannot</I> change the exception interface of
<B>event(&#160;)</B> in <B>Inning</B>. Again, this makes sense because otherwise
you&#8217;d never know if you were catching the correct thing when working with
the base class. Of course, if a method described in an <B>interface</B> is not
in the base class, such as <B>rainHard(&#160;)</B>,<B> </B>then there&#8217;s no
problem if it throws exceptions.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The restriction on exceptions does
not apply to <A NAME="Index948"></A><A NAME="Index949"></A>constructors. You can
see in <B>StormyInning </B>that a constructor can throw anything it wants,
regardless of what the base-class constructor throws. However, since a
base-class constructor must always be called one way or another (here, the
default constructor is called automatically), the derived-class constructor must
declare any base-class constructor exceptions in its exception
specification.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The reason
<B>StormyInning.walk(&#160;)</B> will not compile is that it throws an
exception, while <B>Inning.walk(&#160;)</B> does not. If this was allowed, then
you could write code that called <B>Inning.walk(&#160;)</B> and that
didn&#8217;t have to handle any exceptions, but then when you substituted an
object of a class derived from <B>Inning</B>, exceptions would be thrown so your
code would break. By forcing the derived-class methods to conform to the
exception specifications of the base-class methods, substitutability of objects
is maintained.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The overridden <B>event(&#160;)</B>
method shows that a derived-class version of a method may choose to not throw
any exceptions, even if the base-class version does. Again, this is fine since
it doesn&#8217;t break any code that is written assuming the base-class version
throws exceptions. Similar logic applies to <B>atBat(&#160;)</B>, which throws
<B>PopFoul</B>, an exception that is derived from <B>Foul</B> thrown by the
base-class version of <B>atBat(&#160;)</B>. This way, if someone writes code
that works with <B>Inning</B> and calls <B>atBat(&#160;)</B>, they must catch
the <B>Foul</B> exception. Since <B>PopFoul</B> is derived from <B>Foul</B>, the
exception handler will also catch <B>PopFoul</B>. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The last point of interest is in
<B>main(&#160;)</B>. Here you can see that if you&#8217;re dealing with exactly
a <B>StormyInning</B> object, the compiler forces you to catch only the
exceptions that are specific to that class, but if you upcast to the base type
then the compiler (correctly) forces you to catch the exceptions for the base
type. All these constraints produce much more robust exception-handling
code.</FONT><A NAME="fnB40" HREF="#fn40">[40]</A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s useful to realize that
although exception specifications are enforced by the compiler during
inheritance, the exception specifications are not part of the type of a method,
which is comprised of only the method name and argument types. Therefore, you
cannot overload methods based on exception specifications. In addition, because
an exception specification exists in a base-class version of a method
doesn&#8217;t mean that it must exist in the derived-class version of the
method, and this is quite different from inheriting the methods (that is, a
method in the base class must also exist in the derived class). Put another way,
the &#8220;exception specification interface&#8221; for a particular method may
narrow during inheritance and overriding, but it may not widen &#8211; this is
precisely the opposite of the rule for the class interface during
inheritance.</FONT><A NAME="_Toc408018601"></A><BR></P></DIV>
<A NAME="Heading294"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Performing cleanup <BR>with finally</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s often some piece of
code that you want to execute whether or not an exception occurs in a <B>try</B>
block. This usually pertains to some operation other than memory recovery (since
that&#8217;s taken care of by the garbage collector). To achieve this effect,
you use a <A NAME="Index950"></A><A NAME="Index951"></A><B>finally</B>
clause</FONT><A NAME="fnB41" HREF="#fn41">[41]</A><FONT FACE="Georgia"> at
the end of all the exception handlers. The full picture of an exception-handling
section is thus:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>try</font> {
  <font color=#009900>// The guarded region:</font>
  <font color=#009900>// Dangerous stuff that might throw A, B, or C </font>
} <font color=#0000ff>catch</font> (A a1) {
  <font color=#009900>// Handle A</font>
} <font color=#0000ff>catch</font> (B b1) {
  <font color=#009900>// Handle B</font>
} <font color=#0000ff>catch</font> (C c1) {
  <font color=#009900>// Handle C</font>
} <font color=#0000ff>finally</font> {
  <font color=#009900>// Stuff that happens every time</font>
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To demonstrate that the
<B>finally</B> clause always runs, try this program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: FinallyWorks.java</font>
<font color=#009900>// The finally clause is always executed</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FinallyWorks {
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>try</font> {
        <font color=#009900>// post-increment is zero first time:</font>
        <font color=#0000ff>if</font>(count++ == 0)
          <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Exception();
        System.out.println(<font color=#004488>"No exception"</font>);
      } <font color=#0000ff>catch</font>(Exception e) {
        System.out.println(<font color=#004488>"Exception thrown"</font>);
      } <font color=#0000ff>finally</font> {
        System.out.println(<font color=#004488>"in finally clause"</font>);
        <font color=#0000ff>if</font>(count == 2) <font color=#0000ff>break</font>; <font color=#009900>// out of "while"</font>
      }
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program also gives a hint for
how you can deal with the fact that exceptions in Java (like exceptions in C++)
do not allow you to resume back to where the exception was thrown, as discussed
earlier. If you place your <B>try</B> block in a loop, you can establish a
condition that must be met before you continue the program. You can also add a
<B>static</B> counter or some other device to allow the loop to try several
different approaches before giving up. This way you can build a greater level of
robustness into your programs.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Exception thrown
in <font color=#0000ff>finally</font> clause
No exception
in <font color=#0000ff>finally</font> clause</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Whether an exception is thrown or
not, the <B>finally</B> clause is always
executed.</FONT><A NAME="_Toc375545375"></A><A NAME="_Toc408018602"></A><BR></P></DIV>
<A NAME="Heading295"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
What&#8217;s finally for?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In a language without garbage
collection <I>and</I> without automatic <A NAME="Index952"></A>destructor
calls,</FONT><A NAME="fnB42" HREF="#fn42">[42]</A><FONT FACE="Georgia">
<B>finally</B> is important because it allows the programmer to guarantee the
release of memory regardless of what happens in the
<A NAME="Index953"></A><A NAME="Index954"></A><B>try</B> block. But Java has
garbage collection, so releasing memory is virtually never a problem. Also, it
has no destructors to call. So when do you need to use
<A NAME="Index955"></A><B>finally</B> in Java?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>finally</B> is necessary when
you need to set something <I>other</I> than memory back to its original state.
This is usually something like an open file or network connection, something
you&#8217;ve drawn on the screen or even a switch in the outside world, as
modeled in the following example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: OnOffSwitch.java</font>
<font color=#009900>// Why use finally?</font>

<font color=#0000ff>class</font> Switch {
  <font color=#0000ff>boolean</font> state = <font color=#0000ff>false</font>;
  <font color=#0000ff>boolean</font> read() { <font color=#0000ff>return</font> state; }
  <font color=#0000ff>void</font> on() { state = <font color=#0000ff>true</font>; }
  <font color=#0000ff>void</font> off() { state = <font color=#0000ff>false</font>; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> OnOffSwitch {
  <font color=#0000ff>static</font> Switch sw = <font color=#0000ff>new</font> Switch();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      sw.on();
      <font color=#009900>// Code that can throw exceptions...</font>
      sw.off();
    } <font color=#0000ff>catch</font>(NullPointerException e) {
      System.out.println(<font color=#004488>"NullPointerException"</font>);
      sw.off();
    } <font color=#0000ff>catch</font>(IllegalArgumentException e) {
      System.out.println(<font color=#004488>"IOException"</font>);
      sw.off();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The goal here is to make sure that
the switch is off when <B>main(&#160;)</B> is completed, so
<B>sw.off(&#160;)</B> is placed at the end of the try block and at the end of
each exception handler. But it&#8217;s possible that an exception could be
thrown that isn&#8217;t caught here, so <B>sw.off(&#160;) </B>would be missed.
However, with <B>finally</B> you can place the closure code from a try block in
just one place:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: WithFinally.java</font>
<font color=#009900>// Finally Guarantees cleanup</font>

<font color=#0000ff>class</font> Switch2 {
  <font color=#0000ff>boolean</font> state = <font color=#0000ff>false</font>;
  <font color=#0000ff>boolean</font> read() { <font color=#0000ff>return</font> state; }
  <font color=#0000ff>void</font> on() { state = <font color=#0000ff>true</font>; }
  <font color=#0000ff>void</font> off() { state = <font color=#0000ff>false</font>; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WithFinally {
  <font color=#0000ff>static</font> Switch2 sw = <font color=#0000ff>new</font> Switch2();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      sw.on();
      <font color=#009900>// Code that can throw exceptions...</font>
    } <font color=#0000ff>catch</font>(NullPointerException e) {
      System.out.println(<font color=#004488>"NullPointerException"</font>);
    } <font color=#0000ff>catch</font>(IllegalArgumentException e) {
      System.out.println(<font color=#004488>"IOException"</font>);
    } <font color=#0000ff>finally</font> {
      sw.off();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here the <B>sw.off(&#160;)</B> has
been moved to just one place, where it&#8217;s guaranteed to run no matter what
happens.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Even in cases in which the
exception is not caught in the current set of <B>catch</B> clauses,
<B>finally</B> will be executed before the exception-handling mechanism
continues its search for a handler at the next higher level:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: AlwaysFinally.java</font>
<font color=#009900>// Finally is always executed</font>

<font color=#0000ff>class</font> Ex <font color=#0000ff>extends</font> Exception {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlwaysFinally {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(
      <font color=#004488>"Entering first try block"</font>);
    <font color=#0000ff>try</font> {
      System.out.println(
        <font color=#004488>"Entering second try block"</font>);
      <font color=#0000ff>try</font> {
        <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Ex();
      } <font color=#0000ff>finally</font> {
        System.out.println(
          <font color=#004488>"finally in 2nd try block"</font>);
      }
    } <font color=#0000ff>catch</font>(Ex e) {
      System.out.println(
        <font color=#004488>"Caught Ex in first try block"</font>);
    } <font color=#0000ff>finally</font> {
      System.out.println(
        <font color=#004488>"finally in 1st try block"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output for this program shows
you what happens:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Entering first <font color=#0000ff>try</font> block
Entering second <font color=#0000ff>try</font> block
<font color=#0000ff>finally</font> in 2nd <font color=#0000ff>try</font> block
Caught Ex in first <font color=#0000ff>try</font> block
<font color=#0000ff>finally</font> in 1st <font color=#0000ff>try</font> block</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>finally</B> statement will
also be executed in situations in which <B>break</B> and <B>continue</B>
statements are involved. Note that, along with the labeled <B>break</B> and
labeled <B>continue</B>, <B>finally</B> eliminates the need for a <B>goto
</B>statement in Java.</FONT><A NAME="_Toc408018603"></A><BR></P></DIV>
<A NAME="Heading296"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Pitfall: the lost exception</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, Java&#8217;s exception
implementation is quite outstanding, but unfortunately there&#8217;s a flaw.
Although exceptions are an indication of a crisis in your program and should
never be ignored, it&#8217;s possible for an exception to simply be
<A NAME="Index956"></A>lost. This happens with a particular configuration using
a <A NAME="Index957"></A><B>finally</B> clause:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: LostMessage.java</font>
<font color=#009900>// How an exception can be lost</font>

<font color=#0000ff>class</font> VeryImportantException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"A very important exception!"</font>;
  }
}

<font color=#0000ff>class</font> HoHumException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"A trivial exception"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LostMessage {
  <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> VeryImportantException {
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> VeryImportantException();
  }
  <font color=#0000ff>void</font> dispose() <font color=#0000ff>throws</font> HoHumException {
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> HoHumException();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> Exception {
    LostMessage lm = <font color=#0000ff>new</font> LostMessage();
    <font color=#0000ff>try</font> {
      lm.f();
    } <font color=#0000ff>finally</font> {
      lm.dispose();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>A trivial exception
        at LostMessage.dispose(LostMessage.java:21)
        at LostMessage.main(LostMessage.java:29)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that there&#8217;s no
evidence of the <B>VeryImportantException</B>, which is simply replaced by the
<B>HoHumException</B> in the <B>finally</B> clause. This is a rather serious
pitfall, since it means that an exception can be completely lost, and in a far
more subtle and difficult-to-detect fashion than the example above. In contrast,
C++ treats the situation in which a second exception is thrown before the first
one is handled as a dire programming error. Perhaps a future version of Java
will repair the problem. (The above results were produced with Java
1.1.<A NAME="Index958"></A>)</FONT><A NAME="_Toc305593300"></A><A NAME="_Toc305628772"></A><A NAME="_Toc312374122"></A><A NAME="_Toc375545376"></A><A NAME="_Toc408018604"></A><BR></P></DIV>
<A NAME="Heading297"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Constructors<BR><A NAME="Index959"></A><A NAME="Index960"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When writing code with exceptions,
it&#8217;s particularly important that you always ask, &#8220;If an exception
occurs, will this be properly cleaned up?&#8221; Most of the time you&#8217;re
fairly safe, but in constructors there&#8217;s a problem. The constructor puts
the object into a safe starting state, but it might perform some operation
&#8211; such as opening a file &#8211; that doesn&#8217;t get cleaned up until
the user is finished with the object and calls a special cleanup method. If you
throw an exception from inside a constructor, these cleanup behaviors might not
occur properly. This means that you must be especially diligent while you write
your constructor.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since you&#8217;ve just learned
about <A NAME="Index961"></A><A NAME="Index962"></A><B>finally</B>, you might
think that it is the correct solution. But it&#8217;s not quite that simple,
because <B>finally </B>performs the cleanup code <I>every time</I>, even in the
situations in which you don&#8217;t want the cleanup code executed until the
cleanup method runs. Thus, if you do perform cleanup in <B>finally</B>, you must
set some kind of flag when the constructor finishes normally and don&#8217;t do
anything in the finally block if the flag is set. Because this isn&#8217;t
particularly elegant (you are coupling your code from one place to another),
it&#8217;s best if you try to avoid performing this kind of cleanup in
<B>finally</B> unless you are forced to.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the following example, a class
called <B>InputFile</B> is created that opens a file and allows you to read it
one line (converted into a <B>String</B>) at a time. It uses the classes
<A NAME="Index963"></A><A NAME="Index964"></A><B>FileReader</B> and
<A NAME="Index965"></A><A NAME="Index966"></A><B>BufferedReader</B> from the
Java standard IO library that will be discussed in Chapter 10, but which are
simple enough that you probably won&#8217;t have any trouble understanding their
basic use:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Cleanup.java</font>
<font color=#009900>// Paying attention to exceptions</font>
<font color=#009900>// in constructors</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> InputFile {
  <font color=#0000ff>private</font> BufferedReader in;
  InputFile(String fname) <font color=#0000ff>throws</font> Exception {
    <font color=#0000ff>try</font> {
      in = 
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(fname));
      <font color=#009900>// Other code that might throw exceptions</font>
    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.out.println(
        <font color=#004488>"Could not open "</font> + fname);
      <font color=#009900>// Wasn't open, so don't close it</font>
      <font color=#0000ff>throw</font> e;
    } <font color=#0000ff>catch</font>(Exception e) {
      <font color=#009900>// All other exceptions must close it</font>
      <font color=#0000ff>try</font> {
        in.close();
      } <font color=#0000ff>catch</font>(IOException e2) {
        System.out.println(
          <font color=#004488>"in.close() unsuccessful"</font>);
      }
      <font color=#0000ff>throw</font> e;
    } <font color=#0000ff>finally</font> {
      <font color=#009900>// Don't close it here!!!</font>
    }
  }
  String getLine() {
    String s;
    <font color=#0000ff>try</font> {
      s = in.readLine();
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(
        <font color=#004488>"readLine() unsuccessful"</font>);
      s = <font color=#004488>"failed"</font>;
    }
    <font color=#0000ff>return</font> s;
  }
  <font color=#0000ff>void</font> cleanup() {
    <font color=#0000ff>try</font> {
      in.close();
    } <font color=#0000ff>catch</font>(IOException e2) {
      System.out.println(
        <font color=#004488>"in.close() unsuccessful"</font>);
    }
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Cleanup {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      InputFile in = 
        <font color=#0000ff>new</font> InputFile(<font color=#004488>"Cleanup.java"</font>);
      String s;
      <font color=#0000ff>int</font> i = 1;
      <font color=#0000ff>while</font>((s = in.getLine()) != <font color=#0000ff>null</font>)
        System.out.println(<font color=#004488>""</font>+ i++ + <font color=#004488>": "</font> + s);
      in.cleanup();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.out.println(
        <font color=#004488>"Caught in main, e.printStackTrace()"</font>);
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example uses Java
1.1<A NAME="Index967"></A> IO classes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor for
<B>InputFile</B> takes a <B>String</B> argument, which is the name of the file
you want to open. Inside a <B>try</B> block, it creates a <B>FileReader</B>
using the file name. A <B>FileReader</B> isn&#8217;t particularly useful until
you turn around and use it to create a <B>BufferedReader</B> that you can
actually talk to &#8211; notice that one of the benefits of <B>InputFile</B> is
that it combines these two actions.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the <B>FileReader</B>
constructor is unsuccessful, it throws a
<A NAME="Index968"></A><A NAME="Index969"></A><B>FileNotFoundException</B>,
which must be caught separately because that&#8217;s the one case in which you
don&#8217;t want to close the file since it wasn&#8217;t successfully opened.
Any <I>other</I> catch clauses must close the file because it <I>was</I> opened
by the time those catch clauses are entered. (Of course, this is trickier if
more than one method can throw a <B>FileNotFoundException</B>. In that case, you
might want to break things into several <B>try </B>blocks.) The
<B>close(&#160;)</B> method throws an exception that is tried and caught even
though it&#8217;s within the block of another <B>catch</B> clause &#8211;
it&#8217;s just another pair of curly braces to the Java compiler. After
performing local operations, the exception is re-thrown, which is appropriate
because this constructor failed, and you wouldn&#8217;t want the calling method
to assume that the object had been properly created and was
valid.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this example, which
doesn&#8217;t use the aforementioned flagging technique, the <B>finally</B>
clause is definitely <I>not</I> the place to <B>close(&#160;)</B> the file,
since that would close it every time the constructor completed. Since we want
the file to be open for the useful lifetime of the <B>InputFile</B> object this
would not be appropriate.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>getLine(&#160;)</B> method
returns a <B>String</B> containing the next line in the file. It calls
<A NAME="Index970"></A><A NAME="Index971"></A><B>readLine(&#160;),</B> which can
throw an exception, but that exception is caught so <B>getLine(&#160;)</B>
doesn&#8217;t throw any exceptions. One of the design issues with
<A NAME="Index972"></A>exceptions is whether to handle an exception completely
at this level, to handle it partially and pass the same exception (or a
different one) on, or whether to simply pass it on. Passing it on, when
appropriate, can certainly simplify coding. The <B>getLine(&#160;)</B> method
becomes:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>String getLine() <font color=#0000ff>throws</font> IOException {
  <font color=#0000ff>return</font> in.readLine();
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But of course, the caller is now
responsible for handling any <B>IOException</B> that might
arise.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>cleanup(&#160;)</B> method
must be called by the user when they are finished using the <B>InputFile</B>
object to release the system resources (such as file handles) that are used by
the <B>BufferedReader</B> and/or <B>FileReader</B>
objects.</FONT><A NAME="fnB43" HREF="#fn43">[43]</A><FONT FACE="Georgia">
You don&#8217;t want to do this until you&#8217;re finished with the
<B>InputFile</B> object, at the point you&#8217;re going to let it go. You might
think of putting such functionality into a
<A NAME="Index973"></A><B>finalize(&#160;)</B> method, but as mentioned in
Chapter 4 you can&#8217;t always be sure that <B>finalize(&#160;)</B> will be
called (even if you <I>can</I> be sure that it will be called, you don&#8217;t
know <I>when</I>). This is one of the downsides to Java &#8211; all cleanup
other than memory cleanup doesn&#8217;t happen automatically, so you must inform
the client programmer that they are responsible, and possibly guarantee that
cleanup occurs using <B>finalize(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Cleanup.java</B> an
<B>InputFile</B> is created to open the same source file that creates the
program, and this file is read in a line at a time, and line numbers are added.
All exceptions are caught generically in <B>main(&#160;)</B>, although you could
choose greater granularity.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the benefits of this example
is to show you why exceptions are introduced at this point in the book.
Exceptions are so integral to programming in Java, especially because the
compiler enforces them, that you can accomplish only so much without knowing how
to work with
them.</FONT><A NAME="_Toc305593301"></A><A NAME="_Toc305628773"></A><A NAME="_Toc312374124"></A><A NAME="_Toc375545377"></A><A NAME="_Toc408018605"></A><BR></P></DIV>
<A NAME="Heading298"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exception matching<BR><A NAME="Index974"></A><A NAME="Index975"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When an exception is thrown, the
exception-handling system looks through the &#8220;nearest&#8221; handlers in
the order they are written. When it finds a match, the exception is considered
handled, and no further searching occurs. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Matching an exception doesn&#8217;t
require a perfect match between the exception and its handler. A derived-class
object will match a handler for the base class, as shown in
<A NAME="Index976"></A><A NAME="Index977"></A>this example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Human.java</font>
<font color=#009900>// Catching Exception Hierarchies</font>

<font color=#0000ff>class</font> Annoyance <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> Sneeze <font color=#0000ff>extends</font> Annoyance {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Human {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Sneeze();
    } <font color=#0000ff>catch</font>(Sneeze s) {
      System.out.println(<font color=#004488>"Caught Sneeze"</font>);
    } <font color=#0000ff>catch</font>(Annoyance a) {
      System.out.println(<font color=#004488>"Caught Annoyance"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Sneeze</B> exception will be
caught by the first <B>catch</B> clause that it matches, which is the first one,
of course. However, if you remove the first catch clause:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Sneeze();
    } <font color=#0000ff>catch</font>(Annoyance a) {
      System.out.println(<font color=#004488>"Caught Annoyance"</font>);
    }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The remaining catch clause will
still work because it&#8217;s catching the base class of <B>Sneeze</B>. Put
another way, <B>catch(Annoyance e)</B> will catch a <B>Annoyance</B> <I>or any
class derived from it</I>. This is useful because if you decide to add more
exceptions to a method, if they&#8217;re all inherited from the same base class
then the client programmer&#8217;s code will not need changing, assuming they
catch the base class, at the very least.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you try to &#8220;mask&#8221;
the derived-class exceptions by putting the base-class catch clause first, like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Sneeze();
    } <font color=#0000ff>catch</font>(Annoyance a) {
      System.out.println(<font color=#004488>"Caught Annoyance"</font>);
    } <font color=#0000ff>catch</font>(Sneeze s) {
      System.out.println(<font color=#004488>"Caught Sneeze"</font>);
    }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">the compiler will give you an error
message, since it sees that the <B>Sneeze</B> catch-clause can never be
reached.</FONT><A NAME="_Toc312374128"></A><A NAME="_Toc375545378"></A><A NAME="_Toc408018606"></A><BR></P></DIV>
<A NAME="Heading299"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Exception guidelines<BR><A NAME="Index978"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Use exceptions to:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Fix
the problem and call the method (which caused the exception)
again.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Patch
things up and continue without retrying the
method.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Calculate
some alternative result instead of what the method was supposed to
produce.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Do
whatever you can in the current context and rethrow the <I>same</I> exception to
a higher
context.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Do
whatever you can in the current context and throw a <I>different</I> exception
to a higher
context.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Terminate
the
program.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Simplify.
If your exception scheme makes things more complicated, then it is painful and
annoying to
use.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Make
your library and program safer. This is a short-term investment (for debugging)
and a long-term investment (for application
robustness).</FONT><A NAME="_Toc375545379"></A><A NAME="_Toc408018607"></A></OL><A NAME="Heading300"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Improved error
recovery<A NAME="Index979"></A> is one of the most powerful ways that you can
increase the robustness of your code. Error recovery is a fundamental concern
for every program you write, and it&#8217;s especially important in Java, in
which one of the primary goals is to create program components for others to
use. To create a robust system, each component must be robust.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The goals for exception handling in
Java are to simplify the creation of large, reliable programs using less code
than currently possible, with more confidence that your application
doesn&#8217;t have an unhandled error.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Exceptions are not terribly
difficult to learn, and are one of those features that provide immediate and
significant benefits to your project. Fortunately, Java enforces all aspects of
exceptions so it&#8217;s guaranteed that they will be used consistently by both
library designer and client
programmer.</FONT><A NAME="_Toc375545380"></A><A NAME="_Toc408018608"></A><BR></P></DIV>
<A NAME="Heading301"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
a class with a <B>main(&#160;)</B> that throws an object of class
<B>Exception</B> inside a <B>try</B> block. Give the constructor for
<B>Exception</B> a string argument. Catch the exception inside a <B>catch</B>
clause and print out the string argument. Add a <B>finally</B> clause and print
a message to prove you were
there.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
your own exception class using the <B>extends</B> keyword. Write a constructor
for this class that takes a <B>String</B> argument and stores it inside the
object with a <B>String</B> handle. Write a method that prints out the stored
<B>String</B>. Create a try-catch clause to exercise your new
exception.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Write
a class with a method that throws an exception of the type created in Exercise
2. Try compiling it without an exception specification to see what the compiler
says. Add the appropriate exception specification. Try out your class and its
exception inside a try-catch
clause.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">In
chapter 5, find the two programs called <B>Assert.java</B> and modify these to
throw their own type of exception instead of printing to <B>System.err</B>. This
exception should be an inner class that extends
RuntimeException.</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn38" HREF="#fnB38">[38]</A><FONT FACE="Georgia" SIZE=2>
The C programmer can look up the return value of <B>printf(&#160;)</B> for an
example of this.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn39" HREF="#fnB39">[39]</A><FONT FACE="Georgia" SIZE=2>
This is a significant improvement over C++ exception handling, which
doesn&#8217;t catch violations of exception specifications until run time, when
it&#8217;s not very useful.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn40" HREF="#fnB40">[40]</A><FONT FACE="Georgia" SIZE=2>
ANSI/ISO C++ added similar constraints that require derived-method exceptions to
be the same as, or derived from, the exceptions thrown by the base-class method.
This is one case in which C++ is actually able to check exception specifications
at compile time.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn41" HREF="#fnB41">[41]</A><FONT FACE="Georgia" SIZE=2>
C++ exception handling does not have the <B>finally</B> clause because it relies
on destructors to accomplish this sort of cleanup.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn42" HREF="#fnB42">[42]</A><FONT FACE="Georgia" SIZE=2>
A destructor is a function that&#8217;s always called when an object becomes
unused. You always know exactly where and when the destructor gets called. C++
has automatic destructor calls, but Delphi&#8217;s Object Pascal versions 1 and
2 do not (which changes the meaning and use of the concept of a destructor for
that language).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn43" HREF="#fnB43">[43]</A><FONT FACE="Georgia" SIZE=2>
In C++, a <I>destructor</I> would handle this for you.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter08.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter10.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/04/2000</P></DIV>

</BODY>

</HTML>
