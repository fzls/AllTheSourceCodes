<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:Tjava14.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/04/2000
Translation Time:23:25:36
Translation Platform:Win32
Number of Output files:27
This File:Chapter13.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>13: Creating windows  and applets</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/TIJ2/index.html">2nd Edition</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/javaCD2.html">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 1st edition</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;1998 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter12.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter14.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_15"></A><A NAME="_Toc375545444"></A><A NAME="_Toc407441457"></A><A NAME="_Toc408018677"></A><A NAME="Heading392"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
13: Creating windows <BR>and applets</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>The original design goal
of the graphical user interface (GUI) library in Java
1.0<A NAME="Index1504"></A> was to allow the programmer to build a GUI that
looks good on all platforms.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index1505"></A><A NAME="Index1506"></A><A NAME="Index1507"></A><FONT FACE="Georgia">That
goal was not achieved. Instead, the Java 1.0<A NAME="Index1508"></A>
<A NAME="Index1509"></A><A NAME="Index1510"></A><A NAME="Index1511"></A><I>Abstract
Window Toolkit</I> (AWT) produces a GUI that looks equally mediocre on all
systems. In addition it&#8217;s restrictive: you can use only four fonts and you
cannot access any of the more sophisticated GUI elements that exist in your
operating system (OS). The Java 1.0 AWT programming model is also awkward and
non-object-oriented.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Much of this situation has been
improved with the Java 1.1<A NAME="Index1512"></A> AWT event model, which takes
a much clearer, object-oriented approach, along with the introduction of Java
Beans, a component programming model that is particularly oriented toward the
easy creation of visual programming environments. Java
1.2<A NAME="Index1513"></A> finishes the transformation away from the old Java
1.0 AWT by adding the <A NAME="Index1514"></A><A NAME="Index1515"></A><I>Java
Foundation Classes</I> (JFC), the GUI portion of which is called
&#8220;<A NAME="Index1516"></A>Swing.&#8221; These are a rich set of
easy-to-use, easy-to-understand Java Beans that can be dragged and dropped (as
well as hand programmed) to create a GUI that you can (finally) be satisfied
with. The &#8220;revision 3&#8221; rule of the software industry (a product
isn&#8217;t good until revision 3) seems to hold true with programming languages
as well.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of Java&#8217;s primary design
goals is to create <I>applets</I>, which are little programs that run inside a
Web browser. Because they must be safe, applets are limited in what they can
accomplish. However, they are a powerful tool in supporting client-side
programming, a major issue for the Web.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Programming within an applet is so
restrictive that it&#8217;s often referred to as being &#8220;inside the
sandbox,&#8221; since you always have someone &#8211; the Java run-time security
system &#8211; watching over you. Java 1.1<A NAME="Index1517"></A> offers
digital signing for applets so you can choose to allow trusted applets to have
access to your machine. However, you can also step outside the sandbox and write
regular applications, in which case you can access the other features of your
OS. We&#8217;ve been writing regular applications all along in this book, but
they&#8217;ve been <I>console applications</I> without any graphical components.
The AWT can also be used to build GUI interfaces for regular
applications.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this chapter you&#8217;ll first
learn the use of the original &#8220;old&#8221; AWT, which is still supported
and used by many of the code examples that you will come across. Although
it&#8217;s a bit painful to learn the old AWT, it&#8217;s necessary because you
must read and maintain legacy code that uses the old AWT. Sometimes you&#8217;ll
even need to write old AWT code to support environments that haven&#8217;t
upgraded past Java 1.0<A NAME="Index1518"></A>. In the second part of the
chapter you&#8217;ll learn about the structure of the &#8220;new&#8221; AWT in
Java 1.1<A NAME="Index1519"></A> and see how much better the event model is. (If
you can, you should use the newest tools when you&#8217;re creating new
programs.) Finally, you&#8217;ll learn about the new JFC/Swing components, which
can be added to Java 1.1 as a library &#8211; this means you can use the library
without requiring a full upgrade to Java 1.2<A NAME="Index1520"></A>.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most of the examples will show the
creation of applets, not only because it&#8217;s easier but also because
that&#8217;s where the AWT&#8217;s primary usefulness might reside. In addition
you&#8217;ll see how things are different when you want to create a regular
application using the AWT, and how to create programs that are both applets and
applications so they can be run either inside a browser or from the command
line.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Please be aware that this is not a
comprehensive glossary of all the methods for the described classes. This
chapter will just get you started with the essentials. When you&#8217;re looking
for more sophistication, make sure you go to your information browser to look
for the classes and methods that will solve your problem. (If you&#8217;re using
a development environment your information browser might be built in; if
you&#8217;re using the Sun JDK then you use your Web browser and start in the
java root directory.) Appendix F lists other resources for learning library
details.</FONT><A NAME="_Toc375545445"></A><A NAME="_Toc408018678"></A><BR></P></DIV>
<A NAME="Heading393"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Why use the AWT?</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the problems with the
&#8220;old&#8221; AWT that you&#8217;ll learn about in this chapter is that it
is a poor example of both object-oriented design and GUI development kit design.
It throws us back into the dark ages of programming (some suggest that the
&#8216;A&#8217; in AWT stands for &#8220;awkward,&#8221; &#8220;awful,&#8221;
&#8220;abominable,&#8221; etc.). You must write lines of code to do
<I>everything</I>, including tasks that are accomplished much more easily using
<A NAME="Index1521"></A><I>resources</I> in other environments.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Many of these problems are reduced
or eliminated in <A NAME="Index1522"></A>Java 1.1 because:
<A NAME="Index1523"></A><A NAME="Index1524"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	The new AWT in Java 1.1 is a much better
programming model and a significant step towards a better library. Java Beans is
the framework for that library.</FONT><LI><FONT FACE="Georgia">	&#8220;GUI
builders&#8221; (visual programming environments) will become <I>de rigeur</I>
for all development systems. Java Beans and the new AWT allow the GUI builder to
write code for you as you place components onto forms using graphical tools.
Other component technologies such as ActiveX will be supported in the same
fashion.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So why learn to
use the old AWT? &#8220;Because it&#8217;s there.&#8221; In this case,
&#8220;there&#8221; has a much more ominous meaning and points to a tenet of
object-oriented library design: <I>Once you publicize a component in your
library, you can never take it out</I>. If you do, you&#8217;ll wreck
somebody&#8217;s existing code. In addition, there are many existing code
examples out there that you&#8217;ll read as you learn about Java and they all
use the old AWT.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The AWT must reach into the GUI
components of the native OS, which means that it performs a task that an applet
cannot otherwise accomplish. An untrusted applet cannot make any direct calls
into an OS because otherwise it could do bad things to the user&#8217;s machine.
The only way an untrusted applet can access important functionality such as
&#8220;draw a window on the screen&#8221; is through calls in the standard Java
library that&#8217;s been specially ported and safety checked for that machine.
The original model that Sun created is that this &#8220;trusted library&#8221;
will be provided only by the trusted vendor of the Java system in your Web
browser, and the vendor will control what goes into that library.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But what if you want to extend the
system by adding a new component that accesses functionality in the OS? Waiting
for Sun to decide that your extension should be incorporated into the standard
Java library isn&#8217;t going to solve your problem. The new model in Java 1.1
is &#8220;trusted code&#8221; or &#8220;signed code&#8221; whereby a special
server verifies that a piece of code that you download is in fact
&#8220;signed&#8221; by the stated author using a public-key encryption system.
This way, you&#8217;ll know for sure where the code comes from, that it&#8217;s
Bob&#8217;s code and not just someone pretending to be Bob. This doesn&#8217;t
prevent Bob from making mistakes or doing something malicious, but it does
prevent Bob from shirking responsibility &#8211; anonymity is what makes
computer viruses possible. A digitally signed applet &#8211; a &#8220;trusted
applet&#8221; &#8211; in Java 1.1 <I>can</I> reach into your machine and
manipulate it directly, just like any other application you get from a
&#8220;trusted&#8221; vendor and install onto your computer.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But the point of all this is that
the old AWT is <I>there</I>. There will always be old AWT code floating around
and new Java programmers learning from old books will encounter that code. Also,
the old AWT is worth studying as an example of poor library design. The coverage
of the old AWT given here will be relatively painless since it won&#8217;t go
into depth and enumerate every single method and class, but instead give you an
overview of the old AWT design.
</FONT><A NAME="_Toc375545446"></A><A NAME="_Toc408018679"></A><BR></P></DIV>
<A NAME="Heading394"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The basic applet</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Libraries are often grouped
according to their functionality. Some libraries, for example, are used as is,
off the shelf. The standard Java library <B>String</B> and <B>Vector</B> classes
are examples of these. Other libraries are designed specifically as building
blocks to build other classes. A certain class of library is the
<A NAME="Index1525"></A><A NAME="Index1526"></A><I>application framework</I>,
whose goal is to help you build applications by providing a class or set of
classes that produces the basic behavior that you need in every application of a
particular type. Then, to customize the behavior to your own needs you inherit
from the application class and override the methods of interest. The application
framework&#8217;s default control mechanism will call your overridden methods at
the appropriate time. An application framework is a good example of
&#8220;separating the things that change from the things that stay the
same,&#8221; since it attempts to localize all the unique parts of a program in
the overridden methods.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index1527"></A><FONT FACE="Georgia">Applets are
built using an application framework. You inherit from class <B>Applet</B> and
override the appropriate methods. Most of the time you&#8217;ll be concerned
with only a few important methods that have to do with how the applet is built
and used on a Web page. These methods are:
<A NAME="Index1528"></A><A NAME="Index1529"></A><A NAME="Index1530"></A><A NAME="Index1531"></A><A NAME="Index1532"></A><A NAME="Index1533"></A><A NAME="Index1534"></A><A NAME="Index1535"></A><A NAME="Index1536"></A><A NAME="Index1537"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=58 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Method</FONT><BR></P></DIV>
</TH>
<TH WIDTH=279 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Operation</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>init(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Called when the applet is first
created to perform first-time initialization of the applet</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>start(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Called every time the applet moves
into sight on the Web browser to allow the applet to start up its normal
operations (especially those that are shut off by <B>stop(&#160;)</B>). Also
called after <B>init(&#160;)</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>paint(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Part of the base class
<B>Component</B> (three levels of inheritance up).<B> </B>Called as part of an
<B>update(&#160;)</B> to perform special painting on the canvas of an
applet.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>stop(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Called every time the applet moves
out of sight on the Web browser to allow the applet to shut off expensive
operations. Also called right before <B>destroy(&#160;)</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>destroy(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Called when the applet is being
unloaded from the page to perform final release of resources when the applet is
no longer used</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider the <B>paint(&#160;)</B>
method. This method is called automatically when the
<A NAME="Index1538"></A><A NAME="Index1539"></A><B>Component</B> (in this case,
the applet) decides that it needs to update itself &#8211; perhaps because
it&#8217;s being moved back onto the screen or placed on the screen for the
first time, or perhaps some other window had been temporarily placed over your
Web browser. The applet calls its
<A NAME="Index1540"></A><A NAME="Index1541"></A><B>update(&#160;)</B> method
(defined in the base class <B>Component</B>),<B> </B>which goes about restoring
everything, and as a part of that restoration calls <B>paint(&#160;)</B>. You
don&#8217;t have to override <B>paint(&#160;),</B> but it turns out to be an
easy way to make a simple applet, so we&#8217;ll start out with
<B>paint(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When <B>update(&#160;)</B> calls
<B>paint(&#160;)</B> it hands it a handle to a
<A NAME="Index1542"></A><A NAME="Index1543"></A><B>Graphics</B> object that
represents the surface on which you can paint. This is important because
you&#8217;re limited to the surface of that particular component and thus cannot
paint outside that area, which is a good thing or else you&#8217;d be painting
outside the lines. In the case of an applet, the surface is the area inside the
applet.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Graphics</B> object also has
a set of operations you can perform on it. These operations revolve around
painting on the canvas, so most of them have to do with drawing images, shapes,
arcs, etc. (Note that you can look all this up in your online Java documentation
if you&#8217;re curious.) There are some methods that allow you to draw
characters, however, and the most commonly used one is
<A NAME="Index1544"></A><A NAME="Index1545"></A><B>drawString(&#160;)</B>. For
this, you must specify the <B>String</B> you want to draw and its starting
location on the applet&#8217;s drawing surface. This location is given in
pixels, so it will look different on different machines, but at least it&#8217;s
portable.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With this information you can
create a simple applet:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Applet1.java</font>
<font color=#009900>// Very simple applet</font>
<font color=#0000ff>package</font> c13;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Applet1 <font color=#0000ff>extends</font> Applet {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics g) {
    g.drawString(<font color=#004488>"First applet"</font>, 10, 10);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that applets are not required
to have a <B>main(&#160;)</B>. That&#8217;s all wired in to the application
framework; you put any startup code in <B>init(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To run this program you must place
it inside a Web page and view that page inside your Java-enabled Web browser. To
place an <A NAME="Index1546"></A><A NAME="Index1547"></A>applet inside a Web
page you put a special tag inside the HTML source for that Web
page</FONT><A NAME="fnB51" HREF="#fn51">[51]</A><FONT FACE="Georgia"> to
tell the page how to load and run the applet. This is the <B>applet</B>
<A NAME="Index1548"></A><A NAME="Index1549"></A>tag, and it looks like this for
Applet1:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;applet
code=Applet1
width=200
height=200&gt;
&lt;/applet&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>code </B>value gives the
name of the <B>.class </B>file where the applet resides. The <B>width</B> and
<B>height</B> specify the initial size of the applet (in pixels, as before).
There are other items you can place within the applet tag: a place to find other
<B>.class </B>files on the Internet
(<A NAME="Index1550"></A><A NAME="Index1551"></A><B>codebase</B>), alignment
information (<A NAME="Index1552"></A><A NAME="Index1553"></A><B>align</B>), a
special identifier that makes it possible for applets to communicate with each
other
(<A NAME="Index1554"></A><A NAME="Index1555"></A><B>name</B>),</FONT><TT><FONT FACE="Courier New">
</FONT></TT><FONT FACE="Georgia">and applet
<A NAME="Index1556"></A><A NAME="Index1557"></A>parameters to provide
information that the applet can retrieve. Parameters are in the
form</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;param name=identifier value = <font color=#004488>"information"</font>&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">and there can be as many as you
want.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For simple applets all you need to
do is place an applet tag in the above form inside your Web page and that will
load and run the applet.</FONT><A NAME="_Toc408018680"></A><BR></P></DIV>
<A NAME="Heading395"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Testing applets</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can perform a simple test
without any network connection by starting up your Web browser and opening the
HTML file containing the applet tag. (Sun&#8217;s JDK also contains a tool
called the <A NAME="Index1558"></A><I>appletviewer</I> that picks the
&lt;APPLET&gt; tags out of the HTML file and runs the applets without displaying
the surrounding HTML
text.</FONT><A NAME="fnB52" HREF="#fn52">[52]</A><FONT FACE="Georgia">) As
the HTML file is loaded, the browser will discover the applet tag and go hunt
for the <B>.class</B> file specified by the <B>code</B> value. Of course, it
looks at the CLASSPATH to find out where to hunt, and if your <B>.class</B> file
isn&#8217;t in the CLASSPATH then it will give an error message on the status
line of the browser to the effect that it couldn&#8217;t find that <B>.class</B>
file.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you want to try this out on
your Web site things are a little more complicated. First of all, you must
<I>have</I> a Web site, which for most people means a third-party
<A NAME="Index1559"></A><A NAME="Index1560"></A>Internet Service Provider (ISP)
at a remote location. Then you must have a way to move the HTML files and the
<B>.class</B> files from your site to the correct directory (your WWW directory)
on the ISP machine. This is typically done with a
<A NAME="Index1561"></A><A NAME="Index1562"></A>File Transfer Protocol (FTP)
program, of which there are many different types freely available. So it would
seem that all you need to do is move the files to the ISP machine with FTP, then
connect to the site and HTML file using your browser; if the applet comes up and
works, then everything checks out, right?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s where you can get
fooled. If the browser cannot locate the <B>.class</B> file on the server, it
will hunt through the <A NAME="Index1563"></A><A NAME="Index1564"></A>CLASSPATH
on your <I>local</I> machine. Thus, the applet might not be loading properly
from the server, but to you it looks fine because the browser finds it on your
machine. When someone else logs in, however, his or her browser can&#8217;t find
it. So when you&#8217;re testing, make sure you erase the relevant <B>.class</B>
files on your machine to be safe.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the most insidious places
where this happened to me is when I innocently placed an applet inside a
<B>package</B>. After uploading the HTML file and applet, it turned out that the
server path to the applet was confused because of the package name. However, my
browser found it in the local CLASSPATH. So I was the only one who could
properly load the applet. It took some time to discover that the <B>package</B>
statement was the culprit. In general, you&#8217;ll want to leave the
<A NAME="Index1565"></A><A NAME="Index1566"></A><B>package</B> statement out of
an applet.</FONT><A NAME="_Toc408018681"></A><BR></P></DIV>
<A NAME="Heading396"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A more graphical example</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The example above isn&#8217;t too
thrilling, so let&#8217;s try adding a slightly more interesting graphic
component:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Applet2.java</font>
<font color=#009900>// Easy graphics</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Applet2 <font color=#0000ff>extends</font> Applet {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics g) {
    g.drawString(<font color=#004488>"Second applet"</font>, 10, 15);
    g.draw3DRect(0, 0, 100, 20, <font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This puts a box around the string.
Of course, all the numbers are hard-coded and are based on pixels, so on some
machines the box will fit nicely around the string and on others it will
probably be off, because fonts will be different on different
machines.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are other interesting things
you can find in the documentation for the <B>Graphic </B>class. Any sort of
graphics activity is usually entertaining, so further experiments of this sort
are left to the reader.</FONT><A NAME="_Toc408018682"></A><BR></P></DIV>
<A NAME="Heading397"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Demonstrating <BR>the framework methods</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s interesting to see some
of the framework methods in action. (This example will look only at
<A NAME="Index1567"></A><A NAME="Index1568"></A><B>init(&#160;)</B>,
<A NAME="Index1569"></A><A NAME="Index1570"></A><B>start(&#160;),</B> and
<A NAME="Index1571"></A><A NAME="Index1572"></A><B>stop(&#160;) </B>because
<B>paint(&#160;)</B> and <B>destroy(&#160;) </B>are self-evident and not so
easily traceable.) The following applet keeps track of the number of times these
methods are called and displays them using
<B>paint(&#160;)</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Applet3.java</font>
<font color=#009900>// Shows init(), start() and stop() activities</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Applet3 <font color=#0000ff>extends</font> Applet {
  String s;
  <font color=#0000ff>int</font> inits = 0;
  <font color=#0000ff>int</font> starts = 0;
  <font color=#0000ff>int</font> stops = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() { inits++; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> start() { starts++; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> stop() { stops++; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics g) {
    s = <font color=#004488>"inits: "</font> + inits + 
      <font color=#004488>", starts: "</font> + starts +
      <font color=#004488>", stops: "</font> + stops;
    g.drawString(s, 10, 10);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Normally when you override a method
you&#8217;ll want to look to see whether you need to call the base-class version
of that method, in case it does something important. For example, with
<B>init(&#160;)</B> you might need to call <B>super.init(&#160;)</B>. However,
the <B>Applet</B> documentation specifically states that the
<B>init(&#160;)</B>, <B>start(&#160;)</B>, and <B>stop(&#160;)</B> methods in
<B>Applet</B> do nothing, so it&#8217;s not necessary to call them
here.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you experiment with this
applet you&#8217;ll discover that if you minimize the Web browser or cover it up
with another window you might not get calls to <B>stop(&#160;)</B> and
<B>start(&#160;)</B>.<B> </B>(This behavior seems to vary among implementations;
you might wish to contrast the behavior of Web browsers with that of applet
viewers.) The only time the calls will occur is when you move to a different Web
page and then come back to the one containing the
applet.</FONT><A NAME="_Toc375545447"></A><A NAME="_Toc408018683"></A><BR></P></DIV>
<A NAME="Heading398"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Making a button</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Making a button is quite simple:
you just call the <A NAME="Index1573"></A><A NAME="Index1574"></A><B>Button</B>
constructor with the label you want on the button. (You can also use the default
constructor if you want a button with no label, but this is not very useful.)
Usually you&#8217;ll want to create a handle for the button so you can refer to
it later.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Button</B> is a component,
like its own little window, that will automatically get repainted as part of an
update. This means that you don&#8217;t explicitly paint a button or any other
kind of control; you simply place them on the form and let them automatically
take care of painting themselves. So to place a button on a form you override
<B>init(&#160;) </B>instead of overriding <B>paint(&#160;)</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Button1.java</font>
<font color=#009900>// Putting buttons on an applet</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Button1 <font color=#0000ff>extends</font> Applet {
  Button 
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 1"</font>), 
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    add(b1);
    add(b2);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s not enough to create the
<B>Button</B> (or any other control). You must also call the <B>Applet</B>
<B>add(&#160;)</B> method to cause the button to be placed on the applet&#8217;s
form. This seems a lot simpler than it is, because the call to
<B>add(&#160;)</B> actually decides, implicitly, where to place the control on
the form. Controlling the layout of a form is examined
shortly.</FONT><A NAME="_Toc375545448"></A><A NAME="_Toc408018684"></A><BR></P></DIV>
<A NAME="Heading399"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Capturing an event</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that if you
compile and run the applet above, nothing happens when you press the buttons.
This is where you must step in and write some code to determine what will
happen. The basis of
<A NAME="Index1575"></A><A NAME="Index1576"></A><A NAME="Index1577"></A>event-driven
programming, which comprises a lot of what a GUI is about, is tying events to
code that responds to those events.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After working your way this far
through the book and grasping some of the fundamentals of object-oriented
programming, you might think that of course there will be some sort of
object-oriented approach to handling events. For example, you might have to
inherit each button and override some &#8220;button pressed&#8221; method (this,
it turns out, is too tedious and restrictive). You might also think
there&#8217;s some master &#8220;event&#8221; class that contains a method for
each event you want to respond to.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before objects, the typical
approach to handling events was the &#8220;giant switch statement.&#8221; Each
event would have a unique integer value and inside the master event handling
method you&#8217;d write a <B>switch</B> on that value.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The AWT in Java
1.0<A NAME="Index1578"></A> doesn&#8217;t use any object-oriented approach.
Neither does it use a giant <B>switch</B> statement that relies on the
assignment of numbers to events. Instead, you must create a cascaded set of
<B>if</B> statements. What you&#8217;re trying to do with the <B>if</B>
statements is detect the object that was the
<A NAME="Index1579"></A><A NAME="Index1580"></A><I>target</I> of the event. That
is, if you click on a button, then that particular button is the target.
Normally, that&#8217;s all you care about &#8211; if a button is the target of
an event, then it was most certainly a mouse click and you can continue based on
that assumption. However, events can contain other information as well. For
example, if you want to find out the pixel location where a mouse click occurred
so you can draw a line to that location, the <B>Event</B> object will contain
the location. (You should also be aware that Java 1.0 components can be limited
in the kinds of events they generate, while Java 1.1 and Swing/JFC components
produce a full set of events.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java
1.0<A NAME="Index1581"></A> AWT method where your cascaded <B>if</B> statement
resides is called
<A NAME="Index1582"></A><A NAME="Index1583"></A><B>action(&#160;)</B>. Although
the whole Java 1.0<A NAME="Index1584"></A> Event model has been deprecated in
Java 1.1<A NAME="Index1585"></A>, it is still widely used for simple applets and
in systems that do not yet support Java 1.1, so I recommend you become
comfortable with it, including the use of the following <B>action()</B> method
approach.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>action(&#160;)</B> has two
arguments: the first is of type
<A NAME="Index1586"></A><A NAME="Index1587"></A><B>Event</B> and contains all
the information about the event that triggered this call to
<B>action(&#160;)</B>. For example, it could be a mouse click, a normal keyboard
press or release, a special key press or release, the fact that the component
got or lost the focus, mouse movements, or drags, etc. The second argument is
usually the target of the event, which you&#8217;ll often ignore. The second
argument is also encapsulated in the <B>Event</B> object so it is redundant as
an argument.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The situations in which
<B>action(&#160;) </B>gets called are extremely limited: When you place controls
on a form, some types of controls (buttons, check boxes, drop-down lists, menus)
have a &#8220;standard action&#8221; that occurs, which causes the call to
<B>action(&#160;)</B> with the appropriate <B>Event</B> object. For example,
with a button the <B>action(&#160;)</B> method is called when the button is
pressed and at no other time. Usually this is just fine, since that&#8217;s what
you ordinarily look for with a button. However, it&#8217;s possible to deal with
many other types of events via the
<A NAME="Index1588"></A><A NAME="Index1589"></A><B>handleEvent(&#160;)</B>
method as we will see later in this chapter.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The previous example can be
extended to handle button clicks as follows:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Button2.java</font>
<font color=#009900>// Capturing button presses</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Button2 <font color=#0000ff>extends</font> Applet {
  Button 
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 1"</font>), 
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    add(b1);
    add(b2);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action(Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(b1))
      getAppletContext().showStatus(<font color=#004488>"Button 1"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(b2))
      getAppletContext().showStatus(<font color=#004488>"Button 2"</font>);
    <font color=#009900>// Let the base class handle it:</font>
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>; <font color=#009900>// We've handled it here</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To see what the
<A NAME="Index1590"></A><A NAME="Index1591"></A>target is, ask the <B>Event</B>
object what its <B>target</B> member is and then use the
<A NAME="Index1592"></A><B>equals(&#160;)</B> method to see if it matches the
target object handle you&#8217;re interested in. When you&#8217;ve written
handlers for all the objects you&#8217;re interested in you must call
<A NAME="Index1593"></A><A NAME="Index1594"></A><B>super.action(evt, arg)</B> in
the <B>else</B> statement at the end, as shown above. Remember from Chapter 7
(polymorphism) that your overridden method is called instead of the base class
version. However, the base-class version contains code to handle all of the
cases that you&#8217;re not interested in, and it won&#8217;t get called unless
you call it explicitly. The return value indicates whether you&#8217;ve handled
it or not, so if you do match an event you should return <B>true</B>, otherwise
return whatever the base-class <B>event(&#160;)</B> returns.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For this example, the simplest
action is to print what button is pressed. Some systems allow you to pop up a
little window with a message in it, but applets discourage this. However, you
can put a message at the bottom of the
<A NAME="Index1595"></A><A NAME="Index1596"></A><A NAME="Index1597"></A><A NAME="Index1598"></A>Web
browser window on its <I>status line</I> by calling the <B>Applet</B> method
<A NAME="Index1599"></A><A NAME="Index1600"></A><B>getAppletContext(&#160;)</B>
to get access to the browser and then
<A NAME="Index1601"></A><A NAME="Index1602"></A><B>showStatus(&#160;)</B> to put
a string on the status
line.</FONT><A NAME="fnB53" HREF="#fn53">[53]</A><FONT FACE="Georgia"> You
can print out a complete description of an event the same way, with
<B>getAppletContext().showStatus(evt + "" ). </B>(The empty <B>String</B> forces
the compiler to convert <B>evt</B> to a <B>String.</B>) Both of these reports
are really useful only for testing and debugging since the browser might
overwrite your message.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Strange as it might seem, you can
also <A NAME="Index1603"></A><A NAME="Index1604"></A>match an event to the
<I>text</I> that&#8217;s on a button through the second argument in
<B>event(&#160;)</B>. Using this technique, the example above
becomes:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Button3.java</font>
<font color=#009900>// Matching events on button text</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Button3 <font color=#0000ff>extends</font> Applet {
  Button 
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 1"</font>), 
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    add(b1);
    add(b2);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(arg.equals(<font color=#004488>"Button 1"</font>))
      getAppletContext().showStatus(<font color=#004488>"Button 1"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(arg.equals(<font color=#004488>"Button 2"</font>))
      getAppletContext().showStatus(<font color=#004488>"Button 2"</font>);
    <font color=#009900>// Let the base class handle it:</font>
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>; <font color=#009900>// We've handled it here</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s difficult to know
exactly what the <B>equals(&#160;)</B> method is doing here. The biggest problem
with this approach is that most new Java programmers who start with this
technique spend at least one frustrating session discovering that they&#8217;ve
gotten the capitalization or spelling wrong when comparing to the text on a
button. (I had this experience.) Also, if you change the text of the button, the
code will no longer work (but you won&#8217;t get any compile-time or run-time
error messages). You should avoid this approach if
possible.</FONT><A NAME="_Toc375545449"></A><A NAME="_Toc408018685"></A><BR></P></DIV>
<A NAME="Heading400"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Text fields</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index1605"></A><A NAME="Index1606"></A><B>TextField</B> is a one line
area that allows the user to enter and edit text. <B>TextField </B>is inherited
from <A NAME="Index1607"></A><A NAME="Index1608"></A><B>TextComponent</B>,<B>
</B>which lets you select text, get the selected text as a <B>String</B>, get or
set the text, and set whether the <B>TextField</B> is editable, along with other
associated methods that you can find in your online reference. The following
example demonstrates some of the functionality of a <B>TextField</B>; you can
see that the method names are fairly obvious:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: TextField1.java</font>
<font color=#009900>// Using the text field control</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TextField1 <font color=#0000ff>extends</font> Applet {
  Button
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Get Text"</font>),
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Set Text"</font>);
  TextField 
    t = <font color=#0000ff>new</font> TextField(<font color=#004488>"Starting text"</font>, 30);
  String s = <font color=#0000ff>new</font> String();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    add(b1);
    add(b2);
    add(t);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(b1)) {
      getAppletContext().showStatus(t.getText());
      s = t.getSelectedText();
      <font color=#0000ff>if</font>(s.length() == 0) s = t.getText();
      t.setEditable(<font color=#0000ff>true</font>);
    }
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(b2)) {
      t.setText(<font color=#004488>"Inserted by Button 2: "</font> + s);
      t.setEditable(<font color=#0000ff>false</font>);
    }
    <font color=#009900>// Let the base class handle it:</font>
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>; <font color=#009900>// We've handled it here</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are several ways to construct
a <B>TextField</B>; the one shown here provides an initial string and sets the
size of the field in characters.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Pressing button 1 either gets the
text you&#8217;ve selected with the mouse or it gets all the text in the field
and places the result in <B>String s</B>. It also allows the field to be edited.
Pressing button 2 puts a message and <B>s</B> into the text field and prevents
the field from being edited (although you can still select the text). The
editability of the text is controlled by passing
<A NAME="Index1609"></A><A NAME="Index1610"></A><B>setEditable(&#160;)</B> a
<B>true</B> or
<B>false</B>.</FONT><A NAME="_Toc375545450"></A><A NAME="_Toc408018686"></A><BR></P></DIV>
<A NAME="Heading401"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Text areas</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index1611"></A><A NAME="Index1612"></A><B>TextArea</B> is like a
<B>TextField</B> except that it can have multiple lines and has significantly
more functionality. In addition to what you can do with a <B>TextField</B>, you
can append text and insert or replace text at a given location. It seems like
this functionality could be useful for <B>TextField</B> as well, so it&#8217;s a
little confusing to try to detect how the distinction is made. You might think
that if you want <B>TextArea</B> functionality everywhere you can simply use a
one line <B>TextArea</B> in places where you would otherwise use a
<B>TextField</B>. In Java 1.0<A NAME="Index1613"></A>, you also got scroll bars
with a <B>TextArea </B>even when they weren&#8217;t appropriate; that is, you
got both vertical and horizontal scroll bars for a one line <B>TextArea</B>. In
Java 1.1<A NAME="Index1614"></A> this was remedied with an extra constructor
that allows you to select which scroll bars (if any) are present. The following
example shows only the Java 1.0<A NAME="Index1615"></A> behavior, in which the
scrollbars are always on. Later in the chapter you&#8217;ll see an example that
demonstrates Java 1.1 <B>TextArea</B>s.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: TextArea1.java</font>
<font color=#009900>// Using the text area control</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TextArea1 <font color=#0000ff>extends</font> Applet {
  Button b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Text Area 1"</font>);
  Button b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Text Area 2"</font>);
  Button b3 = <font color=#0000ff>new</font> Button(<font color=#004488>"Replace Text"</font>);
  Button b4 = <font color=#0000ff>new</font> Button(<font color=#004488>"Insert Text"</font>);
  TextArea t1 = <font color=#0000ff>new</font> TextArea(<font color=#004488>"t1"</font>, 1, 30);
  TextArea t2 = <font color=#0000ff>new</font> TextArea(<font color=#004488>"t2"</font>, 4, 30);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    add(b1);
    add(t1);
    add(b2);
    add(t2);
    add(b3);
    add(b4);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(b1))
      getAppletContext().showStatus(t1.getText());
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(b2)) {
      t2.setText(<font color=#004488>"Inserted by Button 2"</font>);
      t2.appendText(<font color=#004488>": "</font> + t1.getText());
      getAppletContext().showStatus(t2.getText());
    }
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(b3)) {
      String s = <font color=#004488>" Replacement "</font>;
      t2.replaceText(s, 3, 3 + s.length());
    }
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(b4))
      t2.insertText(<font color=#004488>" Inserted "</font>, 10);
    <font color=#009900>// Let the base class handle it:</font>
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>; <font color=#009900>// We've handled it here</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are several different
<B>TextArea</B> constructors, but the one shown here gives a starting string and
the number of rows and columns. The different buttons show getting, appending,
replacing, and inserting
text.</FONT><A NAME="_Toc375545451"></A><A NAME="_Toc408018687"></A><BR></P></DIV>
<A NAME="Heading402"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Labels</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index1616"></A><A NAME="Index1617"></A><B>Label</B> does exactly what
it sounds like it should: places a label on the form. This is particularly
important for text fields and text areas that don&#8217;t have labels of their
own, and can also be useful if you simply want to place textual information on a
form. You can, as shown in the first example in this chapter, use
<B>drawString(&#160;)</B> inside <B>paint(&#160;)</B> to place text in an exact
location. When you use a <B>Label</B> it allows you to (approximately) associate
the text with some other component via the layout manager (which will be
discussed later in this chapter).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With the constructor you can create
a blank label, a label with initial text in it (which is what you&#8217;ll
typically do), and a label with an alignment of <B>CENTER</B>, <B>LEFT</B>, or
<B>RIGHT</B> (<B>static final int</B>s defined in class <B>Label</B>). You can
also change the label and its alignment with
<A NAME="Index1618"></A><A NAME="Index1619"></A><B>setText(&#160;)</B> and
<A NAME="Index1620"></A><A NAME="Index1621"></A><B>setAlignment(&#160;)</B>, and
if you&#8217;ve forgotten what you&#8217;ve set these to you can read the values
with <A NAME="Index1622"></A><A NAME="Index1623"></A><B>getText(&#160;)</B> and
<A NAME="Index1624"></A><A NAME="Index1625"></A><B>getAlignment(&#160;)</B>.
This example shows what you can do with labels:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Label1.java</font>
<font color=#009900>// Using labels</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Label1 <font color=#0000ff>extends</font> Applet {
  TextField t1 = <font color=#0000ff>new</font> TextField(<font color=#004488>"t1"</font>, 10);
  Label labl1 = <font color=#0000ff>new</font> Label(<font color=#004488>"TextField t1"</font>);
  Label labl2 = <font color=#0000ff>new</font> Label(<font color=#004488>"                   "</font>);
  Label labl3 = <font color=#0000ff>new</font> Label(<font color=#004488>"                    "</font>,
    Label.RIGHT);
  Button b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Test 1"</font>);
  Button b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Test 2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    add(labl1); add(t1);
    add(b1); add(labl2);
    add(b2); add(labl3);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(b1))
      labl2.setText(<font color=#004488>"Text set into Label"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(b2)) {
      <font color=#0000ff>if</font>(labl3.getText().trim().length() == 0)
        labl3.setText(<font color=#004488>"labl3"</font>);
      <font color=#0000ff>if</font>(labl3.getAlignment() == Label.LEFT)
        labl3.setAlignment(Label.CENTER);
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(labl3.getAlignment()==Label.CENTER)
        labl3.setAlignment(Label.RIGHT);
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(labl3.getAlignment() == Label.RIGHT)
        labl3.setAlignment(Label.LEFT);
    }
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first use of the label is the
most typical: labeling a <B>TextField</B> or <B>TextArea</B>. In the second part
of the example, a bunch of empty spaces are reserved and when you press the
&#8220;Test 1&#8221; button <B>setText(&#160;)</B> is used to insert text into
the field. Because a number of blank spaces do not equal the same number of
characters (in a
<A NAME="Index1626"></A><A NAME="Index1627"></A><A NAME="Index1628"></A>proportionally-spaced
font) you&#8217;ll see that the text gets truncated when inserted into the
label.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The third part of the example
reserves empty space, then the first time you press the &#8220;Test 2&#8221;
button it sees that there are no characters in the label (since
<A NAME="Index1629"></A><B>trim(&#160;)</B> removes all of the blank spaces at
each end of a <B>String</B>) and inserts a short label, which is initially
left-aligned. The rest of the times you press the button it changes the
alignment so you can see the effect.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might think that you could
create an empty label and then later put text in it with <B>setText(&#160;)</B>.
However, you cannot put text into an empty label &#8211; presumably because it
has zero width &#8211; so creating a label with no text seems to be a useless
thing to do. In the example above, the &#8220;blank&#8221; label is filled with
empty spaces so it has enough width to hold text that&#8217;s placed inside
later.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Similarly, <B>setAlignment(&#160;)
</B>has no effect on a label that you&#8217;d typically create with text in the
constructor. The label width is the width of the text, so changing the alignment
doesn&#8217;t do anything. However, if you start with a long label and then
change it to a shorter one you can see the effect of the
alignment.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These behaviors occur because of
the default <A NAME="Index1630"></A><A NAME="Index1631"></A><I>layout
manager</I> that&#8217;s used for applets, which causes things to be squished
together to their smallest size. Layout managers will be covered later in this
chapter, when you&#8217;ll see that other layouts don&#8217;t have the same
effect.</FONT><A NAME="_Toc375545452"></A><A NAME="_Toc408018688"></A><BR></P></DIV>
<A NAME="Heading403"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Check boxes</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A check box provides a way to make
a single on-off choice; it consists of a tiny box and a label. The box typically
holds a little &#8216;x&#8217; (or some other indication that it is set) or is
empty depending on whether that item was selected.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll normally create a
<A NAME="Index1632"></A><A NAME="Index1633"></A><B>Checkbox</B> using a
constructor that takes the label as an argument. You can get and set the state,
and also get and set the label if you want to read or change it after the
<B>Checkbox</B> has been created. Note that the capitalization of
<B>Checkbox</B> is inconsistent with the other controls, which could catch you
by surprise since you might expect it to be
&#8220;CheckBox.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Whenever a <B>Checkbox</B> is set
or cleared an event occurs, which you can capture the same way you do a button.
The following example uses a <B>TextArea</B> to enumerate all the check boxes
that have been checked:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CheckBox1.java</font>
<font color=#009900>// Using check boxes</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CheckBox1 <font color=#0000ff>extends</font> Applet {
  TextArea t = <font color=#0000ff>new</font> TextArea(6, 20);
  Checkbox cb1 = <font color=#0000ff>new</font> Checkbox(<font color=#004488>"Check Box 1"</font>);
  Checkbox cb2 = <font color=#0000ff>new</font> Checkbox(<font color=#004488>"Check Box 2"</font>);
  Checkbox cb3 = <font color=#0000ff>new</font> Checkbox(<font color=#004488>"Check Box 3"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    add(t); add(cb1); add(cb2); add(cb3);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(cb1))
      trace(<font color=#004488>"1"</font>, cb1.getState());
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(cb2))
      trace(<font color=#004488>"2"</font>, cb2.getState());
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(cb3))
      trace(<font color=#004488>"3"</font>, cb3.getState());
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>void</font> trace(String b, <font color=#0000ff>boolean</font> state) {
    <font color=#0000ff>if</font>(state)
      t.appendText(<font color=#004488>"Box "</font> + b + <font color=#004488>" Set\n"</font>);
    <font color=#0000ff>else</font>
      t.appendText(<font color=#004488>"Box "</font> + b + <font color=#004488>" Cleared\n"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>trace(&#160;)</B> method
sends the name of the selected <B>Checkbox</B> and its current state to the
<B>TextArea</B> using
<A NAME="Index1634"></A><A NAME="Index1635"></A><B>appendText(&#160;)</B> so
you&#8217;ll see a cumulative list of the checkboxes that were selected and what
their state
is.</FONT><A NAME="_Toc375545453"></A><A NAME="_Toc408018689"></A><BR></P></DIV>
<A NAME="Heading404"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Radio buttons</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The concept of a
<A NAME="Index1636"></A><A NAME="Index1637"></A><A NAME="Index1638"></A>radio
button in GUI programming comes from pre-electronic car radios with mechanical
buttons: when you push one in, any other button that was pressed pops out. Thus
it allows you to force a single choice among many.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The AWT does not have a separate
class to represent the radio button; instead it reuses the
<A NAME="Index1639"></A><A NAME="Index1640"></A><B>Checkbox</B>. However, to put
the <B>Checkbox</B> in a radio button group (and to change its shape so
it&#8217;s visually different from an ordinary <B>Checkbox</B>) you must use a
special constructor that takes a
<A NAME="Index1641"></A><A NAME="Index1642"></A><B>CheckboxGroup</B> object as
an argument. (You can also call
<A NAME="Index1643"></A><A NAME="Index1644"></A><B>setCheckboxGroup(&#160;)</B>
after the <B>Checkbox</B> has been created.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>CheckboxGroup </B>has no
constructor argument; its sole reason for existence is to collect some
<B>Checkbox</B>es into a group of radio buttons. One of the <B>Checkbox</B>
objects must have its state set to <B>true</B> before you try to display the
group of radio buttons; otherwise you&#8217;ll get an exception at run time. If
you try to set more than one radio button to <B>true</B> then only the final one
set will be <B>true</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a simple example of
the use of radio buttons. Note that you capture radio button events like all
others:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: RadioButton1.java</font>
<font color=#009900>// Using radio buttons</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> RadioButton1 <font color=#0000ff>extends</font> Applet {
  TextField t = 
    <font color=#0000ff>new</font> TextField(<font color=#004488>"Radio button 2"</font>, 30);
  CheckboxGroup g = <font color=#0000ff>new</font> CheckboxGroup();
  Checkbox 
    cb1 = <font color=#0000ff>new</font> Checkbox(<font color=#004488>"one"</font>, g, <font color=#0000ff>false</font>),
    cb2 = <font color=#0000ff>new</font> Checkbox(<font color=#004488>"two"</font>, g, <font color=#0000ff>true</font>),
    cb3 = <font color=#0000ff>new</font> Checkbox(<font color=#004488>"three"</font>, g, <font color=#0000ff>false</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    t.setEditable(<font color=#0000ff>false</font>);
    add(t); 
    add(cb1); add(cb2); add(cb3); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(cb1))
      t.setText(<font color=#004488>"Radio button 1"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(cb2))
      t.setText(<font color=#004488>"Radio button 2"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(cb3))
      t.setText(<font color=#004488>"Radio button 3"</font>);
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To display the state, an text field
is used. This field is set to non-editable because it&#8217;s used only to
display data, not to collect it. This is shown as an alternative to using a
<B>Label</B>. Notice the text in the field is initialized to &#8220;Radio button
2&#8221; since that&#8217;s the initial selected radio button.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can have any number of
<B>CheckboxGroup</B>s on a
form.</FONT><A NAME="_Toc375545454"></A><A NAME="_Toc408018690"></A><BR></P></DIV>
<A NAME="Heading405"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Drop-down lists</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like a group of radio buttons, a
<A NAME="Index1645"></A><A NAME="Index1646"></A><A NAME="Index1647"></A>drop-down
list is a way to force the user to select only one element from a group of
possibilities. However, it&#8217;s a much more compact way to accomplish this,
and it&#8217;s easier to change the elements of the list without surprising the
user. (You can change radio buttons dynamically, but that tends to be visibly
jarring).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java&#8217;s
<A NAME="Index1648"></A><A NAME="Index1649"></A><B>Choice</B> box is not like
the combo box in Windows, which lets you select from a list <I>or</I> type in
your own selection. With a <B>Choice</B> box you choose one and only one element
from the list. In the following example, the <B>Choice</B> box starts with a
certain number of entries and then new entries are added to the box when a
button is pressed. This allows you to see some interesting behaviors in
<B>Choice</B> boxes:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Choice1.java</font>
<font color=#009900>// Using drop-down lists</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Choice1 <font color=#0000ff>extends</font> Applet {
  String[] description = { <font color=#004488>"Ebullient"</font>, <font color=#004488>"Obtuse"</font>,
    <font color=#004488>"Recalcitrant"</font>, <font color=#004488>"Brilliant"</font>, <font color=#004488>"Somnescent"</font>,
    <font color=#004488>"Timorous"</font>, <font color=#004488>"Florid"</font>, <font color=#004488>"Putrescent"</font> };
  TextField t = <font color=#0000ff>new</font> TextField(30);
  Choice c = <font color=#0000ff>new</font> Choice();
  Button b = <font color=#0000ff>new</font> Button(<font color=#004488>"Add items"</font>);
  <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    t.setEditable(<font color=#0000ff>false</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 4; i++)
      c.addItem(description[count++]);
    add(t);
    add(c);
    add(b);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(c))
      t.setText(<font color=#004488>"index: "</font> +  c.getSelectedIndex()
        + <font color=#004488>"   "</font> + (String)arg);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(b)) {
      <font color=#0000ff>if</font>(count &lt; description.length)
        c.addItem(description[count++]);
    } 
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>TextField</B> displays the
&#8220;selected index,&#8221; which is the sequence number of the currently
selected element, as well as the <B>String</B> representation of the second
argument of <B>action(&#160;)</B>, which is in this case the string that was
selected.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this applet, pay
attention to the determination of the size of the <B>Choice</B> box: in Windows,
the size is fixed from the first time you drop down the list. This means that if
you drop down the list, then add more elements to the list, the elements will be
there but the drop-down list won&#8217;t get any
longer</FONT><A NAME="fnB54" HREF="#fn54">[54]</A><FONT FACE="Georgia">
(you can scroll through the elements). However, if you add all the elements
before the first time the list is dropped down, then it will be sized correctly.
Of course, the user will expect to see the whole list when it&#8217;s dropped
down, so this behavior puts some significant limitations on adding elements to
<B>Choice</B>
boxes.</FONT><A NAME="_Toc375545455"></A><A NAME="_Toc408018691"></A><BR></P></DIV>
<A NAME="Heading406"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
List boxes<BR><A NAME="Index1650"></A><A NAME="Index1651"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">List boxes are significantly
different from <B>Choice</B> boxes, and not just in appearance. While a
<B>Choice</B> box drops down when you activate it, a
<A NAME="Index1652"></A><A NAME="Index1653"></A><B>List</B> occupies some fixed
number of lines on a screen all the time and doesn&#8217;t change. In addition,
a <B>List</B> allows multiple selection: if you click on more than one item the
original item stays highlighted and you can select as many as you want. If you
want to see the items in a list, you simply call
<A NAME="Index1654"></A><A NAME="Index1655"></A><B>getSelectedItems(&#160;),
</B>which produces an array of <B>String</B> of the items that have been
selected. To remove an item from a group you have to click it
again.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A problem with a <B>List</B> is
that the default action is double clicking, not single clicking. A single click
adds or removes elements from the selected group and a double click calls
<B>action(&#160;)</B>. One way around this is to re-educate your user, which is
the assumption made in the following program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: List1.java</font>
<font color=#009900>// Using lists with action()</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> List1 <font color=#0000ff>extends</font> Applet {
  String[] flavors = { <font color=#004488>"Chocolate"</font>, <font color=#004488>"Strawberry"</font>,
    <font color=#004488>"Vanilla Fudge Swirl"</font>, <font color=#004488>"Mint Chip"</font>, 
    <font color=#004488>"Mocha Almond Fudge"</font>, <font color=#004488>"Rum Raisin"</font>, 
    <font color=#004488>"Praline Cream"</font>, <font color=#004488>"Mud Pie"</font> };
  <font color=#009900>// Show 6 items, allow multiple selection:</font>
  List lst = <font color=#0000ff>new</font> List(6, <font color=#0000ff>true</font>);
  TextArea t = <font color=#0000ff>new</font> TextArea(flavors.length, 30);
  Button b = <font color=#0000ff>new</font> Button(<font color=#004488>"test"</font>);
  <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    t.setEditable(<font color=#0000ff>false</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 4; i++)
      lst.addItem(flavors[count++]);
    add(t);
    add(lst);
    add(b);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action (Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(lst)) {
      t.setText(<font color=#004488>""</font>);
      String[] items = lst.getSelectedItems();
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; items.length; i++)
        t.appendText(items[i] + <font color=#004488>"\n"</font>);
    }
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(b)) {
      <font color=#0000ff>if</font>(count &lt; flavors.length)
        lst.addItem(flavors[count++], 0);
    }
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you press the button it adds
items to the <I>top</I> of the list (because of the second argument 0 to
<B>addItem(&#160;)</B>). Adding elements to a <B>List </B>is more reasonable
than the <B>Choice</B> box because users expect to scroll a list box (for one
thing, it has a built-in scroll bar) but they don&#8217;t expect to have to
figure out how to get a drop-down list to scroll, as in the previous
example.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, the only way for
<B>action(&#160;)</B> to be called is through a double-click. If you need to
monitor other activities that the user is doing on your <B>List</B> (in
particular, single clicks) you must take an alternative
approach.</FONT><A NAME="_Toc375545456"></A><A NAME="_Toc408018692"></A><BR></P></DIV>
<A NAME="Heading407"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
handleEvent(&#160;)</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So far we&#8217;ve been using
<B>action(&#160;)</B>, but there&#8217;s another method that gets first crack at
everything:
<A NAME="Index1656"></A><A NAME="Index1657"></A><B>handleEvent(&#160;)</B>. Any
time an event happens, it happens &#8220;over&#8221; or &#8220;to&#8221; a
particular object. The <B>handleEvent(&#160;)</B> method for that object is
automatically called and an
<A NAME="Index1658"></A><A NAME="Index1659"></A><B>Event</B> object is created
and passed to <B>handleEvent(&#160;)</B>. The default <B>handleEvent(&#160;)</B>
(which is defined in
<A NAME="Index1660"></A><A NAME="Index1661"></A><B>Component</B>, the base class
for virtually all the &#8220;controls&#8221; in the AWT) will call either
<A NAME="Index1662"></A><A NAME="Index1663"></A><B>action(&#160;),</B> as
we&#8217;ve been using, or other similar methods to indicate mouse activity,
keyboard activity, or to indicate that the focus has moved. We&#8217;ll look at
those later in this chapter.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What if these other methods &#8211;
<B>action(&#160;)</B> in particular &#8211; don&#8217;t satisfy your needs? In
the case of <B>List</B>, for example, what if you want to catch single mouse
clicks but <B>action(&#160;)</B> responds to only double clicks? The solution is
to override <B>handleEvent(&#160;)</B> for your applet, which after all is
derived from <B>Applet</B> and can therefore override any non-<B>final</B>
methods. When you override <B>handleEvent(&#160;)</B> for the applet
you&#8217;re getting all the applet events before they are routed, so you cannot
just assume &#8220;This has to do with my button so I can assume it&#8217;s been
pressed,&#8221; since that&#8217;s true only for <B>action(&#160;)</B>. Inside
<B>handleEvent(&#160;)</B> it&#8217;s possible that the button has the focus and
someone is typing to it. Whether it makes sense or not, those are events that
you can detect and act upon in <B>handleEvent(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To modify the <B>List</B> example
so that it will react to single mouse clicks, the button detection will be left
in <B>action(&#160;)</B> but the code to handle the <B>List</B> will be moved
into <B>handleEvent(&#160;)</B> as follows:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: List2.java</font>
<font color=#009900>// Using lists with handleEvent()</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> List2 <font color=#0000ff>extends</font> Applet {
  String[] flavors = { <font color=#004488>"Chocolate"</font>, <font color=#004488>"Strawberry"</font>,
    <font color=#004488>"Vanilla Fudge Swirl"</font>, <font color=#004488>"Mint Chip"</font>, 
    <font color=#004488>"Mocha Almond Fudge"</font>, <font color=#004488>"Rum Raisin"</font>, 
    <font color=#004488>"Praline Cream"</font>, <font color=#004488>"Mud Pie"</font> };
  <font color=#009900>// Show 6 items, allow multiple selection:</font>
  List lst = <font color=#0000ff>new</font> List(6, <font color=#0000ff>true</font>);
  TextArea t = <font color=#0000ff>new</font> TextArea(flavors.length, 30);
  Button b = <font color=#0000ff>new</font> Button(<font color=#004488>"test"</font>);
  <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    t.setEditable(<font color=#0000ff>false</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 4; i++)
      lst.addItem(flavors[count++]);
    add(t);
    add(lst);
    add(b);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> handleEvent(Event evt) {
    <font color=#0000ff>if</font>(evt.id == Event.LIST_SELECT ||
       evt.id == Event.LIST_DESELECT) {
      <font color=#0000ff>if</font>(evt.target.equals(lst)) {
        t.setText(<font color=#004488>""</font>);
        String[] items = lst.getSelectedItems();
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; items.length; i++)
          t.appendText(items[i] + <font color=#004488>"\n"</font>);
      }
      <font color=#0000ff>else</font> 
        <font color=#0000ff>return</font> <font color=#0000ff>super</font>.handleEvent(evt);
    } 
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.handleEvent(evt);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action(Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(b)) {
      <font color=#0000ff>if</font>(count &lt; flavors.length)
        lst.addItem(flavors[count++], 0);
    }
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The example is the same as before
except for the addition of <B>handleEvent(&#160;)</B>. Inside, a check is made
to see whether a list selection or deselection has occurred. Now remember,
<B>handleEvent(&#160;) </B>is being overridden for the applet, so this
occurrence could be anywhere on the form and it could be happening to another
list. Thus, you must also check to see what the target is. (Although in this
case there&#8217;s only one list on the applet so we could have made the
assumption that all list events must be about that list. This is bad practice
since it&#8217;s going to be a problem as soon as another list is added.) If the
list matches the one we&#8217;re interested in, the same code as before will do
the trick.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the form for
<B>handleEvent(&#160;) </B>is similar to <B>action(&#160;)</B>:<B> </B>if you
deal with a particular event you <B>return</B> <B>true</B>, but if you&#8217;re
not interested in any of the other events via <B>handleEvent(&#160;)</B> you
must <B>return
<A NAME="Index1664"></A><A NAME="Index1665"></A>super.handleEvent(evt)</B>. This
is vital because if you don&#8217;t do this, none of the other event-handling
code will get called. For example, try commenting out the <B>return
super.handleEvent(evt)</B> in the code above. You&#8217;ll discover that
<B>action(&#160;)</B> never gets called, certainly not what you want. For both
<B>action(&#160;)</B> and <B>handleEvent(&#160;)</B> it&#8217;s important to
follow the format above and always return the base-class version of the method
when you do not handle the event yourself (in which case you should return
<B>true</B>). (Fortunately, these kinds of bug-prone details are relegated to
Java 1.0<A NAME="Index1666"></A>. The new design in Java
1.1<A NAME="Index1667"></A> that you will see later in the chapter eliminates
these kinds of issues.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Windows, a list box
automatically allows
<A NAME="Index1668"></A><A NAME="Index1669"></A><A NAME="Index1670"></A>multiple
selections if you hold down the shift key. This is nice because it allows the
user to choose a single or multiple selection rather than fixing it during
programming. You might think you&#8217;ll be clever and implement this yourself
by checking to see if the shift key is held down when a mouse click was made by
testing for <B>evt.shiftDown(&#160;)</B>. Alas, the design of the AWT stymies
you &#8211; you&#8217;d have to be able to know which item was clicked on if the
shift key <I>wasn&#8217;t </I>pressed so you could deselect all the rest and
select only that one. However, you cannot figure that out in Java
1.0.<A NAME="Index1671"></A> (Java 1.1<A NAME="Index1672"></A> sends all mouse,
keyboard, and focus events to a <B>List</B>, so you&#8217;ll be able to
accomplish
this.)</FONT><A NAME="_Toc375545457"></A><A NAME="_Toc408018693"></A><BR></P></DIV>
<A NAME="Heading408"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Controlling layout<BR><A NAME="Index1673"></A><A NAME="Index1674"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The way that you place components
on a form in Java is probably different from any other GUI system you&#8217;ve
used. First, it&#8217;s all code; there are no &#8220;resources&#8221; that
control placement of components. Second, the way components are placed on a form
is controlled by a &#8220;<A NAME="Index1675"></A>layout manager&#8221; that
decides how the components lie based on the order that you
<A NAME="Index1676"></A><A NAME="Index1677"></A><B>add(&#160;)</B> them. The
size, shape, and placement of components will be remarkably different from one
layout manager to another. In addition, the layout managers adapt to the
dimensions of your applet or application window, so if that window dimension is
changed (for example, in the HTML page&#8217;s applet specification) the size,
shape, and placement of the components could change.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both the
<A NAME="Index1678"></A><A NAME="Index1679"></A><B>Applet</B> and
<A NAME="Index1680"></A><A NAME="Index1681"></A><B>Frame </B>classes are derived
from <A NAME="Index1682"></A><A NAME="Index1683"></A><B>Container</B>, whose job
it is to contain and display <B>Component</B>s. (The <B>Container</B> is a
<A NAME="Index1684"></A><A NAME="Index1685"></A><B>Component</B> so it can also
react to events.) In <B>Container,</B> there&#8217;s a method called
<A NAME="Index1686"></A><A NAME="Index1687"></A><B>setLayout(&#160;)</B> that
allows you to choose a different layout manager.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this section we&#8217;ll explore
the various layout managers by placing buttons in them (since that&#8217;s the
simplest thing to do). There won&#8217;t be any capturing of button events since
this is just intended to show how the buttons are laid
out.</FONT><A NAME="_Toc375545458"></A><A NAME="_Toc408018694"></A><BR></P></DIV>
<A NAME="Heading409"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
FlowLayout</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So far, all the applets that have
been created seem to have laid out their components using some mysterious
internal logic. That&#8217;s because the applet uses a default layout scheme:
the <A NAME="Index1688"></A><A NAME="Index1689"></A><B>FlowLayout</B>. This
simply &#8220;flows&#8221; the components onto the form, from left to right
until the top space is full, then moves down a row and continues flowing the
components.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that
explicitly (redundantly) sets the layout manager in an applet to
<B>FlowLayout</B> and then places buttons on the form. You&#8217;ll notice that
with <B>FlowLayout</B> the components take on their &#8220;natural&#8221; size.
A <A NAME="Index1690"></A><A NAME="Index1691"></A><B>Button</B>, for example,
will be the size of its string. </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: FlowLayout1.java</font>
<font color=#009900>// Demonstrating the FlowLayout</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FlowLayout1 <font color=#0000ff>extends</font> Applet {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    setLayout(<font color=#0000ff>new</font> FlowLayout());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 20; i++)
      add(<font color=#0000ff>new</font> Button(<font color=#004488>"Button "</font> + i));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All components will be compacted to
their smallest size in a <B>FlowLayout</B>, so you might get a little bit of
surprising behavior. For example, a label will be the size of its string, so
right-justifying it yields an unchanged
display.</FONT><A NAME="_Toc375545459"></A><A NAME="_Toc408018695"></A><BR></P></DIV>
<A NAME="Heading410"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
BorderLayout</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This layout manager has the concept
of four border regions and a center area. When you add something to a panel
that&#8217;s using a
<A NAME="Index1692"></A><A NAME="Index1693"></A><B>BorderLayout</B> you must use
an <B>add(&#160;)</B> method that takes a <B>String</B> object as its first
argument, and that string must specify (with proper capitalization)
&#8220;<A NAME="Index1694"></A><A NAME="Index1695"></A>North&#8221; (top),
&#8220;<A NAME="Index1696"></A><A NAME="Index1697"></A>South&#8221; (bottom),
&#8220;<A NAME="Index1698"></A><A NAME="Index1699"></A>East&#8221; (right),
&#8220;<A NAME="Index1700"></A><A NAME="Index1701"></A>West&#8221; (left), or
&#8220;Center.&#8221; If you misspell or mis-capitalize, you won&#8217;t get a
compile-time error, but the applet simply won&#8217;t do what you expect.
Fortunately, as you will see shortly, there&#8217;s a much-improved approach in
Java 1.1<A NAME="Index1702"></A>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a simple
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: BorderLayout1.java</font>
<font color=#009900>// Demonstrating the BorderLayout</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> BorderLayout1 <font color=#0000ff>extends</font> Applet {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    <font color=#0000ff>int</font> i = 0;
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    add(<font color=#004488>"North"</font>, <font color=#0000ff>new</font> Button(<font color=#004488>"Button "</font> + i++));
    add(<font color=#004488>"South"</font>, <font color=#0000ff>new</font> Button(<font color=#004488>"Button "</font> + i++));
    add(<font color=#004488>"East"</font>, <font color=#0000ff>new</font> Button(<font color=#004488>"Button "</font> + i++));
    add(<font color=#004488>"West"</font>, <font color=#0000ff>new</font> Button(<font color=#004488>"Button "</font> + i++));
    add(<font color=#004488>"Center"</font>, <font color=#0000ff>new</font> Button(<font color=#004488>"Button "</font> + i++));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For every placement but
&#8220;Center,&#8221; the element that you add is compressed to fit in the
smallest amount of space along one dimension while it is stretched to the
maximum along the other dimension. &#8220;Center,&#8221; however, spreads out
along both dimensions to occupy the middle.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>BorderLayout</B> is the
default layout manager for applications and
dialogs.</FONT><A NAME="_Toc375545460"></A><A NAME="_Toc408018696"></A><BR></P></DIV>
<A NAME="Heading411"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
GridLayout</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index1703"></A><A NAME="Index1704"></A><B>GridLayout</B> allows you to
build a table of components, and as you add them they are placed left-to-right
and top-to-bottom in the grid. In the constructor you specify the number of rows
and columns that you need and these are laid out in equal
proportions.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: GridLayout1.java</font>
<font color=#009900>// Demonstrating the GridLayout</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GridLayout1 <font color=#0000ff>extends</font> Applet {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    setLayout(<font color=#0000ff>new</font> GridLayout(7,3));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 20; i++)
      add(<font color=#0000ff>new</font> Button(<font color=#004488>"Button "</font> + i));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this case there are 21 slots but
only 20 buttons. The last slot is left empty; no &#8220;balancing&#8221; goes on
with a
<B>GridLayout</B>.</FONT><A NAME="_Toc375545461"></A><A NAME="_Toc408018697"></A><BR></P></DIV>
<A NAME="Heading412"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
CardLayout</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1705"></A><A NAME="Index1706"></A><B>CardLayout</B> allows you to
create the rough equivalent of a &#8220;tabbed dialog,&#8221; which in more
sophisticated environments has actual file-folder tabs running across one edge,
and all you have to do is press a tab to bring forward a different dialog. Not
so in the AWT: The <B>CardLayout</B> is simply a blank space and you&#8217;re
responsible for bringing forward new cards. (The JFC/Swing library contains
tabbed panes that look much better and take care of all the details for
you.)</FONT><BR></P></DIV>
<A NAME="Heading413"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Combining layouts<BR><A NAME="Index1707"></A><A NAME="Index1708"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example will combine more than
one layout type, which seems rather difficult at first since only one layout
manager can be operating for an applet or application. This is true, but if you
create more <A NAME="Index1709"></A><A NAME="Index1710"></A><B>Panel</B>
objects, each one of those <B>Panel</B>s can have its own layout manager and
then be integrated into the applet or application as simply another component,
using the applet or application&#8217;s layout manager. This gives you much
greater flexibility as seen in the following example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CardLayout1.java</font>
<font color=#009900>// Demonstrating the CardLayout</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.Applet;

<font color=#0000ff>class</font> ButtonPanel <font color=#0000ff>extends</font> Panel {
  ButtonPanel(String id) {
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    add(<font color=#004488>"Center"</font>, <font color=#0000ff>new</font> Button(id));
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CardLayout1 <font color=#0000ff>extends</font> Applet {
  Button
    first = <font color=#0000ff>new</font> Button(<font color=#004488>"First"</font>),
    second = <font color=#0000ff>new</font> Button(<font color=#004488>"Second"</font>),
    third = <font color=#0000ff>new</font> Button(<font color=#004488>"Third"</font>);
  Panel cards = <font color=#0000ff>new</font> Panel();
  CardLayout cl = <font color=#0000ff>new</font> CardLayout();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    Panel p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> FlowLayout());
    p.add(first);
    p.add(second);
    p.add(third);
    add(<font color=#004488>"North"</font>, p);
    cards.setLayout(cl);
    cards.add(<font color=#004488>"First card"</font>, 
      <font color=#0000ff>new</font> ButtonPanel(<font color=#004488>"The first one"</font>));
    cards.add(<font color=#004488>"Second card"</font>, 
      <font color=#0000ff>new</font> ButtonPanel(<font color=#004488>"The second one"</font>));
    cards.add(<font color=#004488>"Third card"</font>, 
      <font color=#0000ff>new</font> ButtonPanel(<font color=#004488>"The third one"</font>));
    add(<font color=#004488>"Center"</font>, cards);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action(Event evt, Object arg) {
    <font color=#0000ff>if</font> (evt.target.equals(first)) {
      cl.first(cards);
    } 
    <font color=#0000ff>else</font> <font color=#0000ff>if</font> (evt.target.equals(second)) {
      cl.first(cards);
      cl.next(cards);
    } 
    <font color=#0000ff>else</font> <font color=#0000ff>if</font> (evt.target.equals(third)) {
      cl.last(cards);
    } 
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example begins by creating a
new kind of <B>Panel</B>: a <B>ButtonPanel</B>. This contains a single button,
placed at the center of a <B>BorderLayout</B>, which means that it will expand
to fill the entire panel. The label on the button will let you know which panel
you&#8217;re on in the <B>CardLayout</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the applet, both the <B>Panel
cards</B> where the cards will live and the layout manager <B>cl</B> for the
<B>CardLayout</B> must be members of the class because you need to have access
to those handles when you want to manipulate the cards.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The applet is changed to use a
<B>BorderLayout</B> instead of its default <B>FlowLayout</B>, a <B>Panel</B> is
created to hold three buttons (using a <B>FlowLayout</B>), and this panel is
placed at the &#8220;North&#8221; end of the applet. The <B>cards</B> panel is
added to the &#8220;Center&#8221; of the applet, effectively occupying the rest
of the real estate.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you add the
<B>ButtonPanel</B>s (or whatever other components you want) to the panel of
cards, the <B>add(&#160;)</B> method&#8217;s first argument is not
&#8220;North,&#8221; &#8220;South,&#8221; etc. Instead, it&#8217;s a string that
describes the card. Although this string doesn&#8217;t show up anywhere on the
card, you can use it if you want to flip that card using the string. This
approach is not used in <B>action(&#160;)</B>; instead the <B>first(&#160;)</B>,
<B>next(&#160;),</B> and <B>last(&#160;)</B> methods are used. Check your
documentation for the other approach.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Java, the use of some sort of
&#8220;tabbed panel&#8221; mechanism is quite important because (as you&#8217;ll
see later) in applet programming the use of pop-up dialogs is heavily
discouraged. For Java 1.0<A NAME="Index1711"></A> applets, the <B>CardLayout</B>
is the only viable way for the applet to have a number of different forms that
&#8220;pop up&#8221; on
command.</FONT><A NAME="_Toc375545462"></A><A NAME="_Toc408018698"></A><BR></P></DIV>
<A NAME="Heading414"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
GridBagLayout</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some time ago, it was believed that
all the stars, planets, the sun, and the moon revolved around the earth. It
seemed intuitive from observation. But then astronomers became more
sophisticated and started tracking the motion of individual objects, some of
which seemed at times to go backward in their paths. Since it was known that
everything revolved around the earth, those astronomers spent large amounts of
time coming up with equations and theories to explain the motion of the stellar
objects.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When trying to work with
<A NAME="Index1712"></A><A NAME="Index1713"></A><B>GridBagLayout</B>,<B> </B>you
can consider yourself the analog of one of those early astronomers. The basic
precept (decreed, interestingly enough, by the designers at &#8220;Sun&#8221;)
is that everything should be done in code. The Copernican revolution (again
dripping with irony, the discovery that the planets in the solar system revolve
around the sun) is the use of <I>resources</I> to determine the layout and make
the programmer&#8217;s job easy. Until these are added to Java, you&#8217;re
stuck (to continue the metaphor) in the Spanish Inquisition of
<B>GridBagLayout</B> and <B>GridBagConstraints</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">My recommendation is to avoid
<B>GridBagLayout</B>. Instead, use the other layout managers and especially the
technique of combining several panels using different layout managers within a
single program. Your applets won&#8217;t look <I>that</I> different; at least
not enough to justify the trouble that <B>GridBagLayout</B> entails. For my
part, it&#8217;s just too painful to come up with an example for this (and I
wouldn&#8217;t want to encourage this kind of library design). Instead,
I&#8217;ll refer you to <I>Core Java</I> by Cornell &amp; Horstmann
(2<SUP>nd</SUP> ed., Prentice-Hall, 1997) to get
started.</FONT><A NAME="_Toc375545463"></A><A NAME="_Toc408018699"></A><BR></P></DIV>
<A NAME="Heading415"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Alternatives to action</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As noted previously,
<B>action(&#160;)</B> isn&#8217;t the only method that&#8217;s automatically
called by
<A NAME="Index1714"></A><A NAME="Index1715"></A><B>handleEvent(&#160;)</B> once
it sorts everything out for you. There are three other sets of methods that are
called, and if you want to capture certain types of events (keyboard, mouse, and
focus events) all you have to do is override the provided method. These methods
are defined in the base class
<A NAME="Index1716"></A><A NAME="Index1717"></A><B>Component</B>, so
they&#8217;re available in virtually all the controls that you might place on a
form. However, you should be aware that this approach is deprecated in Java
1.1<A NAME="Index1718"></A>, so although you might see legacy code using this
technique you should use the Java 1.1 approaches (described later in this
chapter) instead.
<A NAME="Index1719"></A><A NAME="Index1720"></A><A NAME="Index1721"></A><A NAME="Index1722"></A><A NAME="Index1723"></A><A NAME="Index1724"></A><A NAME="Index1725"></A><A NAME="Index1726"></A><A NAME="Index1727"></A><A NAME="Index1728"></A><A NAME="Index1729"></A><A NAME="Index1730"></A><A NAME="Index1731"></A><A NAME="Index1732"></A><A NAME="Index1733"></A><A NAME="Index1734"></A><A NAME="Index1735"></A><A NAME="Index1736"></A><A NAME="Index1737"></A><A NAME="Index1738"></A><A NAME="Index1739"></A><A NAME="Index1740"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=184 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Component method</FONT><BR></P></DIV>
</TH>
<TH WIDTH=157 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When it&#8217;s
called</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>action (Event evt, Object
what)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the &#8220;typical&#8221;
event occurs for this component (for example, when a button is pushed or a
drop-down list item is selected)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>keyDown (Event evt, int
key)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A key is pressed when this
component has the focus. The second argument is the key that was pressed and is
redundantly copied from <B>evt.key</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>keyUp(Event evt, int
key)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A key is released when this
component has the focus.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>lostFocus(Event evt, Object
what)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The focus has moved away from the
target. Normally, <B>what</B> is redundantly copied from
<B>evt.arg</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>gotFocus(Event evt, Object
what)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The focus has moved into the
target.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>mouseDown(Event evt,
</B></FONT><BR><FONT FACE="Georgia"><B>  int x, int
y)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A mouse down has occurred over the
component, at the coordinates <B>x</B>, <B>y</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>mouseUp(Event evt, int x, int
y)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A mouse up has occurred over the
component.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>mouseMove(Event evt, int x, int
y)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The mouse has moved while
it&#8217;s over the component.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>mouseDrag(Event evt, int x, int
y)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The mouse is being dragged after a
<B>mouseDown</B> occurred over the component. All drag events are reported to
the component in which the <B>mouseDown</B> occurred until there is a
<B>mouseUp</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>mouseEnter(Event evt, int x, int
y)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The mouse wasn&#8217;t over the
component before, but now it is.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>mouseExit(Event evt, int x, int
y)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The mouse used to be over the
component, but now it isn&#8217;t.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that each method
receives an <B>Event</B> object along with some information that you&#8217;ll
typically need when you&#8217;re handling that particular situation &#8211; with
a mouse event, for example, it&#8217;s likely that you&#8217;ll want to know the
coordinates where the mouse event occurred. It&#8217;s interesting to note that
when <B>Component</B>&#8217;s <B>handleEvent(&#160;)</B> calls any of these
methods (the typical case), the extra arguments are always redundant as they are
contained within the <B>Event</B> object. In fact, if you look at the source
code for <B>Component.handleEvent(&#160;)</B> you can see that it explicitly
plucks the additional arguments out of the <B>Event</B> object. (This might be
considered inefficient coding in some languages, but remember that Java&#8217;s
focus is on safety, not necessarily speed.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To prove to yourself that these
events are in fact being called and as an interesting experiment, it&#8217;s
worth creating an applet that overrides each of the methods above (except for
<B>action(&#160;), </B>which is overridden in many other places in this chapter)
and displays data about each of the events as they happen.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example also shows you how to
make your own button object because that&#8217;s what is used as the target of
all the events of interest. You might first (naturally) assume that to make a
new button, you&#8217;d inherit from
<A NAME="Index1741"></A><A NAME="Index1742"></A><B>Button</B>. But this
doesn&#8217;t work. Instead, you inherit from
<A NAME="Index1743"></A><A NAME="Index1744"></A><B>Canvas</B> (a much more
generic component) and paint your button on that canvas by overriding the
<A NAME="Index1745"></A><A NAME="Index1746"></A><B>paint(&#160;)</B> method. As
you&#8217;ll see, it&#8217;s really too bad that overriding <B>Button</B>
doesn&#8217;t work, since there&#8217;s a bit of code involved to paint the
button. (If you don&#8217;t believe me, try exchanging <B>Button </B>for
<B>Canvas</B> in this example, and remember to call the base-class constructor
<B>super(label)</B>. You&#8217;ll see that the button doesn&#8217;t get painted
and the events don&#8217;t get handled.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>myButton</B> class is
specific: it works only with an <B>AutoEvent</B> &#8220;parent window&#8221;
(not a base class, but the window in which this button is created and lives).
With this knowledge, <B>myButton</B> can reach into the parent window and
manipulate its text fields, which is what&#8217;s necessary to be able to write
the status information into the fields of the parent. Of course this is a much
more limited solution, since <B>myButton</B> can be used only in conjunction
with <B>AutoEvent</B>. This kind of code is sometimes called &#8220;highly
coupled.&#8221; However, to make <B>myButton</B> more generic requires a lot
more effort that isn&#8217;t warranted for this example (and possibly for many
of the applets that you will write). Again, keep in mind that the following code
uses APIs that are deprecated in Java
1.1<A NAME="Index1747"></A>.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: AutoEvent.java</font>
<font color=#009900>// Alternatives to action()</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.applet.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> MyButton <font color=#0000ff>extends</font> Canvas {
  AutoEvent parent;
  Color color;
  String label;
  MyButton(AutoEvent parent, 
           Color color, String label) {
    <font color=#0000ff>this</font>.label = label;
    <font color=#0000ff>this</font>.parent = parent;
    <font color=#0000ff>this</font>.color = color;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics  g) {
    g.setColor(color);
    <font color=#0000ff>int</font> rnd = 30;
    g.fillRoundRect(0, 0, size().width, 
                    size().height, rnd, rnd);
    g.setColor(Color.black);
    g.drawRoundRect(0, 0, size().width, 
                    size().height, rnd, rnd);
    FontMetrics fm = g.getFontMetrics();
    <font color=#0000ff>int</font> width = fm.stringWidth(label);
    <font color=#0000ff>int</font> height = fm.getHeight();
    <font color=#0000ff>int</font> ascent = fm.getAscent();
    <font color=#0000ff>int</font> leading = fm.getLeading();
    <font color=#0000ff>int</font> horizMargin = (size().width - width)/2;
    <font color=#0000ff>int</font> verMargin = (size().height - height)/2;
    g.setColor(Color.white);
    g.drawString(label, horizMargin, 
                 verMargin + ascent + leading);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> keyDown(Event evt, <font color=#0000ff>int</font> key) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"keyDown"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> keyUp(Event evt, <font color=#0000ff>int</font> key) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"keyUp"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> lostFocus(Event evt, Object w) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"lostFocus"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> gotFocus(Event evt, Object w) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"gotFocus"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
  mouseDown(Event evt,<font color=#0000ff>int</font> x,<font color=#0000ff>int</font> y) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"mouseDown"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
  mouseDrag(Event evt,<font color=#0000ff>int</font> x,<font color=#0000ff>int</font> y) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"mouseDrag"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
  mouseEnter(Event evt,<font color=#0000ff>int</font> x,<font color=#0000ff>int</font> y) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"mouseEnter"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
  mouseExit(Event evt,<font color=#0000ff>int</font> x,<font color=#0000ff>int</font> y) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"mouseExit"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
  mouseMove(Event evt,<font color=#0000ff>int</font> x,<font color=#0000ff>int</font> y) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"mouseMove"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> mouseUp(Event evt,<font color=#0000ff>int</font> x,<font color=#0000ff>int</font> y) {
    TextField t = 
      (TextField)parent.h.get(<font color=#004488>"mouseUp"</font>);
    t.setText(evt.toString());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AutoEvent <font color=#0000ff>extends</font> Applet {
  Hashtable h = <font color=#0000ff>new</font> Hashtable();
  String[] event = {
    <font color=#004488>"keyDown"</font>, <font color=#004488>"keyUp"</font>, <font color=#004488>"lostFocus"</font>, 
    <font color=#004488>"gotFocus"</font>, <font color=#004488>"mouseDown"</font>, <font color=#004488>"mouseUp"</font>, 
    <font color=#004488>"mouseMove"</font>, <font color=#004488>"mouseDrag"</font>, <font color=#004488>"mouseEnter"</font>, 
    <font color=#004488>"mouseExit"</font>
  };
  MyButton 
    b1 = <font color=#0000ff>new</font> MyButton(<font color=#0000ff>this</font>, Color.blue, <font color=#004488>"test1"</font>),
    b2 = <font color=#0000ff>new</font> MyButton(<font color=#0000ff>this</font>, Color.red, <font color=#004488>"test2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    setLayout(<font color=#0000ff>new</font> GridLayout(event.length+1,2));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; event.length; i++) {
      TextField t = <font color=#0000ff>new</font> TextField();
      t.setEditable(<font color=#0000ff>false</font>);
      add(<font color=#0000ff>new</font> Label(event[i], Label.CENTER)); 
      add(t);
      h.put(event[i], t);
    }
    add(b1);
    add(b2);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see the constructor uses
the technique of using the same name for the argument as what it&#8217;s
assigned to, and differentiating between the two using
<B>this</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>this</font>.label = label;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>paint(&#160;)</B> method
starts out simple: it fills a &#8220;round rectangle&#8221; with the
button&#8217;s color, and then draws a black line around it. Notice the use of
<B>size(&#160;)</B> to determine the width and height of the component (in
pixels, of course). After this, <B>paint(&#160;) </B>seems quite complicated
because there&#8217;s a lot of calculation going on to figure out how to center
the button&#8217;s label inside the button using the &#8220;font metrics.&#8221;
You can get a pretty good idea of what&#8217;s going on by looking at the method
call, and it turns out that this is pretty stock code, so you can just cut and
paste it when you want to center a label inside any component.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can&#8217;t understand exactly
how the <B>keyDown(&#160;)</B>, <B>keyUp(&#160;),</B> etc. methods work until
you look down at the <B>AutoEvent</B> class. This contains a
<A NAME="Index1748"></A><B>Hashtable</B> to hold the strings representing the
type of event and the <B>TextField</B> where information about that event is
held. Of course, these could have been created statically rather than putting
them in a <B>Hashtable</B>, but I think you&#8217;ll agree that it&#8217;s a lot
easier to use and change. In particular, if you need to add or remove a new type
of event in <B>AutoEvent</B>, you simply add or remove a string in the
<B>event</B> array &#8211; everything else happens
automatically.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The place where you look up the
strings is in the <B>keyDown(&#160;)</B>, <B>keyUp(&#160;),</B> etc. methods
back in <B>MyButton</B>. Each of these methods uses the <B>parent</B> handle to
reach back to the parent window. Since that parent is an <B>AutoEvent</B> it
contains the <B>Hashtable h</B>, and the <B>get(&#160;)</B> method, when
provided with the appropriate <B>String</B>, will produce a handle to an
<B>Object</B> that we happen to know is a <B>TextField</B> &#8211; so it is cast
to that. Then the <B>Event</B> object is converted to its <B>String</B>
representation, which is displayed in the <B>TextField</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It turns out this example is rather
fun to play with since you can really see what&#8217;s going on with the events
in your
program.</FONT><A NAME="_Toc375545464"></A><A NAME="_Toc408018700"></A><BR></P></DIV>
<A NAME="Heading416"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Applet
restrictions<BR><A NAME="Index1749"></A><A NAME="Index1750"></A><A NAME="Index1751"></A><A NAME="Index1752"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For safety&#8217;s sake, applets
are quite restricted and there are many things you can&#8217;t do. You can
generally answer the question of what an applet is able to do by looking at what
it is <I>supposed</I> to do: extend the functionality of a Web page in a
browser. Since, as a net surfer, you never really know if a Web page is from a
friendly place or not, you want any code that it runs to be safe. So the biggest
restrictions you&#8217;ll notice are probably:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1) <I>An applet can&#8217;t touch
the local disk</I>. This means writing <I>or</I> reading, since you
wouldn&#8217;t want an applet to read and transmit important information about
you across the Web. Writing is prevented, of course, since that would be an open
invitation to a virus. These restrictions can be relaxed when digital signing is
fully implemented.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">2) <I>An applet can&#8217;t have
menus.</I> (Note: this is fixed in Swing) This is probably less oriented toward
safety and more toward reducing confusion. You might have noticed that an applet
looks like it blends right in as part of a Web page; you often don&#8217;t see
the boundaries of the applet. There&#8217;s no frame or title bar to hang the
menu from, other than the one belonging to the Web browser. Perhaps the design
could be changed to allow you to merge your applet menu with the browser menu
&#8211; that would be complicated and would also get a bit too close to the edge
of safety by allowing the applet to affect its environment.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">3) <I>Dialog boxes are
&#8220;untrusted.&#8221;</I> In Java, dialog boxes present a bit of a quandary.
First of all, they&#8217;re not exactly disallowed in applets but they&#8217;re
heavily discouraged. If you pop up a dialog box from within an applet
you&#8217;ll get an &#8220;untrusted applet&#8221; message attached to that
dialog. This is because, in theory, it would be possible to fool the user into
thinking that they&#8217;re dealing with a regular native application and to get
them to type in their credit card number, which then goes across the Web. After
seeing the kinds of GUIs that the AWT produces you might have a hard time
believing <I>anybody</I> could be fooled that way. But an applet is always
attached to a Web page and visible within your Web browser, while a dialog box
is detached so in theory it could be possible. As a result it will be rare to
see an applet that uses a dialog box.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Many applet restrictions are
relaxed for trusted applets (those signed by a trusted source) in newer
browsers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are other issues when
thinking about applet development:
<A NAME="Index1753"></A><A NAME="Index1754"></A></FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Applets take longer
to download since you must download the whole thing every time, including a
separate server hit for each different class. Your browser can cache the applet,
but there are no guarantees. One improvement in Java 1.1 is the JAR (Java
ARchive) file that allows packaging of all the applet components (including
other <B>.class</B> files as well as images and sounds) together into a single
compressed file that can be downloaded in a single server transaction.
&#8220;Digital signing&#8221; (the ability to verify the creator of a class) is
available for each individual entry in the JAR
file.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Because
of security issues you must work harder to do certain things such as accessing
databases and sending email. In addition, the security restrictions make
accessing multiple hosts difficult, since everything has to be routed through
the Web server, which then becomes a performance bottleneck and a single failure
point that can stop the entire
process.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">An
applet within the browser doesn&#8217;t have the same kind of control that a
native application does. For example, you can&#8217;t have a modal dialog box
within an applet, since the user can always switch the page. When the user
<I>does</I> change from a Web page or even exit the browser, the results can be
catastrophic for your applet &#8211; there&#8217;s no way to save the state so
if you&#8217;re in the middle of a transaction or other operation the
information can be lost. In addition, different browsers do different things to
your applet when you leave a Web page so the results are essentially
undefined.</FONT><A NAME="_Toc375545465"></A><A NAME="_Toc408018701"></A></UL><A NAME="Heading417"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Applet advantages</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you can live within the
restrictions, applets have definite advantages, especially when building
<A NAME="Index1755"></A><A NAME="Index1756"></A>client/server or other networked
applications: <A NAME="Index1757"></A></FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">There is no
installation issue. An applet has true platform independence (including the
ability to easily play audio files, etc.) so you don&#8217;t need to make any
changes in your code for different platforms nor does anyone have to perform any
&#8220;tweaking&#8221; upon installation. In fact, installation is automatic
every time the user loads the Web page along with the applets, so updates happen
silently and automatically. In traditional client/server systems, building and
installing a new version of the client software is often a
nightmare.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Because
of the security built into the core Java language and the applet structure, you
don&#8217;t have to worry about bad code causing damage to someone&#8217;s
system. This, along with the previous point, makes Java (as well as alternative
client-side Web programming tools like JavaScript and VBScript) popular for
so-called <I>Intranet</I> client/server applications that live only within the
company and don&#8217;t move out onto the
Internet.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Because
applets are automatically integrated with HTML, you have a built-in
platform-independent documentation system to support the applet. It&#8217;s an
interesting twist, since we&#8217;re used to having the documentation part of
the program rather than vice
versa.</FONT><A NAME="_Toc375545466"></A><A NAME="_Toc408018702"></A></UL><A NAME="Heading418"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Windowed
applications<BR><A NAME="Index1758"></A><A NAME="Index1759"></A><A NAME="Index1760"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s possible to see that for
safety&#8217;s sake you can have only limited behavior within an applet. In a
real sense, the applet is a temporary extension to the Web browser so its
functionality must be limited along with its knowledge and control. There are
times, however, when you&#8217;d like to make a windowed program do something
else than sit on a Web page, and perhaps you&#8217;d like it to do some of the
things a &#8220;regular&#8221; application can do and yet have the vaunted
instant portability provided by Java. In previous chapters in this book
we&#8217;ve made command-line applications, but in some operating environments
(the Macintosh, for example) there isn&#8217;t a command line. So for any number
of reasons you&#8217;d like to build a windowed, non-applet program using Java.
This is certainly a reasonable desire.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A Java windowed application can
have menus and dialog boxes (impossible or difficult with an applet), and yet if
you&#8217;re using an older version of Java you sacrifice the native operating
environment&#8217;s look and feel. The JFC/Swing library allows you to make an
application that preserves the look and feel of the underlying operating
environment. If you want to build windowed applications, it makes sense to do so
only if you can use the latest version of Java and associated tools so you can
deliver applications that won&#8217;t confound your users. If for some reason
you&#8217;re forced to use an older version of Java, think hard before
committing to building a significant windowed
application.</FONT><A NAME="_Toc375545467"></A><A NAME="_Toc408018703"></A><BR></P></DIV>
<A NAME="Heading419"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Menus<BR><A NAME="Index1761"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s impossible to put a menu
directly on an applet (in Java 1.0 and Java 1.1; the Swing library <I>does
</I>allow it), so they&#8217;re for applications. Go ahead, try it if you
don&#8217;t believe me and you&#8217;re sure that it would make sense to have
menus on applets. There&#8217;s no
<A NAME="Index1762"></A><A NAME="Index1763"></A><B>setMenuBar(&#160;)</B> method
in <B>Applet</B> and that&#8217;s the way a menu is attached. (You&#8217;ll see
later that it&#8217;s possible to spawn a <B>Frame</B> from within an
<B>Applet</B>, and the <B>Frame</B> can contain menus.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are four different types of
<A NAME="Index1764"></A><A NAME="Index1765"></A><B>MenuComponent</B>, all
derived from that abstract class:
<A NAME="Index1766"></A><A NAME="Index1767"></A><B>MenuBar</B> (you can have one
<B>MenuBar</B> only on a particular
<A NAME="Index1768"></A><A NAME="Index1769"></A><B>Frame</B>),
<A NAME="Index1770"></A><A NAME="Index1771"></A><B>Menu</B> to hold one
individual drop-down menu or submenu,
<A NAME="Index1772"></A><A NAME="Index1773"></A><B>MenuItem</B> to represent one
single element on a menu, and
<A NAME="Index1774"></A><A NAME="Index1775"></A><B>CheckboxMenuItem,</B> which
is derived from <B>MenuItem</B> and produces a checkmark to indicate whether
that menu item is selected.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Unlike a system that uses
resources, with Java and the AWT you must hand assemble all the menus in source
code. Here are the ice cream flavors again, used to create
menus:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Menu1.java</font>
<font color=#009900>// Menus work only with Frames.</font>
<font color=#009900>// Shows submenus, checkbox menu items</font>
<font color=#009900>// and swapping menus.</font>
<font color=#0000ff>import</font> java.awt.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Menu1 <font color=#0000ff>extends</font> Frame {
  String[] flavors = { <font color=#004488>"Chocolate"</font>, <font color=#004488>"Strawberry"</font>,
    <font color=#004488>"Vanilla Fudge Swirl"</font>, <font color=#004488>"Mint Chip"</font>, 
    <font color=#004488>"Mocha Almond Fudge"</font>, <font color=#004488>"Rum Raisin"</font>, 
    <font color=#004488>"Praline Cream"</font>, <font color=#004488>"Mud Pie"</font> };
  TextField t = <font color=#0000ff>new</font> TextField(<font color=#004488>"No flavor"</font>, 30);
  MenuBar mb1 = <font color=#0000ff>new</font> MenuBar();
  Menu f = <font color=#0000ff>new</font> Menu(<font color=#004488>"File"</font>);
  Menu m = <font color=#0000ff>new</font> Menu(<font color=#004488>"Flavors"</font>);
  Menu s = <font color=#0000ff>new</font> Menu(<font color=#004488>"Safety"</font>);
  <font color=#009900>// Alternative approach:</font>
  CheckboxMenuItem[] safety = {
    <font color=#0000ff>new</font> CheckboxMenuItem(<font color=#004488>"Guard"</font>),
    <font color=#0000ff>new</font> CheckboxMenuItem(<font color=#004488>"Hide"</font>)
  };
  MenuItem[] file = {
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Open"</font>),
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Exit"</font>)
  };
  <font color=#009900>// A second menu bar to swap to:</font>
  MenuBar mb2 = <font color=#0000ff>new</font> MenuBar();
  Menu fooBar = <font color=#0000ff>new</font> Menu(<font color=#004488>"fooBar"</font>);
  MenuItem[] other = {
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Foo"</font>),
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Bar"</font>),
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Baz"</font>),
  };
  Button b = <font color=#0000ff>new</font> Button(<font color=#004488>"Swap Menus"</font>);
  <font color=#0000ff>public</font> Menu1() {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; flavors.length; i++) {
      m.add(<font color=#0000ff>new</font> MenuItem(flavors[i]));
      <font color=#009900>// Add separators at intervals:</font>
      <font color=#0000ff>if</font>((i+1) % 3 == 0) 
        m.addSeparator();
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; safety.length; i++)
      s.add(safety[i]);
    f.add(s);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; file.length; i++)
      f.add(file[i]);
    mb1.add(f);
    mb1.add(m);
    setMenuBar(mb1);
    t.setEditable(<font color=#0000ff>false</font>);
    add(<font color=#004488>"Center"</font>, t);
    <font color=#009900>// Set up the system for swapping menus:</font>
    add(<font color=#004488>"North"</font>, b);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; other.length; i++)
      fooBar.add(other[i]);
    mb2.add(fooBar);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> handleEvent(Event evt) {
    <font color=#0000ff>if</font>(evt.id == Event.WINDOW_DESTROY) 
      System.exit(0);
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.handleEvent(evt);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action(Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(b)) {
      MenuBar m = getMenuBar();
      <font color=#0000ff>if</font>(m == mb1) setMenuBar(mb2);
      <font color=#0000ff>else</font> <font color=#0000ff>if</font> (m == mb2) setMenuBar(mb1);
    } 
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target <font color=#0000ff>instanceof</font> MenuItem) {
      <font color=#0000ff>if</font>(arg.equals(<font color=#004488>"Open"</font>)) {
        String s = t.getText();
        <font color=#0000ff>boolean</font> chosen = <font color=#0000ff>false</font>;
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; flavors.length; i++)
          <font color=#0000ff>if</font>(s.equals(flavors[i])) chosen = <font color=#0000ff>true</font>;
        <font color=#0000ff>if</font>(!chosen)
          t.setText(<font color=#004488>"Choose a flavor first!"</font>);
        <font color=#0000ff>else</font>
          t.setText(<font color=#004488>"Opening "</font>+ s +<font color=#004488>". Mmm, mm!"</font>);
      }
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(file[1]))
        System.exit(0);
      <font color=#009900>// CheckboxMenuItems cannot use String </font>
      <font color=#009900>// matching; you must match the target:</font>
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(safety[0]))
        t.setText(<font color=#004488>"Guard the Ice Cream! "</font> +
          <font color=#004488>"Guarding is "</font> + safety[0].getState());
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(safety[1]))
        t.setText(<font color=#004488>"Hide the Ice Cream! "</font> +
          <font color=#004488>"Is it cold? "</font> + safety[1].getState());
      <font color=#0000ff>else</font> 
        t.setText(arg.toString());
    } 
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Menu1 f = <font color=#0000ff>new</font> Menu1();
    f.resize(300,200);
    f.show();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this program I avoided the
typical long lists of <B>add(&#160;)</B> calls for each menu because that seemed
like a lot of unnecessary typing. Instead, I placed the menu items into arrays
and then simply stepped through each array calling <B>add(&#160;)</B> in a
<B>for</B> loop. This makes adding or subtracting a menu item less
tedious.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an alternative approach (which I
find less desirable since it requires more typing), the <B>CheckboxMenuItem</B>s
are created in an array of handles called <B>safety</B>; this is true for the
arrays <B>file</B> and <B>other</B> as well.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program creates not one but
two <B>MenuBar</B>s to demonstrate that menu bars can be actively swapped while
the program is running. You can see how a <B>MenuBar</B> is made up of
<B>Menu</B>s, and each <B>Menu</B> is made up of <B>MenuItem</B>s,
<B>CheckboxMenuItem</B>s, or even other <B>Menu</B>s (which produce submenus).
When a <B>MenuBar</B> is assembled it can be installed into the current program
with the <B>setMenuBar(&#160;)</B> method. Note that when the button is pressed,
it checks to see which menu is currently installed using
<B>getMenuBar(&#160;)</B>, then puts the other menu bar in its
place.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When testing for
&#8220;Open,&#8221; notice that spelling and capitalization are critical, but
Java signals no error if there is no match with &#8220;Open.&#8221; This kind of
string comparison is a clear source of programming errors.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The checking and un-checking of the
menu items is taken care of automatically, but dealing with CheckboxMenuItems
can be a bit surprising since for some reason they don&#8217;t allow string
matching. (Although string matching isn&#8217;t a good approach, this seems
inconsistent.) So you can match only the target object and not its label. As
shown, the <A NAME="Index1776"></A><A NAME="Index1777"></A><B>getState(&#160;)
</B>method can be used to reveal the state. You can also change the state of a
<B>CheckboxMenuItem</B> with <B>setState(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might think that one menu could
reasonably reside on more than one menu bar. This does seem to make sense
because all you&#8217;re passing to the <B>MenuBar</B> <B>add(&#160;)</B> method
is a handle. However, if you try this, the behavior will be strange and not what
you expect. (It&#8217;s difficult to know if this is a bug or if they intended
it to work this way.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example also shows what you
need to do to create an application instead of an applet. (Again, because an
application can support menus and an applet cannot directly have a menu.)
Instead of inheriting from <B>Applet</B>, you inherit from <B>Frame</B>. Instead
of <B>init(&#160;)</B> to set things up, you make a constructor for your class.
Finally, you create a <B>main(&#160;)</B> and in that you build an object of
your new type, resize it, and then call <B>show(&#160;)</B>. It&#8217;s
different from an applet in only a few small places, but it&#8217;s now a
<A NAME="Index1778"></A><A NAME="Index1779"></A><A NAME="Index1780"></A>standalone
windowed application and you&#8217;ve got
menus.</FONT><A NAME="_Toc375545468"></A><A NAME="_Toc408018704"></A><BR></P></DIV>
<A NAME="Heading420"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Dialog boxes</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index1781"></A><A NAME="Index1782"></A>dialog box is a window that pops
up out of another window. Its purpose is to deal with some specific issue
without cluttering the original window with those details. Dialog boxes are
heavily used in windowed programming environments, but as mentioned previously,
rarely used in applets.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To create a dialog box, you inherit
from <A NAME="Index1783"></A><A NAME="Index1784"></A><B>Dialog</B>, which is
just another kind of <B>Window</B>, like a <B>Frame</B>. Unlike a <B>Frame</B>,
a <B>Dialog</B> cannot have a menu bar or change the cursor, but other than that
they&#8217;re quite similar. A dialog has a layout manager (which defaults to
<B>BorderLayout</B>) and you override <B>action(&#160;)</B> etc., or
<B>handleEvent(&#160;)</B> to deal with events. One significant difference
you&#8217;ll want to note in <B>handleEvent(&#160;)</B>: when the
<A NAME="Index1785"></A><A NAME="Index1786"></A><B>WINDOW_DESTROY</B> event
occurs, you don&#8217;t want to shut down the application! Instead, you release
the resources used by the dialog&#8217;s window by calling
<A NAME="Index1787"></A><A NAME="Index1788"></A><B>dispose(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the following example, the
dialog box is made up of a grid (using <B>GridLayout</B>) of a special kind of
button that is defined here as class <B>ToeButton</B>. This button draws a frame
around itself and, depending on its state, a blank, an &#8220;x,&#8221; or an
&#8220;o&#8221; in the middle. It starts out blank, and then depending on whose
turn it is, changes to an &#8220;x&#8221; or an &#8220;o.&#8221; However, it
will also flip back and forth between &#8220;x&#8221; and &#8220;o&#8221; when
you click on the button. (This makes the tic-tac-toe concept only slightly more
annoying than it already is.) In addition, the dialog box can be set up for any
number of rows and columns by changing numbers in the main application
window.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ToeTest.java</font>
<font color=#009900>// Demonstration of dialog boxes</font>
<font color=#009900>// and creating your own components</font>
<font color=#0000ff>import</font> java.awt.*;

<font color=#0000ff>class</font> ToeButton <font color=#0000ff>extends</font> Canvas {
  <font color=#0000ff>int</font> state = ToeDialog.BLANK;
  ToeDialog parent;
  ToeButton(ToeDialog parent) {
    <font color=#0000ff>this</font>.parent = parent;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics  g) {
    <font color=#0000ff>int</font> x1 = 0;
    <font color=#0000ff>int</font> y1 = 0;
    <font color=#0000ff>int</font> x2 = size().width - 1;
    <font color=#0000ff>int</font> y2 = size().height - 1;
    g.drawRect(x1, y1, x2, y2);
    x1 = x2/4;
    y1 = y2/4;
    <font color=#0000ff>int</font> wide = x2/2;
    <font color=#0000ff>int</font> high = y2/2;
    <font color=#0000ff>if</font>(state == ToeDialog.XX) {
      g.drawLine(x1, y1, x1 + wide, y1 + high);
      g.drawLine(x1, y1 + high, x1 + wide, y1);
    }
    <font color=#0000ff>if</font>(state == ToeDialog.OO) {
      g.drawOval(x1, y1, x1+wide/2, y1+high/2);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
  mouseDown(Event evt, <font color=#0000ff>int</font> x, <font color=#0000ff>int</font> y) {
    <font color=#0000ff>if</font>(state == ToeDialog.BLANK) {
      state = parent.turn;
      parent.turn= (parent.turn == ToeDialog.XX ?
        ToeDialog.OO : ToeDialog.XX);
    } 
    <font color=#0000ff>else</font>
      state = (state == ToeDialog.XX ? 
        ToeDialog.OO : ToeDialog.XX);
    repaint();
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
}

<font color=#0000ff>class</font> ToeDialog <font color=#0000ff>extends</font> Dialog {
  <font color=#009900>// w = number of cells wide</font>
  <font color=#009900>// h = number of cells high</font>
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> BLANK = 0;
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> XX = 1;
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> OO = 2;
  <font color=#0000ff>int</font> turn = XX; <font color=#009900>// Start with x's turn</font>
  <font color=#0000ff>public</font> ToeDialog(Frame parent, <font color=#0000ff>int</font> w, <font color=#0000ff>int</font> h) {
    <font color=#0000ff>super</font>(parent, <font color=#004488>"The game itself"</font>, <font color=#0000ff>false</font>);
    setLayout(<font color=#0000ff>new</font> GridLayout(w, h));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; w * h; i++)
      add(<font color=#0000ff>new</font> ToeButton(<font color=#0000ff>this</font>));
    resize(w * 50, h * 50);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> handleEvent(Event evt) {
    <font color=#0000ff>if</font>(evt.id == Event.WINDOW_DESTROY) 
      dispose();
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.handleEvent(evt);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ToeTest <font color=#0000ff>extends</font> Frame {
  TextField rows = <font color=#0000ff>new</font> TextField(<font color=#004488>"3"</font>);
  TextField cols = <font color=#0000ff>new</font> TextField(<font color=#004488>"3"</font>);
  <font color=#0000ff>public</font> ToeTest() {
    setTitle(<font color=#004488>"Toe Test"</font>);
    Panel p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> GridLayout(2,2));
    p.add(<font color=#0000ff>new</font> Label(<font color=#004488>"Rows"</font>, Label.CENTER));
    p.add(rows);
    p.add(<font color=#0000ff>new</font> Label(<font color=#004488>"Columns"</font>, Label.CENTER));
    p.add(cols);
    add(<font color=#004488>"North"</font>, p);
    add(<font color=#004488>"South"</font>, <font color=#0000ff>new</font> Button(<font color=#004488>"go"</font>));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> handleEvent(Event evt) {
    <font color=#0000ff>if</font>(evt.id == Event.WINDOW_DESTROY) 
      System.exit(0);
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.handleEvent(evt);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action(Event evt, Object arg) {
    <font color=#0000ff>if</font>(arg.equals(<font color=#004488>"go"</font>)) {
      Dialog d = <font color=#0000ff>new</font> ToeDialog(
        <font color=#0000ff>this</font>, 
        Integer.parseInt(rows.getText()),
        Integer.parseInt(cols.getText()));
      d.show();
    } 
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> ToeTest();
    f.resize(200,100);
    f.show();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>ToeButton</B> class keeps a
handle to its parent, which must be of type <B>ToeDialog</B>. As before, this
introduces high coupling because a <B>ToeButton</B> can be used only with a
<B>ToeDialog</B>, but it solves a number of problems, and in truth it
doesn&#8217;t seem like such a bad solution because there&#8217;s no other kind
of dialog that&#8217;s keeping track of whose turn it is. Of course, you can
take another approach, which is to make <B>ToeDialog.turn</B> a <B>static</B>
member of <B>ToeButton</B>. This eliminates the coupling, but prevents you from
having more than one <B>ToeDialog</B> at a time. (More than one that works
properly, anyway.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1789"></A><A NAME="Index1790"></A><B>paint(&#160;)</B> method is
concerned with the <A NAME="Index1791"></A><A NAME="Index1792"></A>graphics:
drawing the square around the button and drawing the &#8220;x&#8221; or the
&#8220;o.&#8221; This is full of tedious calculations, but it&#8217;s
straightforward. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A mouse click is captured by the
overridden
<A NAME="Index1793"></A><A NAME="Index1794"></A><B>mouseDown(&#160;)</B> method,
which first checks to see if the button has anything written on it. If not, the
parent window is queried to find out whose turn it is and that is used to
establish the state of the button. Note that the button then reaches back into
the parent and changes the turn. If the button is already displaying an
&#8220;x&#8221; or an &#8220;o&#8221; then that is flopped. You can see in these
calculations the convenient use of the ternary if-else described in Chapter 3.
After a button state change, the button is repainted.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor for
<B>ToeDialog</B> is quite simple: it adds into a <B>GridLayout</B> as many
buttons as you request, then resizes it for 50 pixels on a side for each button.
(If you don&#8217;t resize a <B>Window</B>, it won&#8217;t show up!) Note that
<B>handleEvent(&#160;)</B> just calls <B>dispose(&#160;)</B> for a
<B>WINDOW_DESTROY</B> so the whole application doesn&#8217;t go
away.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ToeTest</B> sets up the whole
application by creating the <B>TextField</B>s (for inputting the rows and
columns of the button grid) and the &#8220;go&#8221; button. You&#8217;ll see in
<B>action(&#160;)</B> that this program uses the less-desirable &#8220;string
match&#8221; technique for detecting the button press (make sure you get
spelling and capitalization right!). When the button is pressed, the data in the
<B>TextField</B>s must be fetched, and, since they are in <B>String</B> form,
turned into <B>int</B>s using the <B>static</B>
<A NAME="Index1795"></A><A NAME="Index1796"></A><B>Integer.parseInt(&#160;)</B>
method. Once the <B>Dialog</B> is created, the <B>show(&#160;)</B> method must
be called to display and activate it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that the
<B>ToeDialog</B> object is assigned to a <B>Dialog</B> handle <B>d</B>. This is
an example of upcasting, although it really doesn&#8217;t make much difference
here since all that&#8217;s happening is the <B>show(&#160;)</B> method is
called. However, if you wanted to call some method that existed only in
<B>ToeDialog</B> you would want to assign to a <B>ToeDialog</B> handle and not
lose the information in an upcast.</FONT><BR></P></DIV>
<A NAME="Heading421"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
File dialogs</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some operating systems have a
number of special built-in dialog boxes to handle the selection of things such
as fonts, colors, printers, and the like. Virtually all graphical operating
systems support the opening and saving of files, however, and so Java&#8217;s
<A NAME="Index1797"></A><A NAME="Index1798"></A><B>FileDialog</B> encapsulates
these for easy use. This, of course, makes no sense at all to use from an applet
since an applet can neither read nor write files on the local disk. (This will
change for trusted applets in newer browsers.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following application exercises
the two forms of file dialogs, one for opening and one for saving. Most of the
code should by now be familiar, and all the interesting activities happen in
<B>action(&#160;)</B> for the two different button clicks:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: FileDialogTest.java</font>
<font color=#009900>// Demonstration of File dialog boxes</font>
<font color=#0000ff>import</font> java.awt.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FileDialogTest <font color=#0000ff>extends</font> Frame {
  TextField filename = <font color=#0000ff>new</font> TextField();
  TextField directory = <font color=#0000ff>new</font> TextField();
  Button open = <font color=#0000ff>new</font> Button(<font color=#004488>"Open"</font>);
  Button save = <font color=#0000ff>new</font> Button(<font color=#004488>"Save"</font>);
  <font color=#0000ff>public</font> FileDialogTest() {
    setTitle(<font color=#004488>"File Dialog Test"</font>);
    Panel p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> FlowLayout());
    p.add(open);
    p.add(save);
    add(<font color=#004488>"South"</font>, p);
    directory.setEditable(<font color=#0000ff>false</font>);
    filename.setEditable(<font color=#0000ff>false</font>);
    p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> GridLayout(2,1));
    p.add(filename);
    p.add(directory);
    add(<font color=#004488>"North"</font>, p);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> handleEvent(Event evt) {
    <font color=#0000ff>if</font>(evt.id == Event.WINDOW_DESTROY) 
      System.exit(0);
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.handleEvent(evt);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> action(Event evt, Object arg) {
    <font color=#0000ff>if</font>(evt.target.equals(open)) {
      <font color=#009900>// Two arguments, defaults to open file:</font>
      FileDialog d = <font color=#0000ff>new</font> FileDialog(<font color=#0000ff>this</font>,
        <font color=#004488>"What file do you want to open?"</font>);
      d.setFile(<font color=#004488>"*.java"</font>); <font color=#009900>// Filename filter</font>
      d.setDirectory(<font color=#004488>"."</font>); <font color=#009900>// Current directory</font>
      d.show();
      String openFile;
      <font color=#0000ff>if</font>((openFile = d.getFile()) != <font color=#0000ff>null</font>) {
        filename.setText(openFile);
        directory.setText(d.getDirectory());
      } <font color=#0000ff>else</font> {
        filename.setText(<font color=#004488>"You pressed cancel"</font>);
        directory.setText(<font color=#004488>""</font>);
      }
    } 
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(evt.target.equals(save)) {
      FileDialog d = <font color=#0000ff>new</font> FileDialog(<font color=#0000ff>this</font>,
        <font color=#004488>"What file do you want to save?"</font>,
        FileDialog.SAVE);
      d.setFile(<font color=#004488>"*.java"</font>);
      d.setDirectory(<font color=#004488>"."</font>);
      d.show();
      String saveFile;
      <font color=#0000ff>if</font>((saveFile = d.getFile()) != <font color=#0000ff>null</font>) {
        filename.setText(saveFile);
        directory.setText(d.getDirectory());
      } <font color=#0000ff>else</font> {
        filename.setText(<font color=#004488>"You pressed cancel"</font>);
        directory.setText(<font color=#004488>""</font>);
      }
    } 
    <font color=#0000ff>else</font> 
      <font color=#0000ff>return</font> <font color=#0000ff>super</font>.action(evt, arg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> FileDialogTest();
    f.resize(250,110);
    f.show();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For an &#8220;open file&#8221;
dialog, you use the constructor that takes two arguments; the first is the
parent window handle and the second is the title for the title bar of the
<B>FileDialog</B>. The method
<A NAME="Index1799"></A><A NAME="Index1800"></A><B>setFile(&#160;)</B> provides
an initial file name &#8211; presumably the native OS supports wildcards, so in
this example all the <B>.java</B> files will initially be displayed. The
<A NAME="Index1801"></A><A NAME="Index1802"></A><B>setDirectory(&#160;)</B>
method chooses the directory where the file selection will begin. (In general,
the OS allows the user to change directories.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1803"></A><A NAME="Index1804"></A><B>show(&#160;)</B> command
doesn&#8217;t return until the dialog is closed. The <B>FileDialog</B> object
still exists, so you can read data from it. If you call
<A NAME="Index1805"></A><A NAME="Index1806"></A><B>getFile(&#160;)</B> and it
returns <B>null</B> it means the user canceled out of the dialog. Both the file
name and the results of
<A NAME="Index1807"></A><A NAME="Index1808"></A><B>getDirectory(&#160;)</B> are
displayed in the <B>TextField</B>s.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The button for saving works the
same way, except that it uses a different constructor for the <B>FileDialog</B>.
This constructor takes three arguments and the third argument must be either
<B>FileDialog.SAVE</B> or
<B>FileDialog.OPEN</B>.</FONT><A NAME="_Toc375545469"></A><A NAME="_Toc408018705"></A><BR></P></DIV>
<A NAME="Heading422"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The new AWT</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <A NAME="Index1809"></A>Java 1.1
a dramatic change has been accomplished in the creation of the new AWT. Most of
this change revolves around the
<A NAME="Index1810"></A><A NAME="Index1811"></A>new event model used in Java
1.1: as bad, awkward, and non-object-oriented as the old event model was, the
new event model is possibly the most elegant I have seen. It&#8217;s difficult
to understand how such a bad design (the old AWT) and such a good one (the new
event model) could come out of the same group. This new way of thinking about
events seems to drop so easily into your mind that the issue no longer becomes
an impediment; instead, it&#8217;s a tool that helps you design the system.
It&#8217;s also essential for Java Beans, described later in the
chapter.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Instead of the non-object-oriented
cascaded <B>if</B> statements in the old AWT, the new approach designates
objects as &#8220;sources&#8221; and &#8220;listeners&#8221; of events. As you
will see, the use of inner classes is integral to the object-oriented nature of
the new event model. In addition, events are now represented in a class
hierarchy instead of a single class, and you can create your own event
types.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll also find, if
you&#8217;ve programmed with the old AWT, that Java 1.1 has made a number of
what might seem like gratuitous name changes. For example,
<B>setSize(&#160;)</B> replaces <B>resize(&#160;)</B>. This will make sense when
you learn about Java Beans, because Beans use a particular naming convention.
The names had to be modified to make the standard AWT components into
Beans.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1 continues to support the
old AWT to ensure backward compatibility with existing programs. Without fully
admitting disaster, the online documents for Java 1.1 list all the problems
involved with programming the old AWT and describe how those problems are
addressed in the new AWT.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Clipboard operations are supported
in 1.1, although drag-and-drop &#8220;will be supported in a future
release.&#8221; You can access the desktop color scheme so your Java program can
fit in with the rest of the desktop. Pop-up menus are available, and there are
some improvements for graphics and images. Mouseless operation is supported.
There is a simple API for printing and simplified support for
scrolling.</FONT><A NAME="_Toc408018706"></A><BR></P></DIV>
<A NAME="Heading423"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The new event model</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the new event model a component
can initiate (&#8220;fire&#8221;) an event. Each type of event is represented by
a distinct class. When an event is fired, it is received by one or more
&#8220;listeners,&#8221; which act on that event. Thus, the source of an event
and the place where the event is handled can be separate.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each
<A NAME="Index1812"></A><A NAME="Index1813"></A>event listener is an object of a
class that implements a particular type of listener <B>interface</B>. So as a
programmer, all you do is create a listener object and register it with the
component that&#8217;s firing the event. This registration is performed by
calling a <B>addXXXListener(&#160;)</B> method in the event-firing component, in
which <B>XXX</B> represents the type of event listened for. You can easily know
what types of events can be handled by noticing the names of the
<A NAME="Index1814"></A><A NAME="Index1815"></A>addListener methods, and if you
try to listen for the wrong events you&#8217;ll find out your mistake at compile
time. Java Beans also uses the names of the addListener methods to determine
what a Bean can do.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All of your event logic, then, will
go inside a listener class. When you create a listener class, the sole
restriction is that it must implement the appropriate interface. You can create
a global listener class, but this is a situation in which
<A NAME="Index1816"></A><A NAME="Index1817"></A><A NAME="Index1818"></A>inner
classes tend to be quite useful, not only because they provide a logical
grouping of your listener classes inside the UI or business logic classes they
are serving, but because (as you shall see later) the fact that an inner class
object keeps a handle to its parent object provides a nice way to call across
class and subsystem boundaries.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A simple example will make this
clear. Consider the <B>Button2.java</B> example from earlier in this chapter.
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Button2New.java</font>
<font color=#009900>// Capturing button presses</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*; <font color=#009900>// Must add this</font>
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Button2New <font color=#0000ff>extends</font> Applet {
  Button
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 1"</font>),
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    b1.addActionListener(<font color=#0000ff>new</font> B1());
    b2.addActionListener(<font color=#0000ff>new</font> B2());
    add(b1);
    add(b2);
  }
  <font color=#0000ff>class</font> B1 <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      getAppletContext().showStatus(<font color=#004488>"Button 1"</font>);
    }
  }
  <font color=#0000ff>class</font> B2 <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      getAppletContext().showStatus(<font color=#004488>"Button 2"</font>);
    }
  }
  <font color=#009900>/* The old way:
  public boolean action(Event evt, Object arg) {
    if(evt.target.equals(b1))
      getAppletContext().showStatus("Button 1");
    else if(evt.target.equals(b2))
      getAppletContext().showStatus("Button 2");
    // Let the base class handle it:
    else 
      return super.action(evt, arg);
    return true; // We've handled it here
  }
  */</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So you can compare the two
approaches, the old code is left in as a comment. In <B>init(&#160;)</B>, the
only change is the addition of the two lines:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>b1.addActionListener(<font color=#0000ff>new</font> B1());
b2.addActionListener(<font color=#0000ff>new</font> B2());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>addActionListener(&#160;)</B>
tells a button which object to activate when the button is pressed. The classes
<B>B1</B> and <B>B2</B> are inner classes that implement the <B>interface
ActionListener</B>. This interface contains a single method
<B>actionPerformed(&#160;)</B> (meaning &#8220;This is the action that will be
performed when the event is fired&#8221;). Note that
<B>actionPerformed(&#160;)</B> does not take a generic event, but rather a
specific type of event, <B>ActionEvent</B>. So you don&#8217;t need to bother
testing and downcasting the argument if you want to extract specific
<B>ActionEvent</B> information.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the nicest things about
<B>actionPerformed(&#160;)</B> is how simple it is. It&#8217;s just a method
that gets called. Compare it to the old <B>action(&#160;)</B> method, in which
you must figure out what happened and act appropriately, and also worry about
calling the base class version of <B>action(&#160;)</B> and return a value to
indicate whether it&#8217;s been handled. With the new event model you know that
all the event-detection logic is taken care of so you don&#8217;t have to figure
that out; you just say what happens and you&#8217;re done. If you don&#8217;t
already prefer this approach over the old one, you will
soon.</FONT><A NAME="_Toc408018707"></A><BR></P></DIV>
<A NAME="Heading424"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Event and listener types</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the AWT components have been
changed to include <B>addXXXListener(&#160;)</B> and
<B>removeXXXListener(&#160;)</B> methods so that the appropriate types of
listeners can be added and removed from each component. You&#8217;ll notice that
the &#8220;<B>XXX</B>&#8221; in each case also represents the argument for the
method, for example, <B>addFooListener(FooListener fl)</B>. The following table
includes the associated events, listeners, methods, and the components that
support those particular events by providing the <B>addXXXListener(&#160;)</B>
and <B>removeXXXListener(&#160;)</B> methods.
<A NAME="Index1819"></A><A NAME="Index1820"></A><A NAME="Index1821"></A><A NAME="Index1822"></A></FONT><BR><A NAME="Index1823"></A><A NAME="Index1824"></A><A NAME="Index1825"></A><A NAME="Index1826"></A><A NAME="Index1827"></A><A NAME="Index1828"></A><A NAME="Index1829"></A><A NAME="Index1830"></A><A NAME="Index1831"></A><A NAME="Index1832"></A><A NAME="Index1833"></A><A NAME="Index1834"></A><A NAME="Index1835"></A><A NAME="Index1836"></A><A NAME="Index1837"></A><A NAME="Index1838"></A><A NAME="Index1839"></A><A NAME="Index1840"></A><A NAME="Index1841"></A><A NAME="Index1842"></A><A NAME="Index1843"></A><A NAME="Index1844"></A><A NAME="Index1845"></A><A NAME="Index1846"></A><A NAME="Index1847"></A><A NAME="Index1848"></A><A NAME="Index1849"></A><A NAME="Index1850"></A><A NAME="Index1851"></A><A NAME="Index1852"></A><A NAME="Index1853"></A><A NAME="Index1854"></A><A NAME="Index1855"></A><A NAME="Index1856"></A><A NAME="Index1857"></A><A NAME="Index1858"></A><A NAME="Index1859"></A><A NAME="Index1860"></A><A NAME="Index1861"></A><A NAME="Index1862"></A><A NAME="Index1863"></A><A NAME="Index1864"></A><A NAME="Index1865"></A><A NAME="Index1866"></A><A NAME="Index1867"></A><A NAME="Index1868"></A><A NAME="Index1869"></A><A NAME="Index1870"></A><A NAME="Index1871"></A><A NAME="Index1872"></A><A NAME="Index1873"></A><A NAME="Index1874"></A><A NAME="Index1875"></A><A NAME="Index1876"></A><A NAME="Index1877"></A><A NAME="Index1878"></A><A NAME="Index1879"></A><A NAME="Index1880"></A><A NAME="Index1881"></A><A NAME="Index1882"></A><A NAME="Index1883"></A><A NAME="Index1884"></A><A NAME="Index1885"></A><A NAME="Index1886"></A><A NAME="Index1887"></A><A NAME="Index1888"></A><A NAME="Index1889"></A><A NAME="Index1890"></A><A NAME="Index1891"></A><A NAME="Index1892"></A><A NAME="Index1893"></A><A NAME="Index1894"></A><A NAME="Index1895"></A><A NAME="Index1896"></A><A NAME="Index1897"></A><A NAME="Index1898"></A><A NAME="Index1899"></A><A NAME="Index1900"></A><A NAME="Index1901"></A><A NAME="Index1902"></A><A NAME="Index1903"></A><A NAME="Index1904"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=166 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Event, listener interface and add-
and remove-methods</FONT><BR></P></DIV>
</TH>
<TH WIDTH=175 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Components supporting this
event</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ActionEvent</B></FONT><BR><FONT FACE="Georgia"><B>ActionListener</B></FONT><BR><FONT FACE="Georgia"><B>addActionListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeActionListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Button</B>, <B>List</B>,<B>
TextField, MenuItem,</B> and its derivatives including <B>CheckboxMenuItem</B>,
<B>Menu,</B> and <B>PopupMenu</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>AdjustmentEvent</B></FONT><BR><FONT FACE="Georgia"><B>AdjustmentListener</B></FONT><BR><FONT FACE="Georgia"><B>addAdjustmentListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeAdjustmentListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Scrollbar</B></FONT><BR><FONT FACE="Georgia">Anything
you create that implements the <B>Adjustable</B> interface</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ComponentEvent</B></FONT><BR><FONT FACE="Georgia"><B>ComponentListener</B></FONT><BR><FONT FACE="Georgia"><B>addComponentListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeComponentListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Component</B> and its
derivatives, including <B>Button</B>, <B>Canvas</B>, <B>Checkbox</B>,
<B>Choice</B>,<B> Container</B>, <B>Panel</B>, <B>Applet</B>, <B>ScrollPane</B>,
<B>Window</B>, <B>Dialog</B>, <B>FileDialog, Frame</B>, <B>Label</B>,
<B>List</B>, <B>Scrollbar</B>, <B>TextArea,</B> and
<B>TextField</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerEvent</B></FONT><BR><FONT FACE="Georgia"><B>ContainerListener</B></FONT><BR><FONT FACE="Georgia"><B>addContainerListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeContainerListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Container</B> and its
derivatives, including <B>Panel</B>, <B>Applet</B>, <B>ScrollPane</B>,
<B>Window</B>, <B>Dialog</B>, <B>FileDialog,</B> and
<B>Frame</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FocusEvent</B></FONT><BR><FONT FACE="Georgia"><B>FocusListener</B></FONT><BR><FONT FACE="Georgia"><B>addFocusListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeFocusListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Component</B> and its
derivatives, including <B>Button</B>, <B>Canvas</B>, <B>Checkbox</B>,
<B>Choice</B>,<B> Container</B>, <B>Panel</B>, <B>Applet</B>, <B>ScrollPane</B>,
<B>Window</B>, <B>Dialog</B>, <B>FileDialog, Frame</B> <B>Label</B>,
<B>List</B>, <B>Scrollbar</B>, <B>TextArea,</B> and
<B>TextField</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>KeyEvent</B></FONT><BR><FONT FACE="Georgia"><B>KeyListener</B></FONT><BR><FONT FACE="Georgia"><B>addKeyListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeKeyListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Component</B> and its
derivatives, including <B>Button</B>, <B>Canvas</B>, <B>Checkbox</B>,
<B>Choice</B>,<B> Container</B>, <B>Panel</B>, <B>Applet</B>, <B>ScrollPane</B>,
<B>Window</B>, <B>Dialog</B>, <B>FileDialog, Frame</B>, <B>Label</B>,
<B>List</B>, <B>Scrollbar</B>, <B>TextArea,</B> and
<B>TextField</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>MouseEvent</B> (for both clicks
and
motion)</FONT><BR><FONT FACE="Georgia"><B>MouseListener</B></FONT><BR><FONT FACE="Georgia"><B>addMouseListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeMouseListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Component</B> and its
derivatives, including <B>Button</B>, <B>Canvas</B>, <B>Checkbox</B>,
<B>Choice</B>,<B> Container</B>, <B>Panel</B>, <B>Applet</B>, <B>ScrollPane</B>,
<B>Window</B>, <B>Dialog</B>, <B>FileDialog, Frame</B>, <B>Label</B>,
<B>List</B>, <B>Scrollbar</B>, <B>TextArea,</B> and
<B>TextField</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>MouseEvent</B></FONT><A NAME="fnB55" HREF="#fn55">[55]</A><FONT FACE="Georgia"><B>
</B>(for both clicks and
motion)</FONT><BR><FONT FACE="Georgia"><B>MouseMotionListener</B></FONT><BR><FONT FACE="Georgia"><B>addMouseMotionListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeMouseMotionListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Component</B> and its
derivatives, including <B>Button</B>, <B>Canvas</B>, <B>Checkbox</B>,
<B>Choice</B>,<B> Container</B>, <B>Panel</B>, <B>Applet</B>, <B>ScrollPane</B>,
<B>Window</B>, <B>Dialog</B>, <B>FileDialog, Frame</B>, <B>Label</B>,
<B>List</B>, <B>Scrollbar</B>, <B>TextArea, </B>and
<B>TextField</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>WindowEvent</B></FONT><BR><FONT FACE="Georgia"><B>WindowListener</B></FONT><BR><FONT FACE="Georgia"><B>addWindowListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeWindowListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Window</B> and its derivatives,
including <B>Dialog</B>, <B>FileDialog,</B> and <B>Frame</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ItemEvent</B></FONT><BR><FONT FACE="Georgia"><B>ItemListener</B></FONT><BR><FONT FACE="Georgia"><B>addItemListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeItemListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Checkbox</B>,
<B>CheckboxMenuItem</B>, <B>Choice</B>, <B>List,</B> and anything that
implements the <B>ItemSelectable</B> interface</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TextEvent</B></FONT><BR><FONT FACE="Georgia"><B>TextListener</B></FONT><BR><FONT FACE="Georgia"><B>addTextListener(&#160;)</B></FONT><BR><FONT FACE="Georgia"><B>removeTextListener(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Anything derived from
<B>TextComponent</B>, including <B>TextArea</B> and
<B>TextField</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that each type of
component supports only certain types of events. It&#8217;s helpful to see the
events supported by each component, as shown in the following table:
<A NAME="Index1905"></A><A NAME="Index1906"></A><A NAME="Index1907"></A><A NAME="Index1908"></A><A NAME="Index1909"></A><A NAME="Index1910"></A><A NAME="Index1911"></A><A NAME="Index1912"></A><A NAME="Index1913"></A><A NAME="Index1914"></A><A NAME="Index1915"></A><A NAME="Index1916"></A><A NAME="Index1917"></A><A NAME="Index1918"></A><A NAME="Index1919"></A><A NAME="Index1920"></A><A NAME="Index1921"></A><A NAME="Index1922"></A><A NAME="Index1923"></A><A NAME="Index1924"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=144 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Component type</FONT><BR></P></DIV>
</TH>
<TH WIDTH=198 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Events supported by this
component</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Adjustable</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>AdjustmentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Applet</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerEvent, FocusEvent,
KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Button</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ActionEvent, FocusEvent,
KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Canvas</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FocusEvent, KeyEvent,
MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Checkbox</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ItemEvent, FocusEvent, KeyEvent,
MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CheckboxMenuItem</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ActionEvent,
ItemEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Choice</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ItemEvent, FocusEvent, KeyEvent,
MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Component</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FocusEvent, KeyEvent,
MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Container</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerEvent, FocusEvent,
KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Dialog</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerEvent, WindowEvent,
FocusEvent, KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileDialog</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerEvent, WindowEvent,
FocusEvent, KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Frame</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerEvent, WindowEvent,
FocusEvent, KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Label</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FocusEvent, KeyEvent,
MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>List</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ActionEvent, FocusEvent,
KeyEvent, MouseEvent, ItemEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Menu</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ActionEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>MenuItem</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ActionEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Panel</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerEvent, FocusEvent,
KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PopupMenu</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ActionEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Scrollbar</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>AdjustmentEvent, FocusEvent,
KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ScrollPane</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerEvent, FocusEvent,
KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TextArea</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TextEvent, FocusEvent, KeyEvent,
MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TextComponent</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TextEvent, FocusEvent, KeyEvent,
MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TextField</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ActionEvent, TextEvent,
FocusEvent, KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Window</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerEvent, WindowEvent,
FocusEvent, KeyEvent, MouseEvent, ComponentEvent</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you know which events a
particular component supports, you don&#8217;t need to look anything up to react
to that event. You simply:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	Take the name of the event class and remove the
word &#8220;<B>Event</B>.&#8221; Add the word &#8220;<B>Listener</B>&#8221; to
what remains. This is the listener interface you need to implement in your inner
class. </FONT><LI><FONT FACE="Georgia">	Implement the interface above and
write out the methods for the events you want to capture. For example, you might
be looking for mouse movements, so you write code for the
<B>mouseMoved(&#160;)</B> method of the <B>MouseMotionListener</B> interface.
(You must implement the other methods, of course, but there&#8217;s a shortcut
for that which you&#8217;ll see
soon.)</FONT><LI><FONT FACE="Georgia">	Create an object of the listener
class in step 2. Register it with your component with the method produced by
prefixing &#8220;<B>add</B>&#8221; to your listener name. For example,
<B>addMouseMotionListener(&#160;)</B>.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To
finish what you need to know, here are the listener interfaces:
<A NAME="Index1925"></A><A NAME="Index1926"></A><A NAME="Index1927"></A><A NAME="Index1928"></A><A NAME="Index1929"></A><A NAME="Index1930"></A><A NAME="Index1931"></A><A NAME="Index1932"></A><A NAME="Index1933"></A><A NAME="Index1934"></A><A NAME="Index1935"></A><A NAME="Index1936"></A><A NAME="Index1937"></A><A NAME="Index1938"></A><A NAME="Index1939"></A><A NAME="Index1940"></A><A NAME="Index1941"></A><A NAME="Index1942"></A><A NAME="Index1943"></A><A NAME="Index1944"></A><A NAME="Index1945"></A><A NAME="Index1946"></A><A NAME="Index1947"></A><A NAME="Index1948"></A><A NAME="Index1949"></A><A NAME="Index1950"></A><A NAME="Index1951"></A><A NAME="Index1952"></A><A NAME="Index1953"></A><A NAME="Index1954"></A><A NAME="Index1955"></A><A NAME="Index1956"></A><A NAME="Index1957"></A><A NAME="Index1958"></A><A NAME="Index1959"></A><A NAME="Index1960"></A><A NAME="Index1961"></A><A NAME="Index1962"></A><A NAME="Index1963"></A><A NAME="Index1964"></A><A NAME="Index1965"></A><A NAME="Index1966"></A><A NAME="Index1967"></A><A NAME="Index1968"></A><A NAME="Index1969"></A><A NAME="Index1970"></A><A NAME="Index1971"></A><A NAME="Index1972"></A><A NAME="Index1973"></A><A NAME="Index1974"></A><A NAME="Index1975"></A><A NAME="Index1976"></A><A NAME="Index1977"></A><A NAME="Index1978"></A><A NAME="Index1979"></A><A NAME="Index1980"></A><A NAME="Index1981"></A><A NAME="Index1982"></A><A NAME="Index1983"></A><A NAME="Index1984"></A><A NAME="Index1985"></A><A NAME="Index1986"></A><A NAME="Index1987"></A><A NAME="Index1988"></A><A NAME="Index1989"></A><A NAME="Index1990"></A><A NAME="Index1991"></A><A NAME="Index1992"></A><A NAME="Index1993"></A><A NAME="Index1994"></A><A NAME="Index1995"></A><A NAME="Index1996"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=121 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Listener
interface</FONT><BR><FONT FACE="Georgia">w/ adapter</FONT><BR></P></DIV>
</TH>
<TH WIDTH=220 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Methods in
interface</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ActionListener</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>actionPerformed(ActionEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>AdjustmentListener</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>adjustmentValueChanged(</B></FONT><BR><FONT FACE="Georgia"><B>
AdjustmentEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ComponentListener</B></FONT><BR><FONT FACE="Georgia"><B>ComponentAdapter</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>componentHidden(ComponentEvent)</B></FONT><BR><FONT FACE="Georgia"><B>componentShown(ComponentEvent)</B></FONT><BR><FONT FACE="Georgia"><B>componentMoved(ComponentEvent)</B></FONT><BR><FONT FACE="Georgia"><B>componentResized(ComponentEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ContainerListener</B></FONT><BR><FONT FACE="Georgia"><B>ContainerAdapter</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>componentAdded(ContainerEvent)</B></FONT><BR><FONT FACE="Georgia"><B>componentRemoved(ContainerEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FocusListener</B></FONT><BR><FONT FACE="Georgia"><B>FocusAdapter</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>focusGained(FocusEvent)</B></FONT><BR><FONT FACE="Georgia"><B>focusLost(FocusEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>KeyListener</B></FONT><BR><FONT FACE="Georgia"><B>KeyAdapter</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>keyPressed(KeyEvent)</B></FONT><BR><FONT FACE="Georgia"><B>keyReleased(KeyEvent)</B></FONT><BR><FONT FACE="Georgia"><B>keyTyped(KeyEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>MouseListener</B></FONT><BR><FONT FACE="Georgia"><B>MouseAdapter</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>mouseClicked(MouseEvent)</B></FONT><BR><FONT FACE="Georgia"><B>mouseEntered(MouseEvent)</B></FONT><BR><FONT FACE="Georgia"><B>mouseExited(MouseEvent)</B></FONT><BR><FONT FACE="Georgia"><B>mousePressed(MouseEvent)</B></FONT><BR><FONT FACE="Georgia"><B>mouseReleased(MouseEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>MouseMotionListener</B></FONT><BR><FONT FACE="Georgia"><B>MouseMotionAdapter</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>mouseDragged(MouseEvent)</B></FONT><BR><FONT FACE="Georgia"><B>mouseMoved(MouseEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>WindowListener</B></FONT><BR><FONT FACE="Georgia"><B>WindowAdapter</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>windowOpened(WindowEvent)</B></FONT><BR><FONT FACE="Georgia"><B>windowClosing(WindowEvent)
</B></FONT><BR><FONT FACE="Georgia"><B>windowClosed(WindowEvent)
</B></FONT><BR><FONT FACE="Georgia"><B>windowActivated(WindowEvent)
</B></FONT><BR><FONT FACE="Georgia"><B>windowDeactivated(WindowEvent)
</B></FONT><BR><FONT FACE="Georgia"><B>windowIconified(WindowEvent)
</B></FONT><BR><FONT FACE="Georgia"><B>windowDeiconified(WindowEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ItemListener</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>itemStateChanged(ItemEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TextListener</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>textValueChanged(TextEvent)</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<A NAME="Heading425"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Using listener adapters for
simplicity<BR><A NAME="Index1997"></A><A NAME="Index1998"></A><A NAME="Index1999"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the table above, you can see
that some listener interfaces have only one method. These are trivial to
implement since you&#8217;ll implement them only when you want to write that
particular method. However, the listener interfaces that have multiple methods
could be less pleasant to use. For example, something you must always do when
creating an application is provide a <B>WindowListener</B> to the <B>Frame</B>
so that when you get the <B>windowClosing(&#160;)</B> event you can call
<B>System.exit(0)</B> to exit the application. But since <B>WindowListener</B>
is an <B>interface</B>, you must implement all of the other methods even if they
don&#8217;t do anything. This can be annoying.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To solve the problem, each of the
listener interfaces that have more than one method are provided with
<I>adapters</I>, the names of which you can see in the table above. Each adapter
provides default methods for each of the interface methods. (Alas,
<B>WindowAdapter</B> does <I>not</I> have a default <B>windowClosing(&#160;)</B>
that calls <B>System.exit(0)</B>.) Then all you need to do is inherit from the
adapter and override only the methods you need to change. For example, the
typical <B>WindowListener</B> you&#8217;ll use looks like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> MyWindowListener <font color=#0000ff>extends</font> WindowAdapter {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
    System.exit(0);
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The whole point of the adapters is
to make the creation of listener classes easy.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is a downside to adapters,
however, in the form of a pitfall. Suppose you write a <B>WindowAdapter</B> like
the one above:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> MyWindowListener <font color=#0000ff>extends</font> WindowAdapter {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> WindowClosing(WindowEvent e) {
    System.exit(0);
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This doesn&#8217;t work, but it
will drive you crazy trying to figure out why, since everything will compile and
run fine &#8211; except that closing the window won&#8217;t exit the program.
Can you see the problem? It&#8217;s in the name of the method:
<B>WindowClosing(&#160;)</B> instead of <B>windowClosing(&#160;)</B>. A simple
slip in capitalization results in the addition of a completely new method.
However, this is not the method that&#8217;s called when the window is closing,
so you don&#8217;t get the desired
results.</FONT><A NAME="_Toc408018708"></A><BR></P></DIV>
<A NAME="Heading426"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Making windows and applets <BR>with the Java 1.1
AWT<BR><A NAME="Index2000"></A><A NAME="Index2001"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Often you&#8217;ll want to be able
to create a class that can be invoked as either a window or an applet. To
accomplish this, you simply add a <B>main(&#160;)</B> to your applet that builds
an instance of the applet inside a <B>Frame</B>. As a simple example,
let&#8217;s look at <B>Button2New.java</B> modified to work as both an
application and an applet:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Button2NewB.java</font>
<font color=#009900>// An application and an applet</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*; <font color=#009900>// Must add this</font>
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Button2NewB <font color=#0000ff>extends</font> Applet {
  Button
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 1"</font>),
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 2"</font>);
  TextField t = <font color=#0000ff>new</font> TextField(20);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    b1.addActionListener(<font color=#0000ff>new</font> B1());
    b2.addActionListener(<font color=#0000ff>new</font> B2());
    add(b1);
    add(b2);
    add(t);
  }
  <font color=#0000ff>class</font> B1 <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t.setText(<font color=#004488>"Button 1"</font>);
    }
  }
  <font color=#0000ff>class</font> B2 <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t.setText(<font color=#004488>"Button 2"</font>);
    }
  }
  <font color=#009900>// To close the application:</font>
  <font color=#0000ff>static</font> <font color=#0000ff>class</font> WL <font color=#0000ff>extends</font> WindowAdapter {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
      System.exit(0);
    }
  }
  <font color=#009900>// A main() for the application:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Button2NewB applet = <font color=#0000ff>new</font> Button2NewB();
    Frame aFrame = <font color=#0000ff>new</font> Frame(<font color=#004488>"Button2NewB"</font>);
    aFrame.addWindowListener(<font color=#0000ff>new</font> WL());
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The inner class <B>WL</B> and the
<B>main(&#160;)</B> are the only two elements added to the applet, and the rest
of the applet is untouched. In fact, you can usually copy and paste the
<B>WL</B> class and <B>main(&#160;)</B> into your own applets with little
modification. The <B>WL </B>class is <B>static </B>so it can be easily created
in <B>main(&#160;). </B>(Remember that an inner class normally needs an outer
class handle when it&#8217;s created. Making it <B>static</B> eliminates this
need.)<B> </B>You can see that in <B>main(&#160;)</B>, the applet is explicitly
initialized and started since in this case the browser isn&#8217;t available to
do it for you. Of course, this doesn&#8217;t provide the full behavior of the
browser, which also calls <B>stop(&#160;)</B> and <B>destroy(&#160;)</B>, but
for most situations it&#8217;s acceptable. If it&#8217;s a problem, you
can:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	Make the handle <B>applet</B> a <B>static</B>
member of the class (instead of a local variable of <B>main(&#160;)</B>), and
then:</FONT><LI><FONT FACE="Georgia">	Call <B>applet.stop(&#160;)</B> and
<B>applet.destroy(&#160;)</B> inside <B>WindowAdapter.windowClosing(&#160;)</B>
before you call
<B>System.exit(&#160;)</B>.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice
the last line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>aFrame.setVisible(<font color=#0000ff>true</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is one of the changes in the
Java 1.1<A NAME="Index2002"></A> AWT. The <B>show(&#160;)</B> method is
deprecated and <B>setVisible(true)</B> replaces it. These sorts of seemingly
capricious changes will make more sense when you learn about Java Beans later in
the chapter.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example is also modified to
use a <B>TextField</B> rather than printing to the console or to the browser
status line. One restriction in making a program that&#8217;s both an applet and
an application is that you must choose input and output forms that work for both
situations.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s another small new
feature of the Java 1.1<A NAME="Index2003"></A> AWT shown here. You no longer
need to use the error-prone approach of specifying
<A NAME="Index2004"></A><A NAME="Index2005"></A><B>BorderLayout </B>positions
using a <B>String</B>. When adding an element to a <B>BorderLayout</B> in Java
1.1<A NAME="Index2006"></A>, you can say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>aFrame.add(applet, BorderLayout.CENTER);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You name the location with one of
the <B>BorderLayout</B> constants, which can then be checked at compile-time
(rather than just quietly doing the wrong thing, as with the old form). This is
a definite improvement, and will be used throughout the rest of the
book.</FONT><BR></P></DIV>
<A NAME="Heading427"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Making the window listener<BR>an anonymous class</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any of the listener classes could
be implemented as <A NAME="Index2007"></A><A NAME="Index2008"></A>anonymous
classes, but there&#8217;s always a chance that you might want to use their
functionality elsewhere. However, the window listener is used here only to close
the application&#8217;s window so you can safely make it an anonymous class.
Then, in <B>main(&#160;)</B>, the line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>aFrame.addWindowListener(<font color=#0000ff>new</font> WL());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">will become:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>aFrame.addWindowListener(
  <font color=#0000ff>new</font> WindowAdapter() {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
      System.exit(0);
    }
  });</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This has the advantage that it
doesn&#8217;t require yet another class name. You must decide for yourself
whether it makes the code easier to understand or more difficult. However, for
the remainder of the book an anonymous inner class will usually be used for the
window listener.</FONT><BR></P></DIV>
<A NAME="Heading428"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Packaging the applet into a JAR file</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An important
<A NAME="Index2009"></A><A NAME="Index2010"></A><A NAME="Index2011"></A>JAR use
is to optimize applet loading. In Java 1.0, people tended to try to cram all
their code into a single <B>Applet</B> class so the client would need only a
single server hit to download the applet code. Not only did this result in
messy, hard to read (and maintain) programs, but the <B>.class</B> file was
still uncompressed so downloading wasn&#8217;t as fast as it could have
been.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">JAR files change all of that by
compressing all of your <B>.class</B> files into a single file that is
downloaded by the browser. Now you don&#8217;t need to create an ugly design to
minimize the number of classes you create, and the user will get a much faster
download time.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider the example above. It
looks like <B>Button2NewB</B> is a single class, but in fact it contains three
inner classes, so that&#8217;s four in all. Once you&#8217;ve compiled the
program, you package it into a JAR file with the line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cf Button2NewB.jar *.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This assumes that the only
<B>.class</B> files in the current directory are the ones from
<B>Button2NewB</B>.<B>java</B> (otherwise you&#8217;ll get extra
baggage).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now you can create an HTML page
with the new
<A NAME="Index2012"></A><A NAME="Index2013"></A><A NAME="Index2014"></A><A NAME="Index2015"></A><B>archive</B>
tag to indicate the name of the JAR file, like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;head&gt;&lt;title&gt;Button2NewB Example Applet
&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;applet code=<font color=#004488>"Button2NewB.class"</font> 
        archive=<font color=#004488>"Button2NewB.jar"</font> 
        width=200 height=150&gt;
&lt;/applet&gt;
&lt;/body&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Everything else about applet tags
in HTML files remains the same.</FONT><A NAME="_Toc408018709"></A><BR></P></DIV>
<A NAME="Heading429"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Revisiting the earlier examples</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To see a number of examples using
the new event model and to study the way a program can be converted from the old
to the new event model, the following examples revisit many of the issues
demonstrated in the first part of this chapter using the old event model. In
addition, each program is now both an applet and an application so you can run
it with or without a browser.</FONT><BR></P></DIV>
<A NAME="Heading430"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Text fields</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is similar to
<B>TextField1.java</B>, but it adds significant extra behavior:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: TextNew.java</font>
<font color=#009900>// Text fields with Java 1.1 events</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TextNew <font color=#0000ff>extends</font> Applet {
  Button 
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Get Text"</font>), 
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Set Text"</font>);
  TextField 
    t1 = <font color=#0000ff>new</font> TextField(30),
    t2 = <font color=#0000ff>new</font> TextField(30),
    t3 = <font color=#0000ff>new</font> TextField(30);
  String s = <font color=#0000ff>new</font> String();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    b1.addActionListener(<font color=#0000ff>new</font> B1());
    b2.addActionListener(<font color=#0000ff>new</font> B2());
    t1.addTextListener(<font color=#0000ff>new</font> T1());
    t1.addActionListener(<font color=#0000ff>new</font> T1A());
    t1.addKeyListener(<font color=#0000ff>new</font> T1K());
    add(b1);
    add(b2);
    add(t1);
    add(t2);
    add(t3);
  }
  <font color=#0000ff>class</font> T1 <font color=#0000ff>implements</font> TextListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> textValueChanged(TextEvent e) {
      t2.setText(t1.getText());
    }
  }
  <font color=#0000ff>class</font> T1A <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> count = 0;
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t3.setText(<font color=#004488>"t1 Action Event "</font> + count++);
    }
  }
  <font color=#0000ff>class</font> T1K <font color=#0000ff>extends</font> KeyAdapter {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> keyTyped(KeyEvent e) {
      String ts = t1.getText();
      <font color=#0000ff>if</font>(e.getKeyChar() == 
          KeyEvent.VK_BACK_SPACE) {
        <font color=#009900>// Ensure it's not empty:</font>
        <font color=#0000ff>if</font>( ts.length() &gt; 0) {
          ts = ts.substring(0, ts.length() - 1);
          t1.setText(ts);
        }
      } 
      <font color=#0000ff>else</font>
        t1.setText(
          t1.getText() +
            Character.toUpperCase(
              e.getKeyChar()));
      t1.setCaretPosition(
        t1.getText().length());
      <font color=#009900>// Stop regular character from appearing:</font>
      e.consume(); 
    }
  }
  <font color=#0000ff>class</font> B1 <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      s = t1.getSelectedText();
      <font color=#0000ff>if</font>(s.length() == 0) s = t1.getText();
      t1.setEditable(<font color=#0000ff>true</font>);
    }
  }
  <font color=#0000ff>class</font> B2 <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t1.setText(<font color=#004488>"Inserted by Button 2: "</font> + s);
      t1.setEditable(<font color=#0000ff>false</font>);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    TextNew applet = <font color=#0000ff>new</font> TextNew();
    Frame aFrame = <font color=#0000ff>new</font> Frame(<font color=#004488>"TextNew"</font>);
    aFrame.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index2016"></A><A NAME="Index2017"></A><B>TextField t3</B> is included
as a place to report when the action listener for the <B>TextField</B> <B>t1</B>
is fired. You&#8217;ll see that the action listener for a <B>TextField</B> is
fired only when you press the &#8220;enter&#8221; key.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>TextField t1</B> has several
listeners attached to it. The <B>T1</B> listener copies all text from <B>t1</B>
into <B>t2</B> and the <B>T1K</B> listener forces all characters to upper case.
You&#8217;ll notice that the two work together, and if you add the <B>T1K</B>
listener <I>after</I> you add the <B>T1</B> listener, it doesn&#8217;t matter:
all characters will still be forced to upper case in both text fields. It would
seem that keyboard events are always fired before
<A NAME="Index2018"></A><A NAME="Index2019"></A><B>TextComponent</B> events, and
if you want the characters in <B>t2</B> to retain the original case that was
typed in, you must do some extra work.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>T1K</B> has some other
activities of interest. You must detect a backspace (since you&#8217;re
controlling everything now) and perform the deletion. The caret must be
explicitly set to the end of the field; otherwise it won&#8217;t behave as you
expect. Finally, to prevent the original character from being handled by the
default mechanism, the event must be &#8220;consumed&#8221; using the
<A NAME="Index2020"></A><A NAME="Index2021"></A><B>consume(&#160;)</B> method
that exists for event objects. This tells the system to stop firing the rest of
the event handlers for this particular event.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example also quietly
demonstrates one of the benefits of the design of inner classes. Note that in
the <A NAME="Index2022"></A><A NAME="Index2023"></A>inner
class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>class</font> T1 <font color=#0000ff>implements</font> TextListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> textValueChanged(TextEvent e) {
      t2.setText(t1.getText());
    }
  }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>t1</B> and <B>t2</B> are
<I>not</I> members of <B>T1</B>, and yet they&#8217;re accessible without any
special qualification. This is because an object of an inner class automatically
captures a handle to the outer object that created it, so you can treat members
and methods of the enclosing class object as if they&#8217;re yours. As you can
see, this is quite
convenient.</FONT><A NAME="fnB56" HREF="#fn56">[56]</A><BR></P></DIV>
<A NAME="Heading431"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Text areas</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most significant change to text
areas in Java 1.1<A NAME="Index2024"></A> concerns scroll bars. With the
<A NAME="Index2025"></A><A NAME="Index2026"></A><B>TextArea </B>constructor, you
can now control whether a <B>TextArea</B> will have scroll bars: vertical,
horizontal, both, or neither. This example modifies the earlier Java
1.0<A NAME="Index2027"></A> <B>TextArea1.java</B> to show the Java 1.1 scrollbar
constructors:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: TextAreaNew.java</font>
<font color=#009900>// Controlling scrollbars with the TextArea</font>
<font color=#009900>// component in Java 1.1</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TextAreaNew <font color=#0000ff>extends</font> Applet {
  Button b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Text Area 1"</font>);
  Button b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Text Area 2"</font>);
  Button b3 = <font color=#0000ff>new</font> Button(<font color=#004488>"Replace Text"</font>);
  Button b4 = <font color=#0000ff>new</font> Button(<font color=#004488>"Insert Text"</font>);
  TextArea t1 = <font color=#0000ff>new</font> TextArea(<font color=#004488>"t1"</font>, 1, 30);
  TextArea t2 = <font color=#0000ff>new</font> TextArea(<font color=#004488>"t2"</font>, 4, 30);
  TextArea t3 = <font color=#0000ff>new</font> TextArea(<font color=#004488>"t3"</font>, 1, 30,
    TextArea.SCROLLBARS_NONE);
  TextArea t4 = <font color=#0000ff>new</font> TextArea(<font color=#004488>"t4"</font>, 10, 10,
    TextArea.SCROLLBARS_VERTICAL_ONLY);
  TextArea t5 = <font color=#0000ff>new</font> TextArea(<font color=#004488>"t5"</font>, 4, 30,
    TextArea.SCROLLBARS_HORIZONTAL_ONLY);
  TextArea t6 = <font color=#0000ff>new</font> TextArea(<font color=#004488>"t6"</font>, 10, 10,
    TextArea.SCROLLBARS_BOTH);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    b1.addActionListener(<font color=#0000ff>new</font> B1L());
    add(b1);
    add(t1);
    b2.addActionListener(<font color=#0000ff>new</font> B2L());
    add(b2);
    add(t2);
    b3.addActionListener(<font color=#0000ff>new</font> B3L());
    add(b3);
    b4.addActionListener(<font color=#0000ff>new</font> B4L());
    add(b4);
    add(t3); add(t4); add(t5); add(t6);
  }
  <font color=#0000ff>class</font> B1L <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t5.append(t1.getText() + <font color=#004488>"\n"</font>);
    }
  }
  <font color=#0000ff>class</font> B2L <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t2.setText(<font color=#004488>"Inserted by Button 2"</font>);
      t2.append(<font color=#004488>": "</font> + t1.getText());
      t5.append(t2.getText() + <font color=#004488>"\n"</font>);
    }
  }
  <font color=#0000ff>class</font> B3L <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      String s = <font color=#004488>" Replacement "</font>;
      t2.replaceRange(s, 3, 3 + s.length());
    }
  }
  <font color=#0000ff>class</font> B4L <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t2.insert(<font color=#004488>" Inserted "</font>, 10);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    TextAreaNew applet = <font color=#0000ff>new</font> TextAreaNew();
    Frame aFrame = <font color=#0000ff>new</font> Frame(<font color=#004488>"TextAreaNew"</font>);
    aFrame.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,725);
    applet.init();
    applet.start();
    aFrame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that you can
control the scrollbars only at the time of construction of the <B>TextArea</B>.
Also, even if a <B>TextArea</B> doesn&#8217;t have a scrollbar, you can move the
cursor such that scrolling will be forced. (You can see this behavior by playing
with the example.)</FONT><BR></P></DIV>
<A NAME="Heading432"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Check boxes and radio buttons</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As noted previously, check boxes
and radio buttons are both created with the same class,
<A NAME="Index2028"></A><A NAME="Index2029"></A><B>Checkbox</B>, but radio
buttons are <B>Checkbox</B>es placed into a <B>CheckboxGroup</B>. In either
case, the interesting event is
<A NAME="Index2030"></A><A NAME="Index2031"></A><B>ItemEvent</B>, for which you
create an
<A NAME="Index2032"></A><A NAME="Index2033"></A><B>ItemListener</B>.</FONT><A NAME="AAAIndexingCurrentPoint"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When dealing with a group of check
boxes or radio buttons, you have a choice. You can either create a new inner
class to handle the event for each different <B>Checkbox</B> or you can create
one inner class that determines which <B>Checkbox</B> was clicked and register a
single object of that inner class with each <B>Checkbox</B> object. The
following example shows both approaches:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: RadioCheckNew.java</font>
<font color=#009900>// Radio buttons and Check Boxes in Java 1.1</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> RadioCheckNew <font color=#0000ff>extends</font> Applet {
  TextField t = <font color=#0000ff>new</font> TextField(30);
  Checkbox[] cb = {
    <font color=#0000ff>new</font> Checkbox(<font color=#004488>"Check Box 1"</font>),
    <font color=#0000ff>new</font> Checkbox(<font color=#004488>"Check Box 2"</font>),
    <font color=#0000ff>new</font> Checkbox(<font color=#004488>"Check Box 3"</font>) };
  CheckboxGroup g = <font color=#0000ff>new</font> CheckboxGroup();
  Checkbox 
    cb4 = <font color=#0000ff>new</font> Checkbox(<font color=#004488>"four"</font>, g, <font color=#0000ff>false</font>),
    cb5 = <font color=#0000ff>new</font> Checkbox(<font color=#004488>"five"</font>, g, <font color=#0000ff>true</font>),
    cb6 = <font color=#0000ff>new</font> Checkbox(<font color=#004488>"six"</font>, g, <font color=#0000ff>false</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    t.setEditable(<font color=#0000ff>false</font>);
    add(t); 
    ILCheck il = <font color=#0000ff>new</font> ILCheck();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cb.length; i++) {
      cb[i].addItemListener(il);
      add(cb[i]);
    }
    cb4.addItemListener(<font color=#0000ff>new</font> IL4());
    cb5.addItemListener(<font color=#0000ff>new</font> IL5());
    cb6.addItemListener(<font color=#0000ff>new</font> IL6());
    add(cb4); add(cb5); add(cb6); 
  }
  <font color=#009900>// Checking the source:</font>
  <font color=#0000ff>class</font> ILCheck <font color=#0000ff>implements</font> ItemListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> itemStateChanged(ItemEvent e) {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cb.length; i++) {
        <font color=#0000ff>if</font>(e.getSource().equals(cb[i])) {
          t.setText(<font color=#004488>"Check box "</font> + (i + 1));
          <font color=#0000ff>return</font>;
        }
      }
    }
  }
  <font color=#009900>// vs. an individual class for each item:</font>
  <font color=#0000ff>class</font> IL4 <font color=#0000ff>implements</font> ItemListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> itemStateChanged(ItemEvent e) {
      t.setText(<font color=#004488>"Radio button four"</font>);
    }
  }
  <font color=#0000ff>class</font> IL5 <font color=#0000ff>implements</font> ItemListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> itemStateChanged(ItemEvent e) {
      t.setText(<font color=#004488>"Radio button five"</font>);
    }
  }
  <font color=#0000ff>class</font> IL6 <font color=#0000ff>implements</font> ItemListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> itemStateChanged(ItemEvent e) {
      t.setText(<font color=#004488>"Radio button six"</font>);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    RadioCheckNew applet = <font color=#0000ff>new</font> RadioCheckNew();
    Frame aFrame = <font color=#0000ff>new</font> Frame(<font color=#004488>"RadioCheckNew"</font>);
    aFrame.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ILCheck</B> has the advantage
that it automatically adapts when you add or subtract <B>Checkbox</B>es. Of
course, you can use this with radio buttons as well. It should be used, however,
only when your logic is general enough to support this approach. Otherwise
you&#8217;ll end up with a cascaded <B>if</B> statement, a sure sign that you
should revert to using independent listener classes.</FONT><BR></P></DIV>
<A NAME="Heading433"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Drop-down lists</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Drop-down lists
(<A NAME="Index2034"></A><A NAME="Index2035"></A><B>Choice</B>) in Java
1.1<A NAME="Index2036"></A> also use <B>ItemListener</B>s to notify you when a
choice has changed:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ChoiceNew.java</font>
<font color=#009900>// Drop-down lists with Java 1.1</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ChoiceNew <font color=#0000ff>extends</font> Applet {
  String[] description = { <font color=#004488>"Ebullient"</font>, <font color=#004488>"Obtuse"</font>,
    <font color=#004488>"Recalcitrant"</font>, <font color=#004488>"Brilliant"</font>, <font color=#004488>"Somnescent"</font>,
    <font color=#004488>"Timorous"</font>, <font color=#004488>"Florid"</font>, <font color=#004488>"Putrescent"</font> };
  TextField t = <font color=#0000ff>new</font> TextField(100);
  Choice c = <font color=#0000ff>new</font> Choice();
  Button b = <font color=#0000ff>new</font> Button(<font color=#004488>"Add items"</font>);
  <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    t.setEditable(<font color=#0000ff>false</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 4; i++)
      c.addItem(description[count++]);
    add(t);
    add(c);
    add(b);
    c.addItemListener(<font color=#0000ff>new</font> CL());
    b.addActionListener(<font color=#0000ff>new</font> BL());
  }
  <font color=#0000ff>class</font> CL <font color=#0000ff>implements</font> ItemListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> itemStateChanged(ItemEvent e) {
      t.setText(<font color=#004488>"index: "</font> +  c.getSelectedIndex()
        + <font color=#004488>"   "</font> + e.toString());
    }
  }
  <font color=#0000ff>class</font> BL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>if</font>(count &lt; description.length)
        c.addItem(description[count++]);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ChoiceNew applet = <font color=#0000ff>new</font> ChoiceNew();
    Frame aFrame = <font color=#0000ff>new</font> Frame(<font color=#004488>"ChoiceNew"</font>);
    aFrame.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(750,100);
    applet.init();
    applet.start();
    aFrame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Nothing else here is particularly
new (except that Java 1.1<A NAME="Index2037"></A> has significantly fewer bugs
in the UI classes).</FONT><BR></P></DIV>
<A NAME="Heading434"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Lists</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll recall that one of the
problems with the Java 1.0<A NAME="Index2038"></A>
<A NAME="Index2039"></A><A NAME="Index2040"></A><B>List</B> design is that it
took extra work to make it do what you&#8217;d expect: react to a single click
on one of the list elements. Java 1.1<A NAME="Index2041"></A> has solved this
problem:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ListNew.java</font>
<font color=#009900>// Java 1.1 Lists are easier to use</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListNew <font color=#0000ff>extends</font> Applet {
  String[] flavors = { <font color=#004488>"Chocolate"</font>, <font color=#004488>"Strawberry"</font>,
    <font color=#004488>"Vanilla Fudge Swirl"</font>, <font color=#004488>"Mint Chip"</font>, 
    <font color=#004488>"Mocha Almond Fudge"</font>, <font color=#004488>"Rum Raisin"</font>, 
    <font color=#004488>"Praline Cream"</font>, <font color=#004488>"Mud Pie"</font> };
  <font color=#009900>// Show 6 items, allow multiple selection:</font>
  List lst = <font color=#0000ff>new</font> List(6, <font color=#0000ff>true</font>);
  TextArea t = <font color=#0000ff>new</font> TextArea(flavors.length, 30);
  Button b = <font color=#0000ff>new</font> Button(<font color=#004488>"test"</font>);
  <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    t.setEditable(<font color=#0000ff>false</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 4; i++)
      lst.addItem(flavors[count++]);
    add(t);
    add(lst);
    add(b);
    lst.addItemListener(<font color=#0000ff>new</font> LL());
    b.addActionListener(<font color=#0000ff>new</font> BL());
  }
  <font color=#0000ff>class</font> LL <font color=#0000ff>implements</font> ItemListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> itemStateChanged(ItemEvent e) {
      t.setText(<font color=#004488>""</font>);
      String[] items = lst.getSelectedItems();
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; items.length; i++)
        t.append(items[i] + <font color=#004488>"\n"</font>);
    }
  }
  <font color=#0000ff>class</font> BL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>if</font>(count &lt; flavors.length)
        lst.addItem(flavors[count++], 0);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ListNew applet = <font color=#0000ff>new</font> ListNew();
    Frame aFrame = <font color=#0000ff>new</font> Frame(<font color=#004488>"ListNew"</font>);
    aFrame.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that no extra logic is
required to support a single click on a list item. You just attach a listener
like you do everywhere else.</FONT><BR></P></DIV>
<A NAME="Heading435"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Menus</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The event handling for menus does
seem to benefit from the Java 1.1<A NAME="Index2042"></A> event model, but
Java&#8217;s approach to menus is still messy and requires a lot of hand coding.
The right medium for a menu seems to be a resource rather than a lot of code.
Keep in mind that program-building tools will generally handle the creation of
menus for you, so that will reduce the pain somewhat (as long as they will also
handle the maintenance!).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, you&#8217;ll find the
events for menus are inconsistent and can lead to confusion:
<A NAME="Index2043"></A><A NAME="Index2044"></A><B>MenuItem</B>s use
<B>ActionListener</B>s, but
<A NAME="Index2045"></A><A NAME="Index2046"></A><B>CheckboxMenuItem</B>s use
<B>ItemListener</B>s. The
<A NAME="Index2047"></A><A NAME="Index2048"></A><B>Menu</B> objects can also
support <B>ActionListener</B>s, but that&#8217;s not usually helpful. In
general, you&#8217;ll attach listeners to each <B>MenuItem</B> or
<B>CheckboxMenuItem</B>, but the following example (revised from the earlier
version) also shows ways to combine the capture of multiple menu components into
a single listener class. As you&#8217;ll see, it&#8217;s probably not worth the
hassle to do this.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MenuNew.java</font>
<font color=#009900>// Menus in Java 1.1</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MenuNew <font color=#0000ff>extends</font> Frame {
  String[] flavors = { <font color=#004488>"Chocolate"</font>, <font color=#004488>"Strawberry"</font>,
    <font color=#004488>"Vanilla Fudge Swirl"</font>, <font color=#004488>"Mint Chip"</font>, 
    <font color=#004488>"Mocha Almond Fudge"</font>, <font color=#004488>"Rum Raisin"</font>, 
    <font color=#004488>"Praline Cream"</font>, <font color=#004488>"Mud Pie"</font> };
  TextField t = <font color=#0000ff>new</font> TextField(<font color=#004488>"No flavor"</font>, 30);
  MenuBar mb1 = <font color=#0000ff>new</font> MenuBar();
  Menu f = <font color=#0000ff>new</font> Menu(<font color=#004488>"File"</font>);
  Menu m = <font color=#0000ff>new</font> Menu(<font color=#004488>"Flavors"</font>);
  Menu s = <font color=#0000ff>new</font> Menu(<font color=#004488>"Safety"</font>);
  <font color=#009900>// Alternative approach:</font>
  CheckboxMenuItem[] safety = {
    <font color=#0000ff>new</font> CheckboxMenuItem(<font color=#004488>"Guard"</font>),
    <font color=#0000ff>new</font> CheckboxMenuItem(<font color=#004488>"Hide"</font>)
  };
  MenuItem[] file = {
    <font color=#009900>// No menu shortcut:</font>
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Open"</font>),
    <font color=#009900>// Adding a menu shortcut is very simple:</font>
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Exit"</font>, 
      <font color=#0000ff>new</font> MenuShortcut(KeyEvent.VK_E))
  };
  <font color=#009900>// A second menu bar to swap to:</font>
  MenuBar mb2 = <font color=#0000ff>new</font> MenuBar();
  Menu fooBar = <font color=#0000ff>new</font> Menu(<font color=#004488>"fooBar"</font>);
  MenuItem[] other = {
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Foo"</font>),
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Bar"</font>),
    <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Baz"</font>),
  };
  <font color=#009900>// Initialization code:</font>
  {
    ML ml = <font color=#0000ff>new</font> ML();
    CMIL cmil = <font color=#0000ff>new</font> CMIL();
    safety[0].setActionCommand(<font color=#004488>"Guard"</font>);
    safety[0].addItemListener(cmil);
    safety[1].setActionCommand(<font color=#004488>"Hide"</font>);
    safety[1].addItemListener(cmil);
    file[0].setActionCommand(<font color=#004488>"Open"</font>);
    file[0].addActionListener(ml);
    file[1].setActionCommand(<font color=#004488>"Exit"</font>);
    file[1].addActionListener(ml);
    other[0].addActionListener(<font color=#0000ff>new</font> FooL());
    other[1].addActionListener(<font color=#0000ff>new</font> BarL());
    other[2].addActionListener(<font color=#0000ff>new</font> BazL());
  }
  Button b = <font color=#0000ff>new</font> Button(<font color=#004488>"Swap Menus"</font>);
  <font color=#0000ff>public</font> MenuNew() {
    FL fl = <font color=#0000ff>new</font> FL();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; flavors.length; i++) {
      MenuItem mi = <font color=#0000ff>new</font> MenuItem(flavors[i]);
      mi.addActionListener(fl);
      m.add(mi);
      <font color=#009900>// Add separators at intervals:</font>
      <font color=#0000ff>if</font>((i+1) % 3 == 0) 
        m.addSeparator();
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; safety.length; i++)
      s.add(safety[i]);
    f.add(s);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; file.length; i++)
      f.add(file[i]);
    mb1.add(f);
    mb1.add(m);
    setMenuBar(mb1);
    t.setEditable(<font color=#0000ff>false</font>);
    add(t, BorderLayout.CENTER);
    <font color=#009900>// Set up the system for swapping menus:</font>
    b.addActionListener(<font color=#0000ff>new</font> BL());
    add(b, BorderLayout.NORTH);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; other.length; i++)
      fooBar.add(other[i]);
    mb2.add(fooBar);
  }
  <font color=#0000ff>class</font> BL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      MenuBar m = getMenuBar();
      <font color=#0000ff>if</font>(m == mb1) setMenuBar(mb2);
      <font color=#0000ff>else</font> <font color=#0000ff>if</font> (m == mb2) setMenuBar(mb1);
    }
  }
  <font color=#0000ff>class</font> ML <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      MenuItem target = (MenuItem)e.getSource();
      String actionCommand = 
        target.getActionCommand();
      <font color=#0000ff>if</font>(actionCommand.equals(<font color=#004488>"Open"</font>)) {
        String s = t.getText();
        <font color=#0000ff>boolean</font> chosen = <font color=#0000ff>false</font>;
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; flavors.length; i++)
          <font color=#0000ff>if</font>(s.equals(flavors[i])) chosen = <font color=#0000ff>true</font>;
        <font color=#0000ff>if</font>(!chosen)
          t.setText(<font color=#004488>"Choose a flavor first!"</font>);
        <font color=#0000ff>else</font>
          t.setText(<font color=#004488>"Opening "</font>+ s +<font color=#004488>". Mmm, mm!"</font>);
      } <font color=#0000ff>else</font> <font color=#0000ff>if</font>(actionCommand.equals(<font color=#004488>"Exit"</font>)) {
        dispatchEvent(
          <font color=#0000ff>new</font> WindowEvent(MenuNew.<font color=#0000ff>this</font>, 
            WindowEvent.WINDOW_CLOSING));
      }
    }
  }
  <font color=#0000ff>class</font> FL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      MenuItem target = (MenuItem)e.getSource();
      t.setText(target.getLabel());
    }
  }
  <font color=#009900>// Alternatively, you can create a different</font>
  <font color=#009900>// class for each different MenuItem. Then you</font>
  <font color=#009900>// Don't have to figure out which one it is:</font>
  <font color=#0000ff>class</font> FooL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t.setText(<font color=#004488>"Foo selected"</font>);
    }
  }
  <font color=#0000ff>class</font> BarL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t.setText(<font color=#004488>"Bar selected"</font>);
    }
  }
  <font color=#0000ff>class</font> BazL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t.setText(<font color=#004488>"Baz selected"</font>);
    }
  }
  <font color=#0000ff>class</font> CMIL <font color=#0000ff>implements</font> ItemListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> itemStateChanged(ItemEvent e) {
      CheckboxMenuItem target = 
        (CheckboxMenuItem)e.getSource();
      String actionCommand = 
        target.getActionCommand();
      <font color=#0000ff>if</font>(actionCommand.equals(<font color=#004488>"Guard"</font>))
        t.setText(<font color=#004488>"Guard the Ice Cream! "</font> +
          <font color=#004488>"Guarding is "</font> + target.getState());
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(actionCommand.equals(<font color=#004488>"Hide"</font>))
        t.setText(<font color=#004488>"Hide the Ice Cream! "</font> +
          <font color=#004488>"Is it cold? "</font> + target.getState());
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    MenuNew f = <font color=#0000ff>new</font> MenuNew();
    f.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    f.setSize(300,200);
    f.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This code is similar to the
previous (Java 1.0<A NAME="Index2049"></A>) version, until you get to the
initialization section (marked by the opening brace right after the comment
&#8220;Initialization code:&#8221;). Here you can see the <B>ItemListener</B>s
and <B>ActionListener</B>s attached to the various menu components.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1<A NAME="Index2050"></A>
supports
&#8220;<A NAME="Index2051"></A><A NAME="Index2052"></A><A NAME="Index2053"></A>menu
shortcuts,&#8221; so you can select a menu item using the keyboard instead of
the mouse. These are quite simple; you just use the overloaded <B>MenuItem</B>
constructor that takes as a second argument a <B>MenuShortcut</B> object. The
constructor for <B>MenuShortcut</B> takes the key of interest, which magically
appears on the menu item when it drops down. The example above adds Control-E to
the &#8220;Exit&#8221; menu item.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also see the use of
<A NAME="Index2054"></A><A NAME="Index2055"></A><B>setActionCommand(&#160;)</B>.
This seems a bit strange because in each case the &#8220;action command&#8221;
is exactly the same as the label on the menu component. Why not just use the
label instead of this alternative string? The problem is internationalization.
If you retarget this program to another language, you want to change only the
label in the menu, and not go through the code changing all the logic that will
no doubt introduce new errors. So to make this easy for code that checks the
text string associated with a menu component, the &#8220;action command&#8221;
can be immutable while the menu label can change. All the code works with the
&#8220;action command,&#8221; so it&#8217;s unaffected by changes to the menu
labels. Note that in this program, not all the menu components are examined for
their action commands, so those that aren&#8217;t don&#8217;t have their action
command set.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Much of the constructor is the same
as before, with the exception of a couple of calls to add listeners. The bulk of
the work happens in the listeners. In <B>BL</B>, the
<A NAME="Index2056"></A><A NAME="Index2057"></A><B>MenuBar</B> swapping happens
as in the previous example. In <B>ML</B>, the &#8220;figure out who rang&#8221;
approach is taken by getting the source of the
<A NAME="Index2058"></A><A NAME="Index2059"></A><B>ActionEvent</B> and casting
it to a <A NAME="Index2060"></A><A NAME="Index2061"></A><B>MenuItem</B>, then
getting the action command string to pass it through a cascaded <B>if</B>
statement. Much of this is the same as before, but notice that if
&#8220;Exit&#8221; is chosen, a new
<A NAME="Index2062"></A><A NAME="Index2063"></A><B>WindowEvent</B> is created,
passing in the handle of the enclosing class object (<B>MenuNew.this</B>) and
creating a <A NAME="Index2064"></A><A NAME="Index2065"></A><B>WINDOW_CLOSING</B>
event. This is handed to the
<A NAME="Index2066"></A><A NAME="Index2067"></A><B>dispatchEvent(&#160;)</B>
method of the enclosing class object, which then ends up calling
<B>windowClosing(&#160;)</B> inside the window listener for the <B>Frame</B>
(this listener is created as an anonymous inner class, inside
<B>main(&#160;)</B>), just as if the message had been generated the
&#8220;normal&#8221; way. Through this mechanism, you can
<A NAME="Index2068"></A><A NAME="Index2069"></A>dispatch any message you want in
any circumstances, so it&#8217;s quite powerful.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>FL</B> listener is simple
even though it&#8217;s handling all the different flavors in the flavor menu.
This approach is useful if you have enough simplicity in your logic, but in
general, you&#8217;ll want to take the approach used with <B>FooL</B>,
<B>BarL,</B> and <B>BazL</B>, in which they are each attached to only a single
menu component so no extra detection logic is necessary and you know exactly who
called the listener. Even with the profusion of classes generated this way, the
code inside tends to be smaller and the process is more
foolproof.</FONT><BR></P></DIV>
<A NAME="Heading436"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Dialog boxes<BR><A NAME="Index2070"></A><A NAME="Index2071"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is a direct rewrite of the
earlier <B>ToeTest.java.</B> In this version, however, everything is placed
inside an inner class. Although this completely eliminates the need to keep
track of the object that spawned any class, as was the case in
<B>ToeTest.java</B>, it could be taking the concept of inner classes a bit too
far. At one point, the inner classes are nested four deep! This is the kind of
design in which you need to decide whether the benefit of inner classes is worth
the increased complexity. In addition, when you create a non-<B>static</B> inner
class you&#8217;re tying that class to its surrounding class. Sometimes a
standalone class can more easily be reused.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ToeTestNew.java</font>
<font color=#009900>// Demonstration of dialog boxes</font>
<font color=#009900>// and creating your own components</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ToeTestNew <font color=#0000ff>extends</font> Frame {
  TextField rows = <font color=#0000ff>new</font> TextField(<font color=#004488>"3"</font>);
  TextField cols = <font color=#0000ff>new</font> TextField(<font color=#004488>"3"</font>);
  <font color=#0000ff>public</font> ToeTestNew() {
    setTitle(<font color=#004488>"Toe Test"</font>);
    Panel p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> GridLayout(2,2));
    p.add(<font color=#0000ff>new</font> Label(<font color=#004488>"Rows"</font>, Label.CENTER));
    p.add(rows);
    p.add(<font color=#0000ff>new</font> Label(<font color=#004488>"Columns"</font>, Label.CENTER));
    p.add(cols);
    add(p, BorderLayout.NORTH);
    Button b = <font color=#0000ff>new</font> Button(<font color=#004488>"go"</font>);
    b.addActionListener(<font color=#0000ff>new</font> BL());
    add(b, BorderLayout.SOUTH);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> BLANK = 0;
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> XX = 1;
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> OO = 2;
  <font color=#0000ff>class</font> ToeDialog <font color=#0000ff>extends</font> Dialog {
    <font color=#009900>// w = number of cells wide</font>
    <font color=#009900>// h = number of cells high</font>
    <font color=#0000ff>int</font> turn = XX; <font color=#009900>// Start with x's turn</font>
    <font color=#0000ff>public</font> ToeDialog(<font color=#0000ff>int</font> w, <font color=#0000ff>int</font> h) {
      <font color=#0000ff>super</font>(ToeTestNew.<font color=#0000ff>this</font>, 
        <font color=#004488>"The game itself"</font>, <font color=#0000ff>false</font>);
      setLayout(<font color=#0000ff>new</font> GridLayout(w, h));
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; w * h; i++)
        add(<font color=#0000ff>new</font> ToeButton());
      setSize(w * 50, h * 50);
      addWindowListener(<font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e){
          dispose();
        }
      });
    }
    <font color=#0000ff>class</font> ToeButton <font color=#0000ff>extends</font> Canvas {
      <font color=#0000ff>int</font> state = BLANK;
      ToeButton() {
        addMouseListener(<font color=#0000ff>new</font> ML());
      }
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics  g) {
        <font color=#0000ff>int</font> x1 = 0;
        <font color=#0000ff>int</font> y1 = 0;
        <font color=#0000ff>int</font> x2 = getSize().width - 1;
        <font color=#0000ff>int</font> y2 = getSize().height - 1;
        g.drawRect(x1, y1, x2, y2);
        x1 = x2/4;
        y1 = y2/4;
        <font color=#0000ff>int</font> wide = x2/2;
        <font color=#0000ff>int</font> high = y2/2;
        <font color=#0000ff>if</font>(state == XX) {
          g.drawLine(x1, y1, 
            x1 + wide, y1 + high);
          g.drawLine(x1, y1 + high, 
            x1 + wide, y1);
        }
        <font color=#0000ff>if</font>(state == OO) {
          g.drawOval(x1, y1, 
            x1 + wide/2, y1 + high/2);
        }
      }
      <font color=#0000ff>class</font> ML <font color=#0000ff>extends</font> MouseAdapter {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> mousePressed(MouseEvent e) {
          <font color=#0000ff>if</font>(state == BLANK) {
            state = turn;
            turn = (turn == XX ? OO : XX);
          } 
          <font color=#0000ff>else</font>
            state = (state == XX ? OO : XX);
          repaint();
        }
      }
    }
  }
  <font color=#0000ff>class</font> BL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      Dialog d = <font color=#0000ff>new</font> ToeDialog(
        Integer.parseInt(rows.getText()),
        Integer.parseInt(cols.getText()));
      d.show();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> ToeTestNew();
    f.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    f.setSize(200,100);
    f.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because <B>static</B>s can be at
only the outer level of the class, inner classes cannot have <B>static</B> data
or <B>static</B> inner classes.</FONT><BR></P></DIV>
<A NAME="Heading437"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
File dialogs</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Converting from
<A NAME="Index2072"></A><A NAME="Index2073"></A><B>FileDialogTest.java</B> to
the new event model is straightforward:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: FileDialogNew.java</font>
<font color=#009900>// Demonstration of File dialog boxes</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FileDialogNew <font color=#0000ff>extends</font> Frame {
  TextField filename = <font color=#0000ff>new</font> TextField();
  TextField directory = <font color=#0000ff>new</font> TextField();
  Button open = <font color=#0000ff>new</font> Button(<font color=#004488>"Open"</font>);
  Button save = <font color=#0000ff>new</font> Button(<font color=#004488>"Save"</font>);
  <font color=#0000ff>public</font> FileDialogNew() {
    setTitle(<font color=#004488>"File Dialog Test"</font>);
    Panel p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> FlowLayout());
    open.addActionListener(<font color=#0000ff>new</font> OpenL());
    p.add(open);
    save.addActionListener(<font color=#0000ff>new</font> SaveL());
    p.add(save);
    add(p, BorderLayout.SOUTH);
    directory.setEditable(<font color=#0000ff>false</font>);
    filename.setEditable(<font color=#0000ff>false</font>);
    p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> GridLayout(2,1));
    p.add(filename);
    p.add(directory);
    add(p, BorderLayout.NORTH);
  }
  <font color=#0000ff>class</font> OpenL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#009900>// Two arguments, defaults to open file:</font>
      FileDialog d = <font color=#0000ff>new</font> FileDialog(
        FileDialogNew.<font color=#0000ff>this</font>,
        <font color=#004488>"What file do you want to open?"</font>);
      d.setFile(<font color=#004488>"*.java"</font>);
      d.setDirectory(<font color=#004488>"."</font>); <font color=#009900>// Current directory</font>
      d.show();
      String yourFile = <font color=#004488>"*.*"</font>;
      <font color=#0000ff>if</font>((yourFile = d.getFile()) != <font color=#0000ff>null</font>) {
        filename.setText(yourFile);
        directory.setText(d.getDirectory());
      } <font color=#0000ff>else</font> {
        filename.setText(<font color=#004488>"You pressed cancel"</font>);
        directory.setText(<font color=#004488>""</font>);
      }
    }
  }
  <font color=#0000ff>class</font> SaveL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      FileDialog d = <font color=#0000ff>new</font> FileDialog(
        FileDialogNew.<font color=#0000ff>this</font>,
        <font color=#004488>"What file do you want to save?"</font>,
        FileDialog.SAVE);
      d.setFile(<font color=#004488>"*.java"</font>);
      d.setDirectory(<font color=#004488>"."</font>);
      d.show();
      String saveFile;
      <font color=#0000ff>if</font>((saveFile = d.getFile()) != <font color=#0000ff>null</font>) {
        filename.setText(saveFile);
        directory.setText(d.getDirectory());
      } <font color=#0000ff>else</font> {
        filename.setText(<font color=#004488>"You pressed cancel"</font>);
        directory.setText(<font color=#004488>""</font>);
      }
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> FileDialogNew();
    f.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    f.setSize(250,110);
    f.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It would be nice if all the
conversions were this easy, but they&#8217;re usually easy enough, and your code
benefits from the improved
readability.</FONT><A NAME="_Toc408018710"></A><BR></P></DIV>
<A NAME="Heading438"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Binding events dynamically</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the benefits of the new AWT
event model is flexibility. In the old model you were forced to hard code the
behavior of your program, but with the new model you can add and remove event
behavior with single method calls. The following example demonstrates
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: DynamicEvents.java</font>
<font color=#009900>// The new Java 1.1 event model allows you to</font>
<font color=#009900>// change event behavior dynamically. Also</font>
<font color=#009900>// demonstrates multiple actions for an event.</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DynamicEvents <font color=#0000ff>extends</font> Frame {
  Vector v = <font color=#0000ff>new</font> Vector();
  <font color=#0000ff>int</font> i = 0;
  Button 
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 1"</font>), 
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 2"</font>);
  <font color=#0000ff>public</font> DynamicEvents() {
    setLayout(<font color=#0000ff>new</font> FlowLayout());
    b1.addActionListener(<font color=#0000ff>new</font> B());
    b1.addActionListener(<font color=#0000ff>new</font> B1());
    b2.addActionListener(<font color=#0000ff>new</font> B());
    b2.addActionListener(<font color=#0000ff>new</font> B2());
    add(b1);
    add(b2);
  }
  <font color=#0000ff>class</font> B <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      System.out.println(<font color=#004488>"A button was pressed"</font>);
    }
  }
  <font color=#0000ff>class</font> CountListener <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>int</font> index;
    <font color=#0000ff>public</font> CountListener(<font color=#0000ff>int</font> i) { index = i; }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      System.out.println(
        <font color=#004488>"Counted Listener "</font> + index);
    }
  }    
  <font color=#0000ff>class</font> B1 <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      System.out.println(<font color=#004488>"Button 1 pressed"</font>);
      ActionListener a = <font color=#0000ff>new</font> CountListener(i++);
      v.addElement(a);
      b2.addActionListener(a);
    }
  }
  <font color=#0000ff>class</font> B2 <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      System.out.println(<font color=#004488>"Button 2 pressed"</font>);
      <font color=#0000ff>int</font> end = v.size() -1;
      <font color=#0000ff>if</font>(end &gt;= 0) {
        b2.removeActionListener(
          (ActionListener)v.elementAt(end));
        v.removeElementAt(end);
      }
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> DynamicEvents();
    f.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e){
          System.exit(0);
        }
      });
    f.setSize(300,200);
    f.show();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The new twists in this example
are:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	There is more than one listener attached to each
<B>Button</B>. Usually, components handle events as
<A NAME="Index2074"></A><A NAME="Index2075"></A><A NAME="Index2076"></A><I>multicast</I>,
meaning that you can register many listeners for a single event. In the special
components in which an event is handled as
<A NAME="Index2077"></A><A NAME="Index2078"></A><A NAME="Index2079"></A><I>unicast</I>,
you&#8217;ll get a
<A NAME="Index2080"></A><A NAME="Index2081"></A><B>TooManyListenersException</B>.</FONT><LI><FONT FACE="Georgia">	During
the execution of the program, listeners are dynamically added and removed from
the <B>Button b2</B>. Adding is accomplished in the way you&#8217;ve seen
before, but each component also has a <B>removeXXXListener(&#160;)</B> method to
remove each type of
listener.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This kind of
flexibility provides much greater power in your programming.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You should notice that
<A NAME="Index2082"></A>event listeners are not guaranteed to be called in the
order they are added (although most implementations do in fact work that
way).</FONT><A NAME="_Toc408018711"></A><BR></P></DIV>
<A NAME="Heading439"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Separating business logic <BR>from UI logic</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general you&#8217;ll want to
design your classes so that each one does &#8220;only one thing.&#8221; This is
particularly important when user-interface code is concerned, since it&#8217;s
easy to wrap up &#8220;what you&#8217;re doing&#8221; with &#8220;how
you&#8217;re displaying it.&#8221; This kind of coupling prevents code reuse.
It&#8217;s much more desirable to separate your &#8220;business logic&#8221;
from the GUI. This way, you can not only reuse the business logic more easily,
it&#8217;s also easier to reuse the GUI.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another issue is
<A NAME="Index2083"></A><I>multi-tiered</I> systems, where the
&#8220;<A NAME="Index2084"></A><A NAME="Index2085"></A>business objects&#8221;
reside on a completely separate machine. This central location of the business
rules allows changes to be instantly effective for all new transactions, and is
thus a compelling way to set up a system. However, these business objects can be
used in many different applications and so should not be tied to any particular
mode of display. They should just perform the business operations and nothing
more.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example shows how
easy it is to separate the business logic from the GUI code:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Separation.java</font>
<font color=#009900>// Separating GUI logic and business objects</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.applet.*;

<font color=#0000ff>class</font> BusinessLogic {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> modifier;
  BusinessLogic(<font color=#0000ff>int</font> mod) {
    modifier = mod;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setModifier(<font color=#0000ff>int</font> mod) {
    modifier = mod;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getModifier() {
    <font color=#0000ff>return</font> modifier;
  }
  <font color=#009900>// Some business operations:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> calculation1(<font color=#0000ff>int</font> arg) {
    <font color=#0000ff>return</font> arg * modifier;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> calculation2(<font color=#0000ff>int</font> arg) {
    <font color=#0000ff>return</font> arg + modifier;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Separation <font color=#0000ff>extends</font> Applet {
  TextField 
    t = <font color=#0000ff>new</font> TextField(20),
    mod = <font color=#0000ff>new</font> TextField(20);
  BusinessLogic bl = <font color=#0000ff>new</font> BusinessLogic(2);
  Button
    calc1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Calculation 1"</font>),
    calc2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Calculation 2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    add(t);
    calc1.addActionListener(<font color=#0000ff>new</font> Calc1L());
    calc2.addActionListener(<font color=#0000ff>new</font> Calc2L());
    add(calc1); add(calc2);
    mod.addTextListener(<font color=#0000ff>new</font> ModL());
    add(<font color=#0000ff>new</font> Label(<font color=#004488>"Modifier:"</font>));
    add(mod);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> getValue(TextField tf) {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>return</font> Integer.parseInt(tf.getText());
    } <font color=#0000ff>catch</font>(NumberFormatException e) {
      <font color=#0000ff>return</font> 0;
    }
  }
  <font color=#0000ff>class</font> Calc1L <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t.setText(Integer.toString(
        bl.calculation1(getValue(t))));
    }
  }
  <font color=#0000ff>class</font> Calc2L <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t.setText(Integer.toString(
        bl.calculation2(getValue(t))));
    }
  }
  <font color=#0000ff>class</font> ModL <font color=#0000ff>implements</font> TextListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> textValueChanged(TextEvent e) {
      bl.setModifier(getValue(mod));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Separation applet = <font color=#0000ff>new</font> Separation();
    Frame aFrame = <font color=#0000ff>new</font> Frame(<font color=#004488>"Separation"</font>);
    aFrame.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(200,200);
    applet.init();
    applet.start();
    aFrame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that
<B>BusinessLogic</B> is a straightforward class that performs its operations
without even a hint that it might be used in a GUI environment. It just does its
job.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Separation</B> keeps track of
all the UI details, and it talks to <B>BusinessLogic</B> only through its
<B>public</B> interface. All the operations are centered around getting
information back and forth through the UI and the <B>BusinessLogic</B> object.
So <B>Separation</B>, in turn, just does its job. Since <B>Separation</B> knows
only that it&#8217;s talking to a <B>BusinessLogic</B> object (that is, it
isn&#8217;t highly coupled), it could be massaged into talking to other types of
objects without much trouble.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thinking in terms of separating UI
from business logic also makes life easier when you&#8217;re adapting legacy
code to work with Java.</FONT><A NAME="_Toc408018712"></A><BR></P></DIV>
<A NAME="Heading440"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Recommended coding approaches</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Inner classes, the new event model,
and the fact that the old event model is still supported along with new library
features that rely on old-style programming has added a new element of
confusion. Now there are even more different ways for people to write unpleasant
code. Unfortunately, this kind of code is showing up in books and article
examples, and even in documentation and examples distributed from Sun! In this
section we&#8217;ll look at some misunderstandings about what you should and
shouldn&#8217;t do with the new AWT, and end by showing that except in
extenuating circumstances you can always use <A NAME="Index2086"></A>listener
classes (written as <A NAME="Index2087"></A><A NAME="Index2088"></A>inner
classes) to solve your event-handling needs. Since this is also the simplest and
clearest approach, it should be a relief for you to learn this.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before looking at anything else,
you should know that although Java 1.1<A NAME="Index2089"></A> is
backward-compatible with Java 1.0<A NAME="Index2090"></A> (that is, you can
compile and run 1.0 programs with 1.1), you cannot mix the event models within
the same program. That is, you cannot use the old-style
<A NAME="Index2091"></A><A NAME="Index2092"></A><B>action(&#160;)</B> method in
the same program in which you employ listeners. This can be a problem in a
larger program when you&#8217;re trying to integrate old code with a new
program, since you must decide whether to use the old, hard-to-maintain approach
with the new program or to update the old code. This shouldn&#8217;t be too much
of a battle since the new approach is so superior to the old.</FONT><BR></P></DIV>
<A NAME="Heading441"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Baseline: the good way to do it</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To give you something to compare
with, here&#8217;s an example showing the recommended approach. By now it should
be reasonably familiar and comfortable:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: GoodIdea.java</font>
<font color=#009900>// The best way to design classes using the new</font>
<font color=#009900>// Java 1.1 event model: use an inner class for</font>
<font color=#009900>// each different event. This maximizes </font>
<font color=#009900>// flexibility and modularity.</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GoodIdea <font color=#0000ff>extends</font> Frame {
  Button 
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 1"</font>), 
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 2"</font>);
  <font color=#0000ff>public</font> GoodIdea() {
    setLayout(<font color=#0000ff>new</font> FlowLayout());
    b1.addActionListener(<font color=#0000ff>new</font> B1L());
    b2.addActionListener(<font color=#0000ff>new</font> B2L());
    add(b1);
    add(b2);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>class</font> B1L <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      System.out.println(<font color=#004488>"Button 1 pressed"</font>);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>class</font> B2L <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      System.out.println(<font color=#004488>"Button 2 pressed"</font>);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> GoodIdea();
    f.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e){
          System.out.println(<font color=#004488>"Window Closing"</font>);
          System.exit(0);
        }
      });
    f.setSize(300,200);
    f.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is fairly trivial: each button
has its own listener that prints something out to the console. But notice that
there isn&#8217;t an <B>if</B> statement in the entire program, or any statement
that says, &#8220;I wonder what caused this event.&#8221; Each piece of code is
concerned with <I>doing</I>, not type-checking. This is the best way to write
your code; not only is it easier to conceptualize, but much easier to read and
maintain. Cutting and pasting to create new programs is also much
easier.</FONT><BR></P></DIV>
<A NAME="Heading442"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Implementing the main class as a listener</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first bad idea is a common and
recommended approach. This makes the main class (typically <B>Applet</B> or
<B>Frame</B>, but it could be any class) implement the various listeners.
Here&#8217;s an example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: BadIdea1.java</font>
<font color=#009900>// Some literature recommends this approach,</font>
<font color=#009900>// but it's missing the point of the new event</font>
<font color=#009900>// model in Java 1.1</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> BadIdea1 <font color=#0000ff>extends</font> Frame 
    <font color=#0000ff>implements</font> ActionListener, WindowListener {
  Button 
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 1"</font>), 
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 2"</font>);
  <font color=#0000ff>public</font> BadIdea1() {
    setLayout(<font color=#0000ff>new</font> FlowLayout());
    addWindowListener(<font color=#0000ff>this</font>);
    b1.addActionListener(<font color=#0000ff>this</font>);
    b2.addActionListener(<font color=#0000ff>this</font>);
    add(b1);
    add(b2);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
    Object source = e.getSource();
    <font color=#0000ff>if</font>(source == b1)
      System.out.println(<font color=#004488>"Button 1 pressed"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(source == b2)
      System.out.println(<font color=#004488>"Button 2 pressed"</font>);
    <font color=#0000ff>else</font>
      System.out.println(<font color=#004488>"Something else"</font>);
  }    
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
    System.out.println(<font color=#004488>"Window Closing"</font>);
    System.exit(0);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosed(WindowEvent e) {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowDeiconified(WindowEvent e) {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowIconified(WindowEvent e) {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowActivated(WindowEvent e) {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowDeactivated(WindowEvent e) {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowOpened(WindowEvent e) {}  

  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> BadIdea1();
    f.setSize(300,200);
    f.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of this shows up in the
three lines:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    addWindowListener(<font color=#0000ff>this</font>);
    b1.addActionListener(<font color=#0000ff>this</font>);
    b2.addActionListener(<font color=#0000ff>this</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since <B>BadIdea1</B> implements
<B>ActionListener</B> and <B>WindowListener,</B> these lines are certainly
acceptable, and if you&#8217;re still stuck in the mode of trying to make fewer
classes to reduce server hits during applet loading, it seems to be a good idea.
However: <A NAME="Index2093"></A><A NAME="Index2094"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	Java 1.1 supports JAR files so all your files
can be placed in a single compressed JAR archive that requires only one server
hit. You no longer need to reduce class count for Internet
efficiency.</FONT><LI><FONT FACE="Georgia">	The code above is much less
modular so it&#8217;s harder to grab and paste. Note that you must not only
implement the various interfaces for your main class, but in
<B>actionPerformed(&#160;)</B> you&#8217;ve got to detect which action was
performed using a cascaded <B>if</B> statement. Not only is this going
backwards, <I>away</I> from the listener model, but you can&#8217;t easily reuse
the <B>actionPerformed(&#160;)</B> method since it&#8217;s specific to this
particular application. Contrast this with <B>GoodIdea.java</B>, in which you
can just grab one listener class and paste it in anywhere else with minimal
fuss. Plus you can register multiple listener classes with a single event,
allowing even more modularity in what each listener class
does.</FONT></OL><A NAME="Heading443"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Mixing the approaches</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second bad idea is to mix the
two approaches: use inner listener classes, but also implement one or more
listener interfaces as part of the main class. This approach has appeared
without explanation in books and documentation, and I can only assume that the
authors thought they must use the different approaches for different purposes.
But you don&#8217;t &#8211; in your programming you can probably use inner
listener classes exclusively.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: BadIdea2.java</font>
<font color=#009900>// An improvement over BadIdea1.java, since it</font>
<font color=#009900>// uses the WindowAdapter as an inner class </font>
<font color=#009900>// instead of implementing all the methods of</font>
<font color=#009900>// WindowListener, but still misses the</font>
<font color=#009900>// valuable modularity of inner classes</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> BadIdea2 <font color=#0000ff>extends</font> Frame 
    <font color=#0000ff>implements</font> ActionListener {
  Button 
    b1 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 1"</font>), 
    b2 = <font color=#0000ff>new</font> Button(<font color=#004488>"Button 2"</font>);
  <font color=#0000ff>public</font> BadIdea2() {
    setLayout(<font color=#0000ff>new</font> FlowLayout());
    addWindowListener(<font color=#0000ff>new</font> WL());
    b1.addActionListener(<font color=#0000ff>this</font>);
    b2.addActionListener(<font color=#0000ff>this</font>);
    add(b1);
    add(b2);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
    Object source = e.getSource();
    <font color=#0000ff>if</font>(source == b1)
      System.out.println(<font color=#004488>"Button 1 pressed"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(source == b2)
      System.out.println(<font color=#004488>"Button 2 pressed"</font>);
    <font color=#0000ff>else</font>
      System.out.println(<font color=#004488>"Something else"</font>);
  }
  <font color=#0000ff>class</font> WL <font color=#0000ff>extends</font> WindowAdapter {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
      System.out.println(<font color=#004488>"Window Closing"</font>);
      System.exit(0);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> BadIdea2();
    f.setSize(300,200);
    f.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since
<B>actionPerformed(&#160;)</B> is still tightly coupled to the main class,
it&#8217;s hard to reuse that code. It&#8217;s also messier and less pleasant to
read than the inner class approach.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s no reason that you
have to use any of the old thinking for events in Java
1.1<A NAME="Index2095"></A> &#8211; so why do it?</FONT><BR></P></DIV>
<A NAME="Heading444"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Inheriting a component</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another place where you&#8217;ll
often see variations on the old way of doing things is when creating a new type
of component. Here&#8217;s an example showing that here, too, the new way
works:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: GoodTechnique.java</font>
<font color=#009900>// Your first choice when overriding components</font>
<font color=#009900>// should be to install listeners. The code is</font>
<font color=#009900>// much safer, more modular and maintainable.</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;

<font color=#0000ff>class</font> Display {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font>
    EVENT = 0, COMPONENT = 1,
    MOUSE = 2, MOUSE_MOVE = 3,
    FOCUS = 4, KEY = 5, ACTION = 6,
    LAST = 7;
  <font color=#0000ff>public</font> String[] evnt;
  Display() {
    evnt = <font color=#0000ff>new</font> String[LAST];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; LAST; i++)
      evnt[i] = <font color=#0000ff>new</font> String();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> show(Graphics g) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; LAST; i++)
      g.drawString(evnt[i], 0, 10 * i + 10);
  }
}

<font color=#0000ff>class</font> EnabledPanel <font color=#0000ff>extends</font> Panel {
  Color c;
  <font color=#0000ff>int</font> id;
  Display display = <font color=#0000ff>new</font> Display();
  <font color=#0000ff>public</font> EnabledPanel(<font color=#0000ff>int</font> i, Color mc) {
    id = i;
    c = mc;
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    add(<font color=#0000ff>new</font> MyButton(), BorderLayout.SOUTH);
    addComponentListener(<font color=#0000ff>new</font> CL());
    addFocusListener(<font color=#0000ff>new</font> FL());
    addKeyListener(<font color=#0000ff>new</font> KL());
    addMouseListener(<font color=#0000ff>new</font> ML());
    addMouseMotionListener(<font color=#0000ff>new</font> MML());
  }
  <font color=#009900>// To eliminate flicker:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> update(Graphics g) {
    paint(g);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics  g) {
    g.setColor(c);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
    g.setColor(Color.black);
    display.show(g);
  }
  <font color=#009900>// Don't need to enable anything for this:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> processEvent(AWTEvent e) {
    display.evnt[Display.EVENT]= e.toString();
    repaint();
    <font color=#0000ff>super</font>.processEvent(e);
  }
  <font color=#0000ff>class</font> CL <font color=#0000ff>implements</font> ComponentListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> componentMoved(ComponentEvent e){
      display.evnt[Display.COMPONENT] = 
        <font color=#004488>"Component moved"</font>;
      repaint();
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> 
    componentResized(ComponentEvent e) {
      display.evnt[Display.COMPONENT] = 
        <font color=#004488>"Component resized"</font>;
      repaint();
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> 
    componentHidden(ComponentEvent e) {
      display.evnt[Display.COMPONENT] = 
        <font color=#004488>"Component hidden"</font>;
      repaint();
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> componentShown(ComponentEvent e){
      display.evnt[Display.COMPONENT] = 
        <font color=#004488>"Component shown"</font>;
      repaint();
    }
  }
  <font color=#0000ff>class</font> FL <font color=#0000ff>implements</font> FocusListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> focusGained(FocusEvent e) {
      display.evnt[Display.FOCUS] = 
        <font color=#004488>"FOCUS gained"</font>;
      repaint();
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> focusLost(FocusEvent e) {
      display.evnt[Display.FOCUS] = 
        <font color=#004488>"FOCUS lost"</font>;
      repaint();
    }
  }
  <font color=#0000ff>class</font> KL <font color=#0000ff>implements</font> KeyListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> keyPressed(KeyEvent e) {
      display.evnt[Display.KEY] = 
        <font color=#004488>"KEY pressed: "</font>; 
      showCode(e);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> keyReleased(KeyEvent e) {
      display.evnt[Display.KEY] = 
        <font color=#004488>"KEY released: "</font>; 
      showCode(e);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> keyTyped(KeyEvent e) {
      display.evnt[Display.KEY] = 
        <font color=#004488>"KEY typed: "</font>;
      showCode(e);
    }
    <font color=#0000ff>void</font> showCode(KeyEvent e) {
      <font color=#0000ff>int</font> code = e.getKeyCode();
      display.evnt[Display.KEY] += 
        KeyEvent.getKeyText(code);
      repaint();
    }
  }
  <font color=#0000ff>class</font> ML <font color=#0000ff>implements</font> MouseListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mouseClicked(MouseEvent e) {
      requestFocus(); <font color=#009900>// Get FOCUS on click</font>
      display.evnt[Display.MOUSE] = 
        <font color=#004488>"MOUSE clicked"</font>;
      showMouse(e);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mousePressed(MouseEvent e) {
      display.evnt[Display.MOUSE] = 
        <font color=#004488>"MOUSE pressed"</font>;
      showMouse(e);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mouseReleased(MouseEvent e) {
      display.evnt[Display.MOUSE] = 
        <font color=#004488>"MOUSE released"</font>;
      showMouse(e);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mouseEntered(MouseEvent e) { 
      display.evnt[Display.MOUSE] = 
        <font color=#004488>"MOUSE entered"</font>;
      showMouse(e);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mouseExited(MouseEvent e) { 
      display.evnt[Display.MOUSE] = 
        <font color=#004488>"MOUSE exited"</font>;
      showMouse(e);
    }
    <font color=#0000ff>void</font> showMouse(MouseEvent e) {
      display.evnt[Display.MOUSE] += 
        <font color=#004488>", x = "</font> + e.getX() + 
        <font color=#004488>", y = "</font> + e.getY();
      repaint();
    }
  }
  <font color=#0000ff>class</font> MML <font color=#0000ff>implements</font> MouseMotionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mouseDragged(MouseEvent e) {
      display.evnt[Display.MOUSE_MOVE] = 
        <font color=#004488>"MOUSE dragged"</font>;
      showMouse(e);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mouseMoved(MouseEvent e) {
      display.evnt[Display.MOUSE_MOVE] = 
        <font color=#004488>"MOUSE moved"</font>;
      showMouse(e);
    }
    <font color=#0000ff>void</font> showMouse(MouseEvent e) {
      display.evnt[Display.MOUSE_MOVE] += 
        <font color=#004488>", x = "</font> + e.getX() + 
        <font color=#004488>", y = "</font> + e.getY();
      repaint();
    }
  }
}

<font color=#0000ff>class</font> MyButton <font color=#0000ff>extends</font> Button {
  <font color=#0000ff>int</font> clickCounter;
  String label = <font color=#004488>""</font>;
  <font color=#0000ff>public</font> MyButton() {
    addActionListener(<font color=#0000ff>new</font> AL());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics g) {
    g.setColor(Color.green);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
    g.setColor(Color.black);
    g.drawRect(0, 0, s.width - 1, s.height - 1);
    drawLabel(g);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> drawLabel(Graphics g) {
    FontMetrics fm = g.getFontMetrics();
    <font color=#0000ff>int</font> width = fm.stringWidth(label);
    <font color=#0000ff>int</font> height = fm.getHeight();
    <font color=#0000ff>int</font> ascent = fm.getAscent();
    <font color=#0000ff>int</font> leading = fm.getLeading();
    <font color=#0000ff>int</font> horizMargin = 
      (getSize().width - width)/2;
    <font color=#0000ff>int</font> verMargin = 
      (getSize().height - height)/2;
    g.setColor(Color.red);
    g.drawString(label, horizMargin, 
      verMargin + ascent + leading);
  }
  <font color=#0000ff>class</font> AL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      clickCounter++;
      label = <font color=#004488>"click #"</font> + clickCounter +
        <font color=#004488>" "</font> + e.toString();
      repaint();
    }
  }
}
  
<font color=#0000ff>public</font> <font color=#0000ff>class</font> GoodTechnique <font color=#0000ff>extends</font> Frame {
  GoodTechnique() {
    setLayout(<font color=#0000ff>new</font> GridLayout(2,2));
    add(<font color=#0000ff>new</font> EnabledPanel(1, Color.cyan));
    add(<font color=#0000ff>new</font> EnabledPanel(2, Color.lightGray));
    add(<font color=#0000ff>new</font> EnabledPanel(3, Color.yellow));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> GoodTechnique();
    f.setTitle(<font color=#004488>"Good Technique"</font>);
    f.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e){
          System.out.println(e);
          System.out.println(<font color=#004488>"Window Closing"</font>);
          System.exit(0);
        }
      });
    f.setSize(700,700);
    f.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example also demonstrates the
various events that occur and displays the information about them. The class
<B>Display</B> is a way to centralize that information display. There&#8217;s an
array of <B>String</B>s to hold information about each type of event, and the
method <B>show(&#160;)</B> takes a handle to whatever <B>Graphic</B>s object you
have and writes directly on that surface. The scheme is intended to be somewhat
reusable.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>EnabledPanel</B> represents the
new type of component. It&#8217;s a colored panel with a button at the bottom,
and it captures all the events that happen over it by using inner listener
classes for every single event <I>except</I> those in which <B>EnabledPanel</B>
overrides
<A NAME="Index2096"></A><A NAME="Index2097"></A><B>processEvent(&#160;) </B>in
the old style (notice it must also call <B>super.processEvent(&#160;))</B>. The
only reason for using this method is that it captures every event that happens,
so you can view everything that goes on. <B>processEvent(&#160;) </B>does
nothing more than show the string representation of each event, otherwise it
would have to use a cascade of <B>if </B>statements to figure out what event it
was. On the other hand, the inner listener classes already know precisely what
event occurred. (Assuming you register them to components in which you
don&#8217;t need any control logic, which should be your goal.) Thus, they
don&#8217;t have to check anything out; they just do their
stuff.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each listener modifies the
<B>Display</B> string associated with its particular event and calls
<A NAME="Index2098"></A><A NAME="Index2099"></A><B>repaint(&#160;)</B> so the
strings get displayed. You can also see a trick that will usually
<A NAME="Index2100"></A><A NAME="Index2101"></A>eliminate
flicker:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>public</font> <font color=#0000ff>void</font> update(Graphics g) {
    paint(g);
  }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You don&#8217;t always need to
override <A NAME="Index2102"></A><A NAME="Index2103"></A><B>update(&#160;)</B>,
but if you write something that flickers, try it. The default version of update
clears the background and then calls <B>paint(&#160;)</B> to redraw any
graphics. This clearing is usually what causes flicker but is not necessary
since <B>paint(&#160;) </B>redraws the entire surface.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that there are a lot of
listeners &#8211; however, type checking occurs for the listeners, and you
can&#8217;t listen for something that the component doesn&#8217;t support
(unlike <B>BadTechnique.java</B>, which you will see
momentarily).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Experimenting with this program is
quite educational since you learn a lot about the way that events occur in Java.
For one thing, it shows a flaw in the design of most windowing systems:
it&#8217;s pretty hard to click and release the mouse without moving it, and the
windowing system will often think you&#8217;re dragging when you&#8217;re
actually just trying to click on something. A solution to this is to use
<B>mousePressed(&#160;)</B> and <B>mouseReleased(&#160;)</B> instead of
<B>mouseClicked(&#160;)</B>, and then determine whether to call your own
&#8220;mouseReallyClicked(&#160;)&#8221; method based on time and about 4 pixels
of mouse hysteresis.</FONT><BR></P></DIV>
<A NAME="Heading445"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Ugly component inheritance</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The alternative, which you will see
put forward in many published works, is to call
<A NAME="Index2104"></A><A NAME="Index2105"></A><B>enableEvents(&#160;) </B>and
pass it the masks corresponding to the events you want to handle. This causes
those events to be sent to the old-style methods (although they&#8217;re new to
Java 1.1<A NAME="Index2106"></A>) with names like
<B>processFocusEvent(&#160;)</B>. You must also remember to call the base-class
version. Here&#8217;s what it looks like:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: BadTechnique.java</font>
<font color=#009900>// It's possible to override components this way,</font>
<font color=#009900>// but the listener approach is much better, so</font>
<font color=#009900>// why would you?</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;

<font color=#0000ff>class</font> Display {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font>
    EVENT = 0, COMPONENT = 1,
    MOUSE = 2, MOUSE_MOVE = 3,
    FOCUS = 4, KEY = 5, ACTION = 6,
    LAST = 7;
  <font color=#0000ff>public</font> String[] evnt;
  Display() {
    evnt = <font color=#0000ff>new</font> String[LAST];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; LAST; i++)
      evnt[i] = <font color=#0000ff>new</font> String();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> show(Graphics g) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; LAST; i++)
      g.drawString(evnt[i], 0, 10 * i + 10);
  }
}

<font color=#0000ff>class</font> EnabledPanel <font color=#0000ff>extends</font> Panel {
  Color c;
  <font color=#0000ff>int</font> id;
  Display display = <font color=#0000ff>new</font> Display();
  <font color=#0000ff>public</font> EnabledPanel(<font color=#0000ff>int</font> i, Color mc) {
    id = i;
    c = mc;
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    add(<font color=#0000ff>new</font> MyButton(), BorderLayout.SOUTH);
    <font color=#009900>// Type checking is lost. You can enable and</font>
    <font color=#009900>// process events that the component doesn't</font>
    <font color=#009900>// capture:</font>
    enableEvents(
      <font color=#009900>// Panel doesn't handle these:</font>
      AWTEvent.ACTION_EVENT_MASK |
      AWTEvent.ADJUSTMENT_EVENT_MASK |
      AWTEvent.ITEM_EVENT_MASK |
      AWTEvent.TEXT_EVENT_MASK |
      AWTEvent.WINDOW_EVENT_MASK |
      <font color=#009900>// Panel can handle these:</font>
      AWTEvent.COMPONENT_EVENT_MASK |
      AWTEvent.FOCUS_EVENT_MASK |
      AWTEvent.KEY_EVENT_MASK |
      AWTEvent.MOUSE_EVENT_MASK |
      AWTEvent.MOUSE_MOTION_EVENT_MASK |
      AWTEvent.CONTAINER_EVENT_MASK);
      <font color=#009900>// You can enable an event without</font>
      <font color=#009900>// overriding its process method.</font>
  }
  <font color=#009900>// To eliminate flicker:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> update(Graphics g) {
    paint(g);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics  g) {
    g.setColor(c);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
    g.setColor(Color.black);
    display.show(g);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> processEvent(AWTEvent e) {
    display.evnt[Display.EVENT]= e.toString();
    repaint();
    <font color=#0000ff>super</font>.processEvent(e);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font>
  processComponentEvent(ComponentEvent e) {
    <font color=#0000ff>switch</font>(e.getID()) {
      <font color=#0000ff>case</font> ComponentEvent.COMPONENT_MOVED:
        display.evnt[Display.COMPONENT] = 
          <font color=#004488>"Component moved"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> ComponentEvent.COMPONENT_RESIZED:
        display.evnt[Display.COMPONENT] = 
          <font color=#004488>"Component resized"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> ComponentEvent.COMPONENT_HIDDEN:
        display.evnt[Display.COMPONENT] = 
          <font color=#004488>"Component hidden"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> ComponentEvent.COMPONENT_SHOWN:
        display.evnt[Display.COMPONENT] = 
          <font color=#004488>"Component shown"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>default</font>:
    }
    repaint();
    <font color=#009900>// Must always remember to call the "super"</font>
    <font color=#009900>// version of whatever you override:</font>
    <font color=#0000ff>super</font>.processComponentEvent(e);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> processFocusEvent(FocusEvent e) {
    <font color=#0000ff>switch</font>(e.getID()) {
      <font color=#0000ff>case</font> FocusEvent.FOCUS_GAINED:
        display.evnt[Display.FOCUS] = 
          <font color=#004488>"FOCUS gained"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> FocusEvent.FOCUS_LOST:
        display.evnt[Display.FOCUS] = 
          <font color=#004488>"FOCUS lost"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>default</font>:
    }
    repaint();
    <font color=#0000ff>super</font>.processFocusEvent(e);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> processKeyEvent(KeyEvent e) {
    <font color=#0000ff>switch</font>(e.getID()) {
      <font color=#0000ff>case</font> KeyEvent.KEY_PRESSED:
        display.evnt[Display.KEY] = 
          <font color=#004488>"KEY pressed: "</font>; 
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> KeyEvent.KEY_RELEASED:
        display.evnt[Display.KEY] = 
          <font color=#004488>"KEY released: "</font>; 
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> KeyEvent.KEY_TYPED:
        display.evnt[Display.KEY] = 
          <font color=#004488>"KEY typed: "</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>default</font>:
    }
    <font color=#0000ff>int</font> code = e.getKeyCode();
    display.evnt[Display.KEY] += 
      KeyEvent.getKeyText(code);
    repaint();
    <font color=#0000ff>super</font>.processKeyEvent(e);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> processMouseEvent(MouseEvent e) {
    <font color=#0000ff>switch</font>(e.getID()) {
      <font color=#0000ff>case</font> MouseEvent.MOUSE_CLICKED:
        requestFocus(); <font color=#009900>// Get FOCUS on click</font>
        display.evnt[Display.MOUSE] = 
          <font color=#004488>"MOUSE clicked"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> MouseEvent.MOUSE_PRESSED:
        display.evnt[Display.MOUSE] = 
          <font color=#004488>"MOUSE pressed"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> MouseEvent.MOUSE_RELEASED:
        display.evnt[Display.MOUSE] = 
          <font color=#004488>"MOUSE released"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> MouseEvent.MOUSE_ENTERED: 
        display.evnt[Display.MOUSE] = 
          <font color=#004488>"MOUSE entered"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> MouseEvent.MOUSE_EXITED: 
        display.evnt[Display.MOUSE] = 
          <font color=#004488>"MOUSE exited"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>default</font>:
    }
    display.evnt[Display.MOUSE] += 
      <font color=#004488>", x = "</font> + e.getX() + 
      <font color=#004488>", y = "</font> + e.getY();
    repaint();
    <font color=#0000ff>super</font>.processMouseEvent(e);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font>
  processMouseMotionEvent(MouseEvent e) {
    <font color=#0000ff>switch</font>(e.getID()) {
      <font color=#0000ff>case</font> MouseEvent.MOUSE_DRAGGED:
        display.evnt[Display.MOUSE_MOVE] = 
          <font color=#004488>"MOUSE dragged"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> MouseEvent.MOUSE_MOVED:
        display.evnt[Display.MOUSE_MOVE] = 
          <font color=#004488>"MOUSE moved"</font>;
        <font color=#0000ff>break</font>;
      <font color=#0000ff>default</font>:
    }
    display.evnt[Display.MOUSE_MOVE] += 
      <font color=#004488>", x = "</font> + e.getX() + 
      <font color=#004488>", y = "</font> + e.getY();
    repaint();
    <font color=#0000ff>super</font>.processMouseMotionEvent(e);
  }
}

<font color=#0000ff>class</font> MyButton <font color=#0000ff>extends</font> Button {
  <font color=#0000ff>int</font> clickCounter;
  String label = <font color=#004488>""</font>;
  <font color=#0000ff>public</font> MyButton() {
    enableEvents(AWTEvent.ACTION_EVENT_MASK);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics g) {
    g.setColor(Color.green);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
    g.setColor(Color.black);
    g.drawRect(0, 0, s.width - 1, s.height - 1);
    drawLabel(g);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> drawLabel(Graphics g) {
    FontMetrics fm = g.getFontMetrics();
    <font color=#0000ff>int</font> width = fm.stringWidth(label);
    <font color=#0000ff>int</font> height = fm.getHeight();
    <font color=#0000ff>int</font> ascent = fm.getAscent();
    <font color=#0000ff>int</font> leading = fm.getLeading();
    <font color=#0000ff>int</font> horizMargin = 
      (getSize().width - width)/2;
    <font color=#0000ff>int</font> verMargin = 
      (getSize().height - height)/2;
    g.setColor(Color.red);
    g.drawString(label, horizMargin, 
                 verMargin + ascent + leading);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> processActionEvent(ActionEvent e) {
    clickCounter++;
    label = <font color=#004488>"click #"</font> + clickCounter +
      <font color=#004488>" "</font> + e.toString();
    repaint();
    <font color=#0000ff>super</font>.processActionEvent(e);
  }
}
  
<font color=#0000ff>public</font> <font color=#0000ff>class</font> BadTechnique <font color=#0000ff>extends</font> Frame {
  BadTechnique() {
    setLayout(<font color=#0000ff>new</font> GridLayout(2,2));
    add(<font color=#0000ff>new</font> EnabledPanel(1, Color.cyan));
    add(<font color=#0000ff>new</font> EnabledPanel(2, Color.lightGray));
    add(<font color=#0000ff>new</font> EnabledPanel(3, Color.yellow));
    <font color=#009900>// You can also do it for Windows:</font>
    enableEvents(AWTEvent.WINDOW_EVENT_MASK);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> processWindowEvent(WindowEvent e) {
    System.out.println(e);
    <font color=#0000ff>if</font>(e.getID() == WindowEvent.WINDOW_CLOSING) {
      System.out.println(<font color=#004488>"Window Closing"</font>);
      System.exit(0);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame f = <font color=#0000ff>new</font> BadTechnique();
    f.setTitle(<font color=#004488>"Bad Technique"</font>);
    f.setSize(700,700);
    f.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sure, it works. But it&#8217;s ugly
and hard to write, read, debug, maintain, and reuse. So why bother when you can
use inner listener classes?</FONT><A NAME="_Toc408018713"></A><BR></P></DIV>
<A NAME="Heading446"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Java 1.1 UI APIs</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1<A NAME="Index2107"></A>
has also added some important new functionality, including focus traversal,
desktop color access, printing &#8220;inside the sandbox,&#8221; and the
beginnings of clipboard support.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index2108"></A><A NAME="Index2109"></A><FONT FACE="Georgia">Focus
traversal is quite easy, since it&#8217;s transparently present in the AWT
library components and you don&#8217;t have to do anything to make it work. If
you make your own components and want them to handle focus traversal, you
override
<A NAME="Index2110"></A><A NAME="Index2111"></A><B>isFocusTraversable(&#160;)</B>
to return <B>true</B>. If you want to capture the keyboard focus on a mouse
click, you catch the mouse down event and call
<A NAME="Index2112"></A><A NAME="Index2113"></A><B>requestFocus(&#160;)</B>.</FONT><A NAME="_Toc408018714"></A><BR></P></DIV>
<A NAME="Heading447"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Desktop colors</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index2114"></A><A NAME="Index2115"></A><A NAME="Index2116"></A>desktop
colors provide a way for you to know what the various color choices are on the
current user&#8217;s desktop. This way, you can use those colors in your program
if you desire. The colors are automatically initialized and placed in
<B>static</B> members of class <B>SystemColor</B>, so all you need to do is read
the member you&#8217;re interested in. The names are intentionally
self-explanatory: <B>desktop</B>, <B>activeCaption</B>,
<B>activeCaptionText</B>, <B>activeCaptionBorder</B>, <B>inactiveCaption</B>,
<B>inactiveCaptionText</B>, <B>inactiveCaptionBorder</B>, <B>window</B>,
<B>windowBorder</B>, <B>windowText</B>, <B>menu</B>, <B>menuText</B>,
<B>text</B>, <B>textText</B>, <B>textHighlight</B>, <B>textHighlightText</B>,
<B>textInactiveText</B>, <B>control</B>, <B>controlText</B>,
<B>controlHighlight</B>, <B>controlLtHighlight</B>, <B>controlShadow</B>,
<B>controlDkShadow</B>, <B>scrollbar</B>, <B>info </B>(for help), and
<B>infoText </B>(for help text).</FONT><A NAME="_Toc408018715"></A><BR></P></DIV>
<A NAME="Heading448"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Printing</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Unfortunately, there isn&#8217;t
much that&#8217;s automatic with printing. Instead you must go through a number
of mechanical, non-OO steps in order to print. Printing a component graphically
can be slightly more automatic: by default, the
<A NAME="Index2117"></A><A NAME="Index2118"></A><B>print(&#160;)</B> method
calls <A NAME="Index2119"></A><A NAME="Index2120"></A><B>paint(&#160;)</B> to do
its work. There are times when this is satisfactory, but if you want to do
anything more specialized you must know that you&#8217;re printing so you can in
particular find out the page dimensions.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example demonstrates
the printing of both text and graphics, and the different approaches you can use
for printing graphics. In addition, it tests the printing
support:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PrintDemo.java</font>
<font color=#009900>// Printing with Java 1.1</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrintDemo <font color=#0000ff>extends</font> Frame {
  Button 
    printText = <font color=#0000ff>new</font> Button(<font color=#004488>"Print Text"</font>),
    printGraphics = <font color=#0000ff>new</font> Button(<font color=#004488>"Print Graphics"</font>);
  TextField ringNum = <font color=#0000ff>new</font> TextField(3);
  Choice faces = <font color=#0000ff>new</font> Choice();
  Graphics g = <font color=#0000ff>null</font>;
  Plot plot = <font color=#0000ff>new</font> Plot3(); <font color=#009900>// Try different plots</font>
  Toolkit tk = Toolkit.getDefaultToolkit();
  <font color=#0000ff>public</font> PrintDemo() {
    ringNum.setText(<font color=#004488>"3"</font>);
    ringNum.addTextListener(<font color=#0000ff>new</font> RingL());
    Panel p = <font color=#0000ff>new</font> Panel();
    p.setLayout(<font color=#0000ff>new</font> FlowLayout());
    printText.addActionListener(<font color=#0000ff>new</font> TBL());
    p.add(printText);
    p.add(<font color=#0000ff>new</font> Label(<font color=#004488>"Font:"</font>));
    p.add(faces);
    printGraphics.addActionListener(<font color=#0000ff>new</font> GBL());
    p.add(printGraphics);
    p.add(<font color=#0000ff>new</font> Label(<font color=#004488>"Rings:"</font>));
    p.add(ringNum);
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    add(p, BorderLayout.NORTH);
    add(plot, BorderLayout.CENTER);
    String[] fontList = tk.getFontList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; fontList.length; i++)
      faces.add(fontList[i]);
    faces.select(<font color=#004488>"Serif"</font>);
  }
  <font color=#0000ff>class</font> PrintData {
    <font color=#0000ff>public</font> PrintJob pj;
    <font color=#0000ff>public</font> <font color=#0000ff>int</font> pageWidth, pageHeight;
    PrintData(String jobName) {
      pj = getToolkit().getPrintJob(
        PrintDemo.<font color=#0000ff>this</font>, jobName, <font color=#0000ff>null</font>);
      <font color=#0000ff>if</font>(pj != <font color=#0000ff>null</font>) {
        pageWidth = pj.getPageDimension().width;
        pageHeight= pj.getPageDimension().height;
        g = pj.getGraphics();
      }
    }
    <font color=#0000ff>void</font> end() { pj.end(); }
  }
  <font color=#0000ff>class</font> ChangeFont {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> stringHeight;
    ChangeFont(String face, <font color=#0000ff>int</font> style,<font color=#0000ff>int</font> point){
      <font color=#0000ff>if</font>(g != <font color=#0000ff>null</font>) {
        g.setFont(<font color=#0000ff>new</font> Font(face, style, point));
        stringHeight = 
          g.getFontMetrics().getHeight();
      }
    }
    <font color=#0000ff>int</font> stringWidth(String s) {
      <font color=#0000ff>return</font> g.getFontMetrics().stringWidth(s);
    }
    <font color=#0000ff>int</font> stringHeight() { <font color=#0000ff>return</font> stringHeight; }
  }
  <font color=#0000ff>class</font> TBL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      PrintData pd = 
        <font color=#0000ff>new</font> PrintData(<font color=#004488>"Print Text Test"</font>);
      <font color=#009900>// Null means print job canceled:</font>
      <font color=#0000ff>if</font>(pd == <font color=#0000ff>null</font>) <font color=#0000ff>return</font>;
      String s = <font color=#004488>"PrintDemo"</font>;
      ChangeFont cf = <font color=#0000ff>new</font> ChangeFont(
        faces.getSelectedItem(), Font.ITALIC,72);
      g.drawString(s, 
        (pd.pageWidth - cf.stringWidth(s)) / 2,
        (pd.pageHeight - cf.stringHeight()) / 3);

      s = <font color=#004488>"A smaller point size"</font>;
      cf = <font color=#0000ff>new</font> ChangeFont(
        faces.getSelectedItem(), Font.BOLD, 48);
      g.drawString(s, 
        (pd.pageWidth - cf.stringWidth(s)) / 2,
        (<font color=#0000ff>int</font>)((pd.pageHeight - 
           cf.stringHeight())/1.5));
      g.dispose();
      pd.end();
    }
  }
  <font color=#0000ff>class</font> GBL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      PrintData pd = 
        <font color=#0000ff>new</font> PrintData(<font color=#004488>"Print Graphics Test"</font>);
      <font color=#0000ff>if</font>(pd == <font color=#0000ff>null</font>) <font color=#0000ff>return</font>;
      plot.print(g);
      g.dispose();
      pd.end();
    }
  }
  <font color=#0000ff>class</font> RingL <font color=#0000ff>implements</font> TextListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> textValueChanged(TextEvent e) {
      <font color=#0000ff>int</font> i = 1;
      <font color=#0000ff>try</font> {
        i = Integer.parseInt(ringNum.getText());
      } <font color=#0000ff>catch</font>(NumberFormatException ex) {
        i = 1;
      }
      plot.rings = i;
      plot.repaint();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Frame pdemo = <font color=#0000ff>new</font> PrintDemo();
    pdemo.setTitle(<font color=#004488>"Print Demo"</font>);
    pdemo.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    pdemo.setSize(500, 500);
    pdemo.setVisible(<font color=#0000ff>true</font>);
  }
}

<font color=#0000ff>class</font> Plot <font color=#0000ff>extends</font> Canvas {
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> rings = 3;
}

<font color=#0000ff>class</font> Plot1 <font color=#0000ff>extends</font> Plot {
  <font color=#009900>// Default print() calls paint():</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics g) {
    <font color=#0000ff>int</font> w = getSize().width;
    <font color=#0000ff>int</font> h = getSize().height;
    <font color=#0000ff>int</font> xc = w / 2;
    <font color=#0000ff>int</font> yc = w / 2;
    <font color=#0000ff>int</font> x = 0, y = 0;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; rings; i++) {
      <font color=#0000ff>if</font>(x &lt; xc &amp;&amp; y &lt; yc) {
        g.drawOval(x, y, w, h);
        x += 10; y += 10;
        w -= 20; h -= 20;
      }
    }
  }
} 

<font color=#0000ff>class</font> Plot2 <font color=#0000ff>extends</font> Plot {
  <font color=#009900>// To fit the picture to the page, you must</font>
  <font color=#009900>// know whether you're printing or painting:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics g) {
    <font color=#0000ff>int</font> w, h;
    <font color=#0000ff>if</font>(g <font color=#0000ff>instanceof</font> PrintGraphics) {
      PrintJob pj = 
        ((PrintGraphics)g).getPrintJob();
      w = pj.getPageDimension().width;
      h = pj.getPageDimension().height;
    } 
    <font color=#0000ff>else</font> {
      w = getSize().width;
      h = getSize().height;
    }
    <font color=#0000ff>int</font> xc = w / 2;
    <font color=#0000ff>int</font> yc = w / 2;
    <font color=#0000ff>int</font> x = 0, y = 0;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; rings; i++) {
      <font color=#0000ff>if</font>(x &lt; xc &amp;&amp; y &lt; yc) {
        g.drawOval(x, y, w, h);
        x += 10; y += 10;
        w -= 20; h -= 20;
      }
    }
  }
} 

<font color=#0000ff>class</font> Plot3 <font color=#0000ff>extends</font> Plot {
  <font color=#009900>// Somewhat better. Separate </font>
  <font color=#009900>// printing from painting:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(Graphics g) {
    <font color=#009900>// Assume it's a PrintGraphics object:</font>
    PrintJob pj = 
      ((PrintGraphics)g).getPrintJob();
    <font color=#0000ff>int</font> w = pj.getPageDimension().width;
    <font color=#0000ff>int</font> h = pj.getPageDimension().height;
    doGraphics(g, w, h);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics g) {
    <font color=#0000ff>int</font> w = getSize().width;
    <font color=#0000ff>int</font> h = getSize().height;
    doGraphics(g, w, h);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> doGraphics(
      Graphics g, <font color=#0000ff>int</font> w, <font color=#0000ff>int</font> h) {
    <font color=#0000ff>int</font> xc = w / 2;
    <font color=#0000ff>int</font> yc = w / 2;
    <font color=#0000ff>int</font> x = 0, y = 0;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; rings; i++) {
      <font color=#0000ff>if</font>(x &lt; xc &amp;&amp; y &lt; yc) {
        g.drawOval(x, y, w, h);
        x += 10; y += 10;
        w -= 20; h -= 20;
      }
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The program allows you to select
fonts from a <B>Choice</B> list (and you&#8217;ll see that the number of fonts
available in Java 1.1<A NAME="Index2121"></A> is still extremely limited, and
has nothing to do with any extra fonts you install on your machine). It uses
these to print out text in bold, italic, and in different sizes. In addition, a
new type of component called a <B>Plot</B> is created to demonstrate graphics. A
<B>Plot</B> has rings that it will display on the screen and print onto paper,
and the three derived classes <B>Plot1</B>, <B>Plot2,</B> and <B>Plot3</B>
perform these tasks in different ways so that you can see your alternatives when
printing graphics. Also, you can change the number of rings in a plot &#8211;
this is interesting because it shows the printing fragility in Java
1.1<A NAME="Index2122"></A>. On my system, the printer gave error messages and
didn&#8217;t print correctly when the ring count got &#8220;too high&#8221;
(whatever that means), but worked fine when the count was &#8220;low
enough.&#8221; You will notice, too, that the page dimensions produced when
printing do not seem to correspond to the actual dimensions of the page. This
might be fixed in a future release of Java, and you can use this program to test
it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program encapsulates
functionality inside inner classes whenever possible, to facilitate reuse. For
example, whenever you want to begin a print job (whether for graphics or text),
you must create a
<A NAME="Index2123"></A><A NAME="Index2124"></A><B>PrintJob</B> object, which
has its own <B>Graphics </B>object along with the width and height of the page.
The creation of a <B>PrintJob</B> and extraction of page dimensions is
encapsulated in the <B>PrintData</B> class.</FONT><BR></P></DIV>
<A NAME="Heading449"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Printing text</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Conceptually,
<A NAME="Index2125"></A><A NAME="Index2126"></A>printing text is
straightforward: you choose a typeface and size, decide where the string should
go on the page, and draw it with <B>Graphics.drawString(&#160;)</B>. This means,
however, that you must perform the calculations of exactly where each line will
go on the page to make sure it doesn&#8217;t run off the end of the page or
collide with other lines. If you want to make a word processor, your work is cut
out for you.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ChangeFont</B> encapsulates a
little of the process of changing from one font to another by automatically
creating a new <A NAME="Index2127"></A><A NAME="Index2128"></A><B>Font</B>
object with your desired typeface, style (<B>Font.BOLD</B> or <B>Font.ITALIC</B>
&#8211; there&#8217;s no support for underline, strikethrough, etc.), and point
size. It also simplifies the calculation of the width and height of a
string.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you press the &#8220;Print
text&#8221; button, the <B>TBL </B>listener is activated. You can see that it
goes through two iterations of creating a <B>ChangeFont</B> object and calling
<B>drawString(&#160;)</B> to print out the string in a calculated position,
centered, one-third, and two-thirds down the page, respectively. Notice whether
these calculations produce the expected results. (They didn&#8217;t with the
version I used.)</FONT><BR></P></DIV>
<A NAME="Heading450"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Printing graphics</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you press the &#8220;Print
graphics&#8221; button the <B>GBL</B> listener is activated. The creation of a
<B>PrintData</B> object initializes <B>g</B>, and then you simply call
<B>print(&#160;)</B> for the component you want to print. To force printing you
must call <A NAME="Index2129"></A><A NAME="Index2130"></A><B>dispose(&#160;)</B>
for the <A NAME="Index2131"></A><A NAME="Index2132"></A><B>Graphics</B> object
and <A NAME="Index2133"></A><A NAME="Index2134"></A><B>end(&#160;)</B> for the
<B>PrintData</B> object (which turns around and calls <B>end(&#160;)</B> for the
<B>PrintJob</B>).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The work is going on inside the
<B>Plot</B> object. You can see that the base-class <B>Plot</B> is simple
&#8211; it extends <B>Canvas</B> and contains an <B>int</B> called <B>rings</B>
to indicate how many concentric rings to draw on this particular <B>Canvas</B>.
The three derived classes show different approaches to accomplishing the same
goal: drawing on both the screen and on the printed page.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Plot1 </B>takes the simplest
approach to coding: ignore the fact that there are differences in painting and
printing, and just override
<A NAME="Index2135"></A><A NAME="Index2136"></A><B>paint(&#160;)</B>. The reason
this works is that the default<B>
<A NAME="Index2137"></A><A NAME="Index2138"></A>print(&#160;)</B> method simply
turns around and calls <B>paint(&#160;)</B>. However, you&#8217;ll notice that
the size of the output depends on the size of the on-screen canvas, which makes
sense since the <B>width</B> and <B>height</B> are determined by calling
<B>Canvas.getSize(&#160;)</B>. The other situation in which this is acceptable
is if your image is always a fixed size.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the size of the drawing
surface is important, then you must discover the dimensions. Unfortunately, this
turns out to be awkward, as you can see in <B>Plot2</B>. For some possibly good
reason that I don&#8217;t know, you cannot simply ask the <B>Graphics</B> object
the dimensions of its drawing surface. This would have made the whole process
quite elegant. Instead, to see if you&#8217;re printing rather than painting,
you must detect the
<A NAME="Index2139"></A><A NAME="Index2140"></A><B>PrintGraphics</B> using the
RTTI <B>instanceof</B> keyword (described in Chapter 11), then downcast and call
the sole <B>PrintGraphics</B> method:
<A NAME="Index2141"></A><A NAME="Index2142"></A><B>getPrintJob(&#160;)</B>. Now
you have a handle to the <B>PrintJob</B> and you can find out the width and
height of the paper. This is a hacky approach, but perhaps there is some
rational reason for it. (On the other hand, you&#8217;ve seen some of the other
library designs by now so you might get the impression that the designers were,
in fact, just hacking around...)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that
<B>paint(&#160;)</B> in <B>Plot2 </B>goes through both possibilities of printing
or painting. But since the <B>print(&#160;)</B> method should be called when
printing, why not use that? This approach is used in <B>Plot3</B>, and it
eliminates the need to use <B>instanceof</B> since inside <B>print(&#160;)</B>
you can assume that you can cast to a <B>PrintGraphics</B> object. This is a
little better. The situation is improved by placing the common drawing code
(once the dimensions have been detected) inside a separate method
<B>doGraphics(&#160;)</B>.</FONT><BR></P></DIV>
<A NAME="Heading451"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Running Frames within applets</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What if you&#8217;d like to print
from within an applet? Well, to print anything you must get a <B>PrintJob</B>
object through a <A NAME="Index2143"></A><A NAME="Index2144"></A><B>Toolkit</B>
object&#8217;s
<A NAME="Index2145"></A><A NAME="Index2146"></A><B>getPrintJob(&#160;)</B>
method, which takes only a <B>Frame</B> object and not an <B>Applet</B>. Thus it
would seem that it&#8217;s possible to print from within an application, but not
an applet. However, it turns out that you can
<A NAME="Index2147"></A><A NAME="Index2148"></A>create a <B>Frame</B> from
within an applet (which is the reverse of what I&#8217;ve been doing for the
applet/application examples so far, which has been making an applet and putting
inside a <B>Frame</B>). This is a useful technique since it allows you to use
many <A NAME="Index2149"></A>applications within applets (as long as they
don&#8217;t violate applet security). When the application window comes up
within an applet, however, you&#8217;ll notice that the Web browser sticks a
little caveat on it, something to the effect of &#8220;Warning: Applet
Window.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that it&#8217;s quite
straightforward to put a <B>Frame</B> inside an applet. The only thing that you
must add is code to
<A NAME="Index2150"></A><A NAME="Index2151"></A><B>dispose(&#160;)</B> of the
<B>Frame</B> when the user closes it (instead of calling
<B>System.exit(&#160;)</B>):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PrintDemoApplet.java</font>
<font color=#009900>// Creating a Frame from within an Applet</font>
<font color=#0000ff>import</font> java.applet.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrintDemoApplet <font color=#0000ff>extends</font> Applet {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    Button b = <font color=#0000ff>new</font> Button(<font color=#004488>"Run PrintDemo"</font>);
    b.addActionListener(<font color=#0000ff>new</font> PDL());
    add(b);
  }
  <font color=#0000ff>class</font> PDL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>final</font> PrintDemo pd = <font color=#0000ff>new</font> PrintDemo();
      pd.addWindowListener(<font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e){
          pd.dispose();
        }
      });
      pd.setSize(500, 500);
      pd.show();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s some confusion
involved with Java 1.1<A NAME="Index2152"></A>
<A NAME="Index2153"></A><A NAME="Index2154"></A>printing support. Some of the
publicity seemed to claim that you&#8217;d be able to print from within an
applet. However, the Java security system contains a feature that could lock out
an applet from initiating its own print job, requiring that the initiation be
done via a Web browser or applet viewer. At the time of this writing, this
seemed to remain an unresolved issue. When I ran this program from within a Web
browser, the <B>PrintDemo</B> window came up just fine, but it wouldn&#8217;t
print from the browser.</FONT><A NAME="_Toc408018716"></A><BR></P></DIV>
<A NAME="Heading452"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The clipboard</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1<A NAME="Index2155"></A>
supports limited operations with the
<A NAME="Index2156"></A><A NAME="Index2157"></A><A NAME="Index2158"></A>system
clipboard (in the <B>java.awt.datatransfer </B>package). You can copy
<B>String</B> objects to the clipboard as text, and you can paste text from the
clipboard into <B>String</B> objects. Of course, the clipboard is designed to
hold any type of data, but how this data is represented on the clipboard is up
to the program doing the cutting and pasting. Although it currently supports
only string data, the Java clipboard API provides for extensibility through the
concept of a &#8220;flavor.&#8221; When data comes off the clipboard, it has an
associated set of <A NAME="Index2159"></A><A NAME="Index2160"></A>flavors that
it can be converted to (for example, a graph might be represented as a string of
numbers or as an image) and you can see if that particular clipboard data
supports the flavor you&#8217;re interested in.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following program is a simple
demonstration of cut, copy, and paste with <B>String</B> data in a
<A NAME="Index2161"></A><A NAME="Index2162"></A><B>TextArea</B>. One thing
you&#8217;ll notice is that the keyboard sequences you normally use for cutting,
copying, and pasting also work. But if you look at any <B>TextField</B> or
<B>TextArea</B> in any other program you&#8217;ll find that they also
automatically support the clipboard key sequences. This example simply adds
programmatic control of the clipboard, and you could use these techniques if you
want to capture clipboard text into some
non-<B>TextComponent</B>.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CutAndPaste.java</font>
<font color=#009900>// Using the clipboard from Java 1.1</font>
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.awt.datatransfer.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CutAndPaste <font color=#0000ff>extends</font> Frame {
  MenuBar mb = <font color=#0000ff>new</font> MenuBar();
  Menu edit = <font color=#0000ff>new</font> Menu(<font color=#004488>"Edit"</font>);
  MenuItem
    cut = <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Cut"</font>),
    copy = <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Copy"</font>),
    paste = <font color=#0000ff>new</font> MenuItem(<font color=#004488>"Paste"</font>);
  TextArea text = <font color=#0000ff>new</font> TextArea(20,20);
  Clipboard clipbd = 
    getToolkit().getSystemClipboard();
  <font color=#0000ff>public</font> CutAndPaste() {
    cut.addActionListener(<font color=#0000ff>new</font> CutL());
    copy.addActionListener(<font color=#0000ff>new</font> CopyL());
    paste.addActionListener(<font color=#0000ff>new</font> PasteL());
    edit.add(cut);
    edit.add(copy);
    edit.add(paste);
    mb.add(edit);
    setMenuBar(mb);
    add(text, BorderLayout.CENTER);
  }
  <font color=#0000ff>class</font> CopyL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      String selection = text.getSelectedText();
      StringSelection clipString = 
        <font color=#0000ff>new</font> StringSelection(selection);
      clipbd.setContents(clipString, clipString);
    }
  }
  <font color=#0000ff>class</font> CutL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      String selection = text.getSelectedText();
      StringSelection clipString = 
        <font color=#0000ff>new</font> StringSelection(selection);
      clipbd.setContents(clipString, clipString);
      text.replaceRange(<font color=#004488>""</font>, 
        text.getSelectionStart(), 
        text.getSelectionEnd());
    }
  }
  <font color=#0000ff>class</font> PasteL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      Transferable clipData =
        clipbd.getContents(CutAndPaste.<font color=#0000ff>this</font>);
      <font color=#0000ff>try</font> {
        String clipString = 
          (String)clipData.
            getTransferData(
              DataFlavor.stringFlavor);
        text.replaceRange(clipString, 
          text.getSelectionStart(), 
          text.getSelectionEnd());
      } <font color=#0000ff>catch</font>(Exception ex) {
        System.out.println(<font color=#004488>"not String flavor"</font>);
      }
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CutAndPaste cp = <font color=#0000ff>new</font> CutAndPaste();
    cp.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    cp.setSize(300,200);
    cp.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The creation and addition of the
menu and <B>TextArea</B> should by now seem a pedestrian activity. What&#8217;s
different is the creation of the <B>Clipboard</B> field <B>clipbd</B>, which is
done through the <B>Toolkit</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the action takes place in the
listeners. The <B>CopyL</B> and <B>CutL</B> listeners are the same except for
the last line of <B>CutL</B>, which erases the line that&#8217;s been copied.
The special two lines are the creation of a
<A NAME="Index2163"></A><A NAME="Index2164"></A><B>StringSelection</B> object
from the <B>String</B> and the call to
<A NAME="Index2165"></A><A NAME="Index2166"></A><B>setContents(&#160;)</B> with
this <B>StringSelection</B>. That&#8217;s all there is to putting a
<B>String</B> on the clipboard.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>PasteL,</B> data is pulled
off the clipboard using
<A NAME="Index2167"></A><A NAME="Index2168"></A><B>getContents(&#160;)</B>. What
comes back is a fairly anonymous
<A NAME="Index2169"></A><A NAME="Index2170"></A><B>Transferable</B> object, and
you don&#8217;t really know what it contains. One way to find out is to call
<A NAME="Index2171"></A><A NAME="Index2172"></A><B>getTransferDataFlavors(&#160;)</B>,
which returns an array of
<A NAME="Index2173"></A><A NAME="Index2174"></A><B>DataFlavor</B> objects
indicating which flavors are supported by this particular object. You can also
ask it directly with
<A NAME="Index2175"></A><A NAME="Index2176"></A><B>isDataFlavorSupported(&#160;)</B>,
passing in the flavor you&#8217;re interested in. Here, however, the bold
approach is taken:
<A NAME="Index2177"></A><A NAME="Index2178"></A><B>getTransferData(&#160;)</B>
is called assuming that the contents supports the <B>String</B> flavor, and if
it doesn&#8217;t the problem is sorted out in the exception
handler.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the future you can expect more
data flavors to be supported.</FONT><A NAME="_Toc408018717"></A><BR></P></DIV>
<A NAME="Heading453"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Visual programming <BR>and Beans</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So far in this book you&#8217;ve
seen how valuable <A NAME="Index2179"></A>Java is for creating
<A NAME="Index2180"></A>reusable pieces of code. The &#8220;most reusable&#8221;
unit of code has been the class, since it comprises a cohesive unit of
characteristics (fields) and behaviors (methods) that can be reused either
directly via composition or through inheritance.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Inheritance and polymorphism are
essential parts of object-oriented programming, but in the majority of cases
when you&#8217;re putting together an application, what you really want is
components that do exactly what you need. You&#8217;d like to drop these parts
into your design like the electronic engineer puts together chips on a circuit
board (or even, in the case of Java, onto a Web page). It seems, too, that there
should be some way to accelerate this &#8220;modular assembly&#8221; style of
programming.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">&#8220;<A NAME="Index2181"></A><A NAME="Index2182"></A>Visual
programming&#8221; first became successful &#8211; <I>very</I> successful
&#8211; with
<A NAME="Index2183"></A><A NAME="Index2184"></A><A NAME="Index2185"></A><A NAME="Index2186"></A>Microsoft&#8217;s
Visual Basic (VB), followed by a second-generation design in
<A NAME="Index2187"></A><A NAME="Index2188"></A><A NAME="Index2189"></A>Borland&#8217;s
Delphi (the primary inspiration for the Java Beans design). With these
programming tools the components are represented visually, which makes sense
since they usually display some kind of visual component such as a button or a
text field. The visual representation, in fact, is often exactly the way the
component will look in the running program. So part of the process of visual
programming involves dragging a component from a pallet and dropping it onto
your form. The <A NAME="Index2190"></A><A NAME="Index2191"></A>application
builder tool writes code as you do this, and that code will cause the component
to be created in the running program.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Simply dropping the component onto
a form is usually not enough to complete the program. Often, you must change the
characteristics of a component, such as what color it is, what text is on it,
what database it&#8217;s connected to, etc. Characteristics that can be modified
at design time are referred to as
<A NAME="Index2192"></A><A NAME="Index2193"></A><I>properties</I>. You can
manipulate the properties of your component inside the application builder tool,
and when you create the program this configuration data is saved so that it can
be rejuvenated when the program is started.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By now you&#8217;re probably used
to the idea that an object is more than characteristics; it&#8217;s also a set
of behaviors. At design-time, the behaviors of a visual component are partially
represented by <A NAME="Index2194"></A><A NAME="Index2195"></A><I>events</I>,
meaning &#8220;Here&#8217;s something that can happen to the component.&#8221;
Ordinarily, you decide what you want to happen when an event occurs by tying
code to that event.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the critical part: the
application builder tool is able to dynamically interrogate (using
<A NAME="Index2196"></A><A NAME="Index2197"></A>reflection) the component to
find out which properties and events the component supports. Once it knows what
they are, it can display the properties and allow you to change those (saving
the state when you build the program), and also display the events. In general,
you do something like double clicking on an event and the application builder
tool creates a code body and ties it to that particular event. All you have to
do at that point is write the code that executes when the event
occurs.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All this adds up to a lot of work
that&#8217;s done for you by the application builder tool. As a result you can
focus on what the program looks like and what it is supposed to do, and rely on
the application builder tool to manage the connection details for you. The
reason that visual programming tools have been so successful is that they
dramatically speed up the process of building an application &#8211; certainly
the user interface, but often other portions of the application as
well.</FONT><A NAME="_Toc408018718"></A><BR></P></DIV>
<A NAME="Heading454"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
What is a Bean?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After the dust settles, then, a
<A NAME="Index2198"></A><A NAME="Index2199"></A>component is really just a block
of code, typically embodied in a class. The key issue is the ability for the
application builder tool to discover the properties and events for that
component. To create a VB component, the programmer had to write a fairly
complicated piece of code following certain conventions to expose the properties
and events. Delphi was a second-generation visual programming tool and the
language was actively designed around visual programming so it is much easier to
create a visual component. However, Java has brought the creation of visual
components to its most advanced state with Java Beans, because a Bean is just a
class. You don&#8217;t have to write any extra code or use special language
extensions in order to make something a Bean. The only thing you need to do, in
fact, is slightly modify the way that you name your methods. It is the method
name that tells the application builder tool whether this is a property, an
event, or just an ordinary method.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the Java documentation, this
naming convention is mistakenly termed a &#8220;design pattern.&#8221; This is
unfortunate since design patterns (see Chapter 16) are challenging enough
without this sort of confusion. It&#8217;s not a design pattern, it&#8217;s just
a <A NAME="Index2200"></A>naming convention and it&#8217;s fairly
simple:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	For a property named <B>xxx</B>, you typically
create two methods: <B>getXxx(&#160;)</B> and <B>setXxx(&#160;)</B>. Note that
the first letter after get or set is automatically lowercased to produce the
property name. The type produced by the &#8220;get&#8221; method is the same as
the type of the argument to the &#8220;set&#8221; method. The name of the
property and the type for the &#8220;get&#8221; and &#8220;set&#8221; are not
related.</FONT><LI><FONT FACE="Georgia">	For a boolean property, you can
use the &#8220;get&#8221; and &#8220;set&#8221; approach above, but you can also
use &#8220;is&#8221; instead of
&#8220;get.&#8221;</FONT><LI><FONT FACE="Georgia">	Ordinary methods of the
Bean don&#8217;t conform to the above naming convention, but they&#8217;re
<B>public</B>.</FONT><LI><FONT FACE="Georgia">	For events, you use the
&#8220;listener&#8221; approach. It&#8217;s exactly the same as you&#8217;ve
been seeing: <B>addFooBarListener(FooBarListener)</B> and
<B>removeFooBarListener(FooBarListener)</B> to handle a <B>FooBarEvent</B>. Most
of the time the built-in events and listeners will satisfy your needs, but you
can also create your own events and listener
interfaces.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Point 1
above answers a question about something you might have noticed in the change
from Java 1.0<A NAME="Index2201"></A> to Java 1.1<A NAME="Index2202"></A>: a
number of method names have had small, apparently meaningless name changes. Now
you can see that most of those changes had to do with adapting to the
&#8220;get&#8221; and &#8220;set&#8221; naming conventions in order to make that
particular component into a Bean.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">We can use these guidelines to
create a simple Bean:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Frog.java</font>
<font color=#009900>// A trivial Java Bean</font>
<font color=#0000ff>package</font> frogbean;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;

<font color=#0000ff>class</font> Spots {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Frog {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> jumps;
  <font color=#0000ff>private</font> Color color;
  <font color=#0000ff>private</font> Spots spots;
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> jmpr;
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getJumps() { <font color=#0000ff>return</font> jumps; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setJumps(<font color=#0000ff>int</font> newJumps) { 
    jumps = newJumps;
  }
  <font color=#0000ff>public</font> Color getColor() { <font color=#0000ff>return</font> color; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(Color newColor) { 
    color = newColor; 
  }
  <font color=#0000ff>public</font> Spots getSpots() { <font color=#0000ff>return</font> spots; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setSpots(Spots newSpots) {
    spots = newSpots; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> isJumper() { <font color=#0000ff>return</font> jmpr; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setJumper(<font color=#0000ff>boolean</font> j) { jmpr = j; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> addActionListener(
      ActionListener l) {
    <font color=#009900>//...</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> removeActionListener(
      ActionListener l) {
    <font color=#009900>// ...</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> addKeyListener(KeyListener l) {
    <font color=#009900>// ...</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> removeKeyListener(KeyListener l) {
    <font color=#009900>// ...</font>
  }
  <font color=#009900>// An "ordinary" public method:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> croak() {
    System.out.println(<font color=#004488>"Ribbet!"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, you can see that it&#8217;s
just a class. Usually, all your fields will be <B>private</B>, and accessible
only through methods. Following the naming convention, the properties are
<B>jumps</B>, <B>color</B>, <B>spots</B>, and <B>jumper</B> (notice the change
in case of the first letter in the property name). Although the name of the
internal identifier is the same as the name of the property in the first three
cases, in <B>jumper</B> you can see that the property name does not force you to
use any particular name for internal variables (or, indeed, to even <I>have</I>
any internal variable for that property).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The events this Bean handles are
<B>ActionEvent</B> and <B>KeyEvent</B>, based on the naming of the
&#8220;add&#8221; and &#8220;remove&#8221; methods for the associated listener.
Finally, you can see that the ordinary method <B>croak(&#160;)</B> is still part
of the Bean simply because it&#8217;s a <B>public</B> method, not because it
conforms to any naming scheme.</FONT><A NAME="_Toc408018719"></A><BR></P></DIV>
<A NAME="Heading455"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Extracting BeanInfo <BR>with the Introspector</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the most critical parts of
the Bean scheme occurs when you drag a Bean off a palette and plop it down on a
form. The application builder tool must be able to create the Bean (which it can
do if there&#8217;s a default constructor) and then, without access to the
Bean&#8217;s source code, extract all the necessary information to create the
property sheet and event handlers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Part of the solution is already
evident from the end of Chapter 11: Java 1.1<A NAME="Index2203"></A>
<A NAME="Index2204"></A><A NAME="Index2205"></A><I>reflection</I> allows all the
methods of an anonymous class to be discovered. This is perfect for solving the
Bean problem without requiring you to use any extra language keywords like those
required in other visual programming languages. In fact, one of the prime
reasons that reflection was added to Java 1.1 was to support Beans (although
reflection also supports object serialization and remote method invocation). So
you might expect that the creator of the application builder tool would have to
reflect each Bean and hunt through its methods to find the properties and events
for that Bean.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is certainly possible, but the
Java designers wanted to provide a standard interface for everyone to use, not
only to make Beans simpler to use but also to provide a standard gateway to the
creation of more complex Beans. This interface is the
<A NAME="Index2206"></A><A NAME="Index2207"></A><B>Introspector</B> class, and
the most important method in this class is the <B>static
<A NAME="Index2208"></A><A NAME="Index2209"></A>getBeanInfo(&#160;)</B>. You
pass a <B>Class</B> handle to this method and it fully interrogates that class
and returns a <B>BeanInfo</B> object that you can then dissect to find
properties, methods, and events.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Usually you won&#8217;t care about
any of this &#8211; you&#8217;ll probably get most of your Beans off the shelf
from vendors, and you don&#8217;t need to know all the magic that&#8217;s going
on underneath. You&#8217;ll simply drag your Beans onto your form, then
configure their properties and write handlers for the events you&#8217;re
interested in. However, it&#8217;s an interesting and educational exercise to
use the <B>Introspector</B> to display information about a Bean, so here&#8217;s
a tool that does it (you&#8217;ll find it in the <B>frogbean</B>
subdirectory):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: BeanDumper.java</font>
<font color=#009900>// A method to introspect a Bean</font>
<font color=#0000ff>import</font> java.beans.*;
<font color=#0000ff>import</font> java.lang.reflect.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> BeanDumper {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> dump(Class bean){
    BeanInfo bi = <font color=#0000ff>null</font>;
    <font color=#0000ff>try</font> {
      bi = Introspector.getBeanInfo(
        bean, java.lang.Object.<font color=#0000ff>class</font>);
    } <font color=#0000ff>catch</font>(IntrospectionException ex) {
      System.out.println(<font color=#004488>"Couldn't introspect "</font> +
        bean.getName());
      System.exit(1);
    }
    PropertyDescriptor[] properties = 
      bi.getPropertyDescriptors();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; properties.length; i++) {
      Class p = properties[i].getPropertyType();
      System.out.println(
        <font color=#004488>"Property type:\n  "</font> + p.getName());
      System.out.println(
        <font color=#004488>"Property name:\n  "</font> + 
        properties[i].getName());
      Method readMethod = 
        properties[i].getReadMethod();
      <font color=#0000ff>if</font>(readMethod != <font color=#0000ff>null</font>)
        System.out.println(
          <font color=#004488>"Read method:\n  "</font> + 
          readMethod.toString());
      Method writeMethod = 
        properties[i].getWriteMethod();
      <font color=#0000ff>if</font>(writeMethod != <font color=#0000ff>null</font>)
        System.out.println(
          <font color=#004488>"Write method:\n  "</font> +
          writeMethod.toString());
      System.out.println(<font color=#004488>"===================="</font>);
    }
    System.out.println(<font color=#004488>"Public methods:"</font>);
    MethodDescriptor[] methods =
      bi.getMethodDescriptors();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; methods.length; i++)
      System.out.println(
        methods[i].getMethod().toString());
    System.out.println(<font color=#004488>"======================"</font>);
    System.out.println(<font color=#004488>"Event support:"</font>);
    EventSetDescriptor[] events = 
      bi.getEventSetDescriptors();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; events.length; i++) {
      System.out.println(<font color=#004488>"Listener type:\n  "</font> +
        events[i].getListenerType().getName());
      Method[] lm = 
        events[i].getListenerMethods();
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; lm.length; j++)
        System.out.println(
          <font color=#004488>"Listener method:\n  "</font> +
          lm[j].getName());
      MethodDescriptor[] lmd = 
        events[i].getListenerMethodDescriptors();
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; lmd.length; j++)
        System.out.println(
          <font color=#004488>"Method descriptor:\n  "</font> +
          lmd[j].getMethod().toString());
      Method addListener = 
        events[i].getAddListenerMethod();
      System.out.println(
          <font color=#004488>"Add Listener Method:\n  "</font> +
        addListener.toString());
      Method removeListener =
        events[i].getRemoveListenerMethod();
      System.out.println(
        <font color=#004488>"Remove Listener Method:\n  "</font> +
        removeListener.toString());
      System.out.println(<font color=#004488>"===================="</font>);
    }
  }
  <font color=#009900>// Dump the class of your choice:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length &lt; 1) {
      System.err.println(<font color=#004488>"usage: \n"</font> +
        <font color=#004488>"BeanDumper fully.qualified.class"</font>);
      System.exit(0);
    }
    Class c = <font color=#0000ff>null</font>;
    <font color=#0000ff>try</font> {
      c = Class.forName(args[0]);
    } <font color=#0000ff>catch</font>(ClassNotFoundException ex) {
      System.err.println(
        <font color=#004488>"Couldn't find "</font> + args[0]);
      System.exit(0);
    }
    dump(c);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BeanDumper.dump(&#160;)</B> is
the method that does all the work. First it tries to create a <B>BeanInfo</B>
object, and if successful calls the methods of <B>BeanInfo</B> that produce
information about properties, methods, and events. In
<B>Introspector.getBeanInfo(&#160;)</B>, you&#8217;ll see there is a second
argument. This tells the <B>Introspector</B> where to stop in the inheritance
hierarchy. Here, it stops before it parses all the methods from <B>Object</B>,
since we&#8217;re not interested in seeing those.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For properties,
<A NAME="Index2210"></A><A NAME="Index2211"></A><B>getPropertyDescriptors(&#160;)</B>
returns an array of
<A NAME="Index2212"></A><A NAME="Index2213"></A><B>PropertyDescriptor</B>s. For
each <B>PropertyDescriptor</B> you can call
<A NAME="Index2214"></A><A NAME="Index2215"></A><B>getPropertyType(&#160;)</B>
to find the class of object that is passed in and out via the property methods.
Then, for each property you can get its pseudonym (extracted from the method
names) with
<A NAME="Index2216"></A><A NAME="Index2217"></A><B>getName(&#160;)</B>, the
method for reading with
<A NAME="Index2218"></A><A NAME="Index2219"></A><B>getReadMethod(&#160;),</B>
and the method for writing with
<A NAME="Index2220"></A><A NAME="Index2221"></A><B>getWriteMethod(&#160;)</B>.
These last two methods return a <B>Method</B> object that can actually be used
to invoke the corresponding method on the object (this is part of
reflection).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For the public methods (including
the property methods),
<A NAME="Index2222"></A><A NAME="Index2223"></A><B>getMethodDescriptors(&#160;)</B>
returns an array of
<A NAME="Index2224"></A><A NAME="Index2225"></A><B>MethodDescriptor</B>s. For
each one you can get the associated
<A NAME="Index2226"></A><A NAME="Index2227"></A><B>Method</B> object and print
out its name.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For the events,
<A NAME="Index2228"></A><A NAME="Index2229"></A><B>getEventSetDescriptors(&#160;)</B>
returns an array of (what else?)
<A NAME="Index2230"></A><A NAME="Index2231"></A><B>EventSetDescriptor</B>s. Each
of these can be queried to find out the class of the listener, the methods of
that listener class, and the add- and remove-listener methods. The <B>BeanDumper
</B>program prints out all of this information.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you invoke <B>BeanDumper</B> on
the <B>Frog</B> class like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java BeanDumper frogbean.Frog</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">the output, after removing extra
details that are unnecessary here, is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> name: Frog
Property type:
  Color
Property name:
  color
Read method:
  <font color=#0000ff>public</font> Color getColor()
Write method:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(Color)
====================
Property type:
  Spots
Property name:
  spots
Read method:
  <font color=#0000ff>public</font> Spots getSpots()
Write method:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setSpots(Spots)
====================
Property type:
  <font color=#0000ff>boolean</font>
Property name:
  jumper
Read method:
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> isJumper()
Write method:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setJumper(<font color=#0000ff>boolean</font>)
====================
Property type:
  <font color=#0000ff>int</font>
Property name:
  jumps
Read method:
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getJumps()
Write method:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setJumps(<font color=#0000ff>int</font>)
====================
Public methods:
<font color=#0000ff>public</font> <font color=#0000ff>void</font> setJumps(<font color=#0000ff>int</font>)
<font color=#0000ff>public</font> <font color=#0000ff>void</font> croak()
<font color=#0000ff>public</font> <font color=#0000ff>void</font> removeActionListener(ActionListener)
<font color=#0000ff>public</font> <font color=#0000ff>void</font> addActionListener(ActionListener)
<font color=#0000ff>public</font> <font color=#0000ff>int</font> getJumps()
<font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(Color)
<font color=#0000ff>public</font> <font color=#0000ff>void</font> setSpots(Spots)
<font color=#0000ff>public</font> <font color=#0000ff>void</font> setJumper(<font color=#0000ff>boolean</font>)
<font color=#0000ff>public</font> <font color=#0000ff>boolean</font> isJumper()
<font color=#0000ff>public</font> <font color=#0000ff>void</font> addKeyListener(KeyListener)
<font color=#0000ff>public</font> Color getColor()
<font color=#0000ff>public</font> <font color=#0000ff>void</font> removeKeyListener(KeyListener)
<font color=#0000ff>public</font> Spots getSpots()
======================
Event support:
Listener type:
  KeyListener
Listener method:
  keyTyped
Listener method:
  keyPressed
Listener method:
  keyReleased
Method descriptor:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> keyTyped(KeyEvent)
Method descriptor:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> keyPressed(KeyEvent)
Method descriptor:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> keyReleased(KeyEvent)
Add Listener Method:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> addKeyListener(KeyListener)
Remove Listener Method:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> removeKeyListener(KeyListener)
====================
Listener type:
  ActionListener
Listener method:
  actionPerformed
Method descriptor:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent)
Add Listener Method:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> addActionListener(ActionListener)
Remove Listener Method:
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> removeActionListener(ActionListener)
====================</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This reveals most of what the
<B>Introspector</B> sees as it produces a <B>BeanInfo</B> object from your Bean.
You can see that the type of the property and its name are independent. Notice
the lowercasing of the property name. (The only time this doesn&#8217;t occur is
when the property name begins with more than one capital letter in a row.) And
remember that the method names you&#8217;re seeing here (such as the read and
write methods) are actually produced from a <B>Method</B> object that can be
used to invoke the associated method on the object.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The public method list includes the
methods that are not associated with a property or event, such as
<B>croak(&#160;)</B>, as well as those that are. These are all the methods that
you can call programmatically for a Bean, and the application builder tool can
choose to list all of these while you&#8217;re making method calls, to ease your
task.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, you can see that the
events are fully parsed out into the listener, its methods, and the add- and
remove-listener methods. Basically, once you have the <B>BeanInfo</B>, you can
find out everything of importance for the Bean. You can also call the methods
for that Bean, even though you don&#8217;t have any other information except the
object (again, a feature of
reflection).</FONT><A NAME="_Toc408018720"></A><BR></P></DIV>
<A NAME="Heading456"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A more sophisticated Bean</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This next example is slightly more
sophisticated, albeit frivolous. It&#8217;s a canvas that draws a little circle
around the mouse whenever the mouse is moved. When you press the mouse, the word
&#8220;Bang!&#8221; appears in the middle of the screen, and an action listener
is fired.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The properties you can change are
the size of the circle as well as the color, size, and text of the word that is
displayed when you press the mouse. A <B>BangBean</B> also has its own
<A NAME="Index2232"></A><A NAME="Index2233"></A><B>addActionListener(&#160;)</B>
and
<A NAME="Index2234"></A><A NAME="Index2235"></A><B>removeActionListener(&#160;)</B>
so you can attach your own listener that will be fired when the user clicks on
the <B>BangBean</B>. You should be able to recognize the property and event
support:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: BangBean.java</font>
<font color=#009900>// A graphical Bean</font>
<font color=#0000ff>package</font> bangbean;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> BangBean <font color=#0000ff>extends</font> Canvas
     <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>protected</font> <font color=#0000ff>int</font> xm, ym;
  <font color=#0000ff>protected</font> <font color=#0000ff>int</font> cSize = 20; <font color=#009900>// Circle size</font>
  <font color=#0000ff>protected</font> String text = <font color=#004488>"Bang!"</font>;
  <font color=#0000ff>protected</font> <font color=#0000ff>int</font> fontSize = 48;
  <font color=#0000ff>protected</font> Color tColor = Color.red;
  <font color=#0000ff>protected</font> ActionListener actionListener;
  <font color=#0000ff>public</font> BangBean() {
    addMouseListener(<font color=#0000ff>new</font> ML());
    addMouseMotionListener(<font color=#0000ff>new</font> MML());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getCircleSize() { <font color=#0000ff>return</font> cSize; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setCircleSize(<font color=#0000ff>int</font> newSize) {
    cSize = newSize;
  }
  <font color=#0000ff>public</font> String getBangText() { <font color=#0000ff>return</font> text; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setBangText(String newText) {
    text = newText;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getFontSize() { <font color=#0000ff>return</font> fontSize; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setFontSize(<font color=#0000ff>int</font> newSize) {
    fontSize = newSize;
  }
  <font color=#0000ff>public</font> Color getTextColor() { <font color=#0000ff>return</font> tColor; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setTextColor(Color newColor) {
    tColor = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paint(Graphics g) {
    g.setColor(Color.black);
    g.drawOval(xm - cSize/2, ym - cSize/2, 
      cSize, cSize);
  }
  <font color=#009900>// This is a unicast listener, which is</font>
  <font color=#009900>// the simplest form of listener management:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> addActionListener (
      ActionListener l) 
        <font color=#0000ff>throws</font> TooManyListenersException {
    <font color=#0000ff>if</font>(actionListener != <font color=#0000ff>null</font>)
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> TooManyListenersException();
    actionListener = l;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> removeActionListener(
      ActionListener l) {
    actionListener = <font color=#0000ff>null</font>;
  }
  <font color=#0000ff>class</font> ML <font color=#0000ff>extends</font> MouseAdapter {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mousePressed(MouseEvent e) {
      Graphics g = getGraphics();
      g.setColor(tColor);
      g.setFont(
        <font color=#0000ff>new</font> Font(
          <font color=#004488>"TimesRoman"</font>, Font.BOLD, fontSize));
      <font color=#0000ff>int</font> width = 
        g.getFontMetrics().stringWidth(text);
      g.drawString(text, 
        (getSize().width - width) /2,
        getSize().height/2);
      g.dispose();
      <font color=#009900>// Call the listener's method:</font>
      <font color=#0000ff>if</font>(actionListener != <font color=#0000ff>null</font>)
        actionListener.actionPerformed(
          <font color=#0000ff>new</font> ActionEvent(BangBean.<font color=#0000ff>this</font>,
            ActionEvent.ACTION_PERFORMED, <font color=#0000ff>null</font>));
    }
  }
  <font color=#0000ff>class</font> MML <font color=#0000ff>extends</font> MouseMotionAdapter {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mouseMoved(MouseEvent e) {
      xm = e.getX();
      ym = e.getY();
      repaint();
    }
  }
  <font color=#0000ff>public</font> Dimension getPreferredSize() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Dimension(200, 200);
  }
  <font color=#009900>// Testing the BangBean:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    BangBean bb = <font color=#0000ff>new</font> BangBean();
    <font color=#0000ff>try</font> {
      bb.addActionListener(<font color=#0000ff>new</font> BBL());
    } <font color=#0000ff>catch</font>(TooManyListenersException e) {}
    Frame aFrame = <font color=#0000ff>new</font> Frame(<font color=#004488>"BangBean Test"</font>);
    aFrame.addWindowListener(
      <font color=#0000ff>new</font> WindowAdapter() {
        <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(bb, BorderLayout.CENTER);
    aFrame.setSize(300,300);
    aFrame.setVisible(<font color=#0000ff>true</font>);
  }
  <font color=#009900>// During testing, send action information</font>
  <font color=#009900>// to the console:</font>
  <font color=#0000ff>static</font> <font color=#0000ff>class</font> BBL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      System.out.println(<font color=#004488>"BangBean action"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first thing you&#8217;ll notice
is that <B>BangBean</B> implements the
<A NAME="Index2236"></A><A NAME="Index2237"></A><B>Serializable</B> interface.
This means that the application builder tool can &#8220;pickle&#8221; all the
information for the <B>BangBean</B> using serialization after the program
designer has adjusted the values of the properties. When the Bean is created as
part of the running application, these &#8220;pickled&#8221; properties are
restored so that you get exactly what you designed.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that all the fields are
<B>private</B>, which is what you&#8217;ll usually do with a Bean &#8211; allow
access only through methods, usually using the &#8220;property&#8221;
scheme.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you look at the signature for
<B>addActionListener(&#160;)</B>, you&#8217;ll see that it can throw a
<A NAME="Index2238"></A><A NAME="Index2239"></A><B>TooManyListenersException</B>.
This indicates that it is
<A NAME="Index2240"></A><A NAME="Index2241"></A><I>unicast</I>, which means it
notifies only one listener when the event occurs. Ordinarily, you&#8217;ll use
<A NAME="Index2242"></A><A NAME="Index2243"></A><I>multicast</I> events so that
many listeners can be notified of an event. However, that runs into issues that
you won&#8217;t be ready for until the next chapter, so it will be revisited
there (under the heading &#8220;Java Beans revisited&#8221;). A unicast event
sidesteps the problem.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you press the mouse, the text
is put in the middle of the <B>BangBean</B>, and if the <B>actionListener</B>
field is not <B>null</B>, its <B>actionPerformed(&#160;)</B> is called, creating
a new <A NAME="Index2244"></A><A NAME="Index2245"></A><B>ActionEvent </B>object
in the process. Whenever the mouse is moved, its new coordinates are captured
and the canvas is repainted (erasing any text that&#8217;s on the canvas, as
you&#8217;ll see).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>main(&#160;)</B> is added to
allow you to test the program from the command line. When a Bean is in a
development environment, <B>main(&#160;)</B> will not be used, but it&#8217;s
helpful to have a <B>main(&#160;)</B> in each of your Beans because it provides
for rapid testing. <B>main(&#160;) </B>creates a <B>Frame</B> and places a
<B>BangBean</B> within it, attaching a simple <B>ActionListener</B> to the
<B>BangBean</B> to print to the console whenever an <B>ActionEvent</B> occurs.
Usually, of course, the application builder tool would create most of the code
that uses the Bean.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run the <B>BangBean</B>
through <B>BeanDumper</B> or put the <B>BangBean</B> inside a Bean-enabled
development environment, you&#8217;ll notice that there are many more properties
and actions than are evident from the above code. That&#8217;s because
<B>BangBean</B> is inherited from <B>Canvas</B>, and <B>Canvas</B> is a Bean, so
you&#8217;re seeing its properties and events as
well.</FONT><A NAME="_Toc408018721"></A><BR></P></DIV>
<A NAME="Heading457"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Packaging a Bean</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before you can bring a Bean into a
Bean-enabled visual builder tool, it must be put into the standard Bean
container, which is a <A NAME="Index2246"></A><A NAME="Index2247"></A>JAR (Java
ARchive) file that includes all the Bean classes as well as a
&#8220;manifest&#8221; file that says &#8220;This is a Bean.&#8221; A manifest
file is simply a text file that follows a particular form. For the
<B>BangBean</B>, the manifest file looks like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Manifest-Version: 1.0

Name: bangbean/BangBean.<font color=#0000ff>class</font>
Java-Bean: True</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first line indicates the
version of the manifest scheme, which until further notice from Sun is 1.0. The
second line (empty lines are ignored) names the <B>BangBean.class</B> file, and
the third says, &#8220;It&#8217;s a Bean.&#8221; Without the third line, the
program builder tool will not recognize the class as a Bean.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The only tricky part is that you
must make sure that you get the proper path in the &#8220;Name:&#8221; field. If
you look back at <B>BangBean.java</B>, you&#8217;ll see it&#8217;s in <B>package
bangbean </B>(and thus in a subdirectory called &#8220;bangbean&#8221;
that&#8217;s off of the classpath), and the name in the manifest file must
include this package information. In addition, you must place the manifest file
in the directory <I>above</I> the root of your package path, which in this case
means placing the file in the directory above the &#8220;bangbean&#8221;
subdirectory. Then you must invoke <B>jar</B> from the same directory as the
<A NAME="Index2248"></A><A NAME="Index2249"></A>manifest file, as
follows:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cfm BangBean.jar BangBean.mf bangbean</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This assumes that you want the
resulting JAR file to be named <B>BangBean.jar</B> and that you&#8217;ve put the
manifest in a file called <B>BangBean.mf</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might wonder &#8220;What about
all the other classes that were generated when I compiled
<B>BangBean.java</B>?&#8221; Well, they all ended up inside the <B>bangbean</B>
subdirectory, and you&#8217;ll see that the last argument for the above
<B>jar</B> command line is the <B>bangbean</B> subdirectory. When you give
<B>jar</B> the name of a subdirectory, it packages that entire subdirectory into
the jar file (including, in this case, the original <B>BangBean.java</B>
source-code file &#8211; you might not choose to include the source with your
own Beans). In addition, if you turn around and unpack the JAR file you&#8217;ve
just created, you&#8217;ll discover that your manifest file isn&#8217;t inside,
but that <B>jar</B> has created its own manifest file (based partly on yours)
called <B>MANIFEST.MF </B>and placed it inside the subdirectory <B>META-INF</B>
(for &#8220;meta-information&#8221;). If you open this manifest file
you&#8217;ll also notice that digital signature information has been added by
<B>jar </B>for each file, of the form:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Digest-Algorithms: SHA MD5 
SHA-Digest: pDpEAG9NaeCx8aFtqPI4udSX/O0=
MD5-Digest: O4NcS1hE3Smnzlp2hj6qeg==</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, you don&#8217;t need to
worry about any of this, and if you make changes you can just modify your
original manifest file and re-invoke <B>jar</B> to create a new JAR file for
your Bean. You can also add other Beans to the JAR file simply by adding their
information to your manifest.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One thing to notice is that
you&#8217;ll probably want to put each Bean in its own subdirectory, since when
you create a JAR file you hand the <B>jar</B> utility the name of a subdirectory
and it puts everything in that subdirectory into the JAR file. You can see that
both <B>Frog</B> and <B>BangBean</B> are in their own
subdirectories.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you have your Bean properly
inside a JAR file you can bring it into a Beans-enabled program-builder
environment. The way you do this varies from one tool to the next, but Sun
provides a freely-available test bed for Java Beans in their &#8220;Beans
Development Kit&#8221; (BDK) called the
&#8220;<A NAME="Index2250"></A><A NAME="Index2251"></A>beanbox.&#8221; (Download
the BDK from <I>www.javasoft.com</I>.) To place your Bean in the beanbox, copy
the JAR file into the BDK&#8217;s &#8220;jars&#8221; subdirectory before you
start up the beanbox.</FONT><A NAME="_Toc408018722"></A><BR></P></DIV>
<A NAME="Heading458"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
More complex Bean support</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see how remarkably simple
it is to make a Bean. But you aren&#8217;t limited to what you&#8217;ve seen
here. The Java Bean design provides a simple point of entry but can also scale
to more complex situations. These situations are beyond the scope of this book
but they will be briefly introduced here. You can find more details at
<I>http://java.sun.com/beans</I>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One place where you can add
sophistication is with properties. The examples above have shown only single
properties, but it&#8217;s also possible to represent multiple properties in an
array. This is called an
<A NAME="Index2252"></A><A NAME="Index2253"></A><A NAME="Index2254"></A><I>indexed
property</I>. You simply provide the appropriate methods (again following a
naming convention for the method names) and the <B>Introspector</B> recognizes
an indexed property so your application builder tool can respond
appropriately.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Properties can be
<A NAME="Index2255"></A><A NAME="Index2256"></A><A NAME="Index2257"></A><I>bound</I>,
which means that they will notify other objects via a
<B>PropertyChangeEvent</B>. The other objects can then choose to change
themselves based on the change to the Bean.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Properties can be
<A NAME="Index2258"></A><A NAME="Index2259"></A><A NAME="Index2260"></A><I>constrained</I>,
which means that other objects can veto a change to that property if it is
unacceptable. The other objects are notified using a
<A NAME="Index2261"></A><A NAME="Index2262"></A><B>PropertyChangeEvent</B>, and
they can throw a
<A NAME="Index2263"></A><A NAME="Index2264"></A><B>ProptertyVetoException</B> to
prevent the change from happening and to restore the old
values.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also change the way your
Bean is represented at design time:
<A NAME="Index2265"></A><A NAME="Index2266"></A><A NAME="Index2267"></A><A NAME="Index2268"></A><A NAME="Index2269"></A><A NAME="Index2270"></A><A NAME="Index2271"></A><A NAME="Index2272"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	You can provide a custom property sheet for your
particular Bean. The ordinary property sheet will be used for all other Beans,
but yours is automatically invoked when your Bean is
selected.</FONT><LI><FONT FACE="Georgia">	You can create a custom editor
for a particular property, so the ordinary property sheet is used, but when your
special property is being edited, your editor will automatically be
invoked.</FONT><LI><FONT FACE="Georgia">	You can provide a custom
<B>BeanInfo</B> class for your Bean that produces information that&#8217;s
different from the default created by the
<B>Introspector</B>.</FONT><LI><FONT FACE="Georgia">	It&#8217;s also
possible to turn &#8220;expert&#8221; mode on and off in all
<B>FeatureDescriptor</B>s to distinguish between basic features and more
complicated
ones.</FONT><A NAME="_Toc408018723"></A></OL><A NAME="Heading459"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
More to Beans</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s another issue that
couldn&#8217;t be addressed here. Whenever you create a Bean, you should expect
that it will be run in a multithreaded environment. This means that you must
understand the issues of threading, which will be introduced in the next
chapter. You&#8217;ll find a section there called &#8220;Java Beans
revisited&#8221; that will look at the problem and its
solution.</FONT><A NAME="_Toc408018724"></A><BR></P></DIV>
<A NAME="Heading460"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Introduction to Swing<A NAME="fnB57" HREF="#fn57">[57]</A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After working your way through this
chapter and seeing the huge changes that have occurred within the AWT (although,
if you can remember back that far, Sun claimed Java was a &#8220;stable&#8221;
language when it first appeared), you might still have the feeling that
it&#8217;s not quite done. Sure, there&#8217;s now a good event model, and
JavaBeans is an excellent component-reuse design. But the GUI components still
seem rather minimal, primitive, and awkward.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That&#8217;s where
<A NAME="Index2273"></A>Swing comes in. The Swing library appeared after Java
1.1 so you might naturally assume that it&#8217;s part of
<A NAME="Index2274"></A>Java 1.2. However, it is designed to work with
<A NAME="Index2275"></A>Java 1.1 as an add-on. This way, you don&#8217;t have to
wait for your platform to support Java 1.2 in order to enjoy a good UI component
library. Your users might actually need to download the Swing library if it
isn&#8217;t part of their Java 1.1 support, and this could cause a few snags.
But it works.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Swing contains all the components
that you&#8217;ve been missing throughout the rest of this chapter: those you
expect to see in a modern UI, everything from buttons that contain pictures to
trees and grids. It&#8217;s a big library, but it&#8217;s designed to have
appropriate complexity for the task at hand &#8211; if something is simple, you
don&#8217;t have to write much code but as you try to do more your code becomes
increasingly complex. This means an easy entry point, but you&#8217;ve got the
power if you need it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Swing has great depth. This section
does not attempt to be comprehensive, but instead introduces the power and
simplicity of Swing to get you started using the library. Please be aware that
what you see here is intended to be simple. If you need to do more, then Swing
can probably give you what you want if you&#8217;re willing to do the research
by hunting through the online documentation from
Sun.</FONT><A NAME="_Toc408018725"></A><BR></P></DIV>
<A NAME="Heading461"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Benefits of Swing</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you begin to use the Swing
library, you&#8217;ll see that it&#8217;s a huge step forward. Swing components
are Beans (and thus use the Java 1.1 event model), so they can be used in any
development environment that supports Beans. Swing provides a full set of UI
components. For speed, all the <A NAME="Index2276"></A>components are
lightweight (no &#8220;peer&#8221; components are used), and Swing is written
entirely in Java for portability.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Much of what you&#8217;ll like
about Swing could be called &#8220;orthogonality of use;&#8221; that is, once
you pick up the general ideas about the library you can apply them everywhere.
Primarily because of the Beans naming conventions, much of the time I was
writing these examples I could guess at the method names and get it right the
first time, without looking anything up. This is certainly the hallmark of a
good library design. In addition, you can generally plug components into other
components and things will work correctly.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index2277"></A><A NAME="Index2278"></A><FONT FACE="Georgia">Keyboard
navigation is automatic &#8211; you can use a Swing application without the
mouse, but you don&#8217;t have to do any extra programming (the old AWT
required some ugly code to achieve keyboard navigation). Scrolling support is
effortless &#8211; you simply wrap your component in a
<A NAME="Index2279"></A><A NAME="Index2280"></A><B>JScrollPane</B> as you add it
to your form. Other features such as tool tips typically require a single line
of code to implement.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Swing also supports something
called &#8220;pluggable look and feel,&#8221; which means that the appearance of
the UI can be dynamically changed to suit the expectations of users working
under different platforms and operating systems. It&#8217;s even possible to
invent your own look and feel.</FONT><A NAME="_Toc408018726"></A><BR></P></DIV>
<A NAME="Heading462"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Easy conversion</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;ve struggled long and
hard to build your UI using Java 1.1, you don&#8217;t want to throw it away to
convert to Swing. Fortunately, the library is designed to allow easy conversion
&#8211; in many cases you can simply put a &#8216;J&#8217; in front of the class
names of each of your old AWT components. Here&#8217;s an example that should
have a familiar flavor to it:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: JButtonDemo.java</font>
<font color=#009900>// Looks like Java 1.1 but with J's added</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.applet.*;
<font color=#0000ff>import</font> javax.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> JButtonDemo <font color=#0000ff>extends</font> Applet {
  JButton 
    b1 = <font color=#0000ff>new</font> JButton(<font color=#004488>"JButton 1"</font>),
    b2 = <font color=#0000ff>new</font> JButton(<font color=#004488>"JButton 2"</font>);
  JTextField t = <font color=#0000ff>new</font> JTextField(20);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    ActionListener al = <font color=#0000ff>new</font> ActionListener() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e){
        String name = 
          ((JButton)e.getSource()).getText();
        t.setText(name + <font color=#004488>" Pressed"</font>);
      }
    };
    b1.addActionListener(al);
    add(b1);
    b2.addActionListener(al);
    add(b2);
    add(t);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    JButtonDemo applet = <font color=#0000ff>new</font> JButtonDemo();
    JFrame frame = <font color=#0000ff>new</font> JFrame(<font color=#004488>"TextAreaNew"</font>);
    frame.addWindowListener(<font color=#0000ff>new</font> WindowAdapter() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e){
        System.exit(0);
      }
    });
    frame.getContentPane().add(
      applet, BorderLayout.CENTER);
    frame.setSize(300,100);
    applet.init();
    applet.start();
    frame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a new <B>import</B>
statement, but everything else looks like the Java 1.1 AWT with the addition of
some J&#8217;s. Also, you don&#8217;t just <B>add(&#160;) </B>something to a
Swing <B>JFrame</B>, but you must get the &#8220;content pane&#8221; first, as
seen above.<B> </B>But you can easily get many of the benefits of Swing with a
simple conversion.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because of the <B>package</B>
statement, you&#8217;ll have to invoke this program by saying:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java c13.swing.JbuttonDemo</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All of the programs in this section
will require a similar form to run
them.</FONT><A NAME="_Toc408018727"></A><BR></P></DIV>
<A NAME="Heading463"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A display framework</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although the programs that are both
applets and applications can be valuable, if used everywhere they become
distracting and waste paper. Instead, a display framework will be used for the
Swing examples in the rest of this section:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Show.java</font>
<font color=#009900>// Tool for displaying Swing demos</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Show {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  inFrame(JPanel jp, <font color=#0000ff>int</font> width, <font color=#0000ff>int</font> height) {
    String title = jp.getClass().toString();
    <font color=#009900>// Remove the word "class":</font>
    <font color=#0000ff>if</font>(title.indexOf(<font color=#004488>"class"</font>) != -1)
      title = title.substring(6);
    JFrame frame = <font color=#0000ff>new</font> JFrame(title);
    frame.addWindowListener(<font color=#0000ff>new</font> WindowAdapter() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> windowClosing(WindowEvent e){
        System.exit(0);
      }
    });
    frame.getContentPane().add(
      jp, BorderLayout.CENTER);
    frame.setSize(width, height);
    frame.setVisible(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Classes that want to display
themselves should inherit from <B>JPanel</B> and then add any visual components
to themselves. Finally, they create a <B>main(&#160;)</B> containing the
line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Show.inFrame(<font color=#0000ff>new</font> MyClass(), 500, 300);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">in which the last two arguments are
the display width and height.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the title for the
<A NAME="Index2281"></A><A NAME="Index2282"></A><B>JFrame</B> is produced using
RTTI.</FONT><A NAME="_Toc408018728"></A><BR></P></DIV>
<A NAME="Heading464"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Tool tips</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Almost all of the classes that
you&#8217;ll be using to create your user interfaces are derived from
<A NAME="Index2283"></A><A NAME="Index2284"></A><B>JComponent</B>, which
contains a method called
<A NAME="Index2285"></A><A NAME="Index2286"></A><B>setToolTipText(String)</B>.
So, for virtually anything you place on your form, all you need to do is say
(for an object <B>jc </B>of any <B>JComponent</B>-derived
class):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jc.setToolTipText(<font color=#004488>"My tip"</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">and when the mouse stays over that
<B>JComponent</B> for a predetermined period of time, a tiny box containing your
text will pop up next to the mouse.</FONT><A NAME="_Toc408018729"></A><BR></P></DIV>
<A NAME="Heading465"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Borders</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>JComponent</B> also contains a
method called
<A NAME="Index2287"></A><A NAME="Index2288"></A><B>setBorder(&#160;),</B> which
allows you to place various interesting borders on any visible component. The
following example demonstrates a number of the different borders that are
available, using a method called <B>showBorder(&#160;)</B> that creates a
<B>JPanel</B> and puts on the border in each case. Also, it uses RTTI to find
the name of the border that you&#8217;re using (stripping off all the path
information), then puts that name in a
<A NAME="Index2289"></A><A NAME="Index2290"></A><B>JLabel</B> in the middle of
the panel:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Borders.java</font>
<font color=#009900>// Different Swing borders</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> javax.swing.border.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Borders <font color=#0000ff>extends</font> JPanel {
  <font color=#0000ff>static</font> JPanel showBorder(Border b) {
    JPanel jp = <font color=#0000ff>new</font> JPanel();
    jp.setLayout(<font color=#0000ff>new</font> BorderLayout());
    String nm = b.getClass().toString();
    nm = nm.substring(nm.lastIndexOf('.') + 1);
    jp.add(<font color=#0000ff>new</font> JLabel(nm, JLabel.CENTER), 
      BorderLayout.CENTER);
    jp.setBorder(b);
    <font color=#0000ff>return</font> jp;
  }
  <font color=#0000ff>public</font> Borders() {
    setLayout(<font color=#0000ff>new</font> GridLayout(2,4));
    add(showBorder(<font color=#0000ff>new</font> TitledBorder(<font color=#004488>"Title"</font>)));
    add(showBorder(<font color=#0000ff>new</font> EtchedBorder()));
    add(showBorder(<font color=#0000ff>new</font> LineBorder(Color.blue)));
    add(showBorder(
      <font color=#0000ff>new</font> MatteBorder(5,5,30,30,Color.green)));
    add(showBorder(
      <font color=#0000ff>new</font> BevelBorder(BevelBorder.RAISED)));
    add(showBorder(
      <font color=#0000ff>new</font> SoftBevelBorder(BevelBorder.LOWERED)));
    add(showBorder(<font color=#0000ff>new</font> CompoundBorder(
      <font color=#0000ff>new</font> EtchedBorder(),
      <font color=#0000ff>new</font> LineBorder(Color.red))));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> Borders(), 500, 300);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most of the examples in this
section use <A NAME="Index2291"></A><A NAME="Index2292"></A><B>TitledBorder</B>,
but you can see that the rest of the borders are as easy to use. You can also
create your own borders and put them inside buttons, labels, etc. &#8211;
anything derived from
<B>JComponent</B>.</FONT><A NAME="_Toc408018730"></A><BR></P></DIV>
<A NAME="Heading466"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Buttons</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Swing adds a number of different
types of buttons, and it also changes the organization of the selection
components: all buttons, checkboxes, radio buttons, and even menu items are
inherited from
<A NAME="Index2293"></A><A NAME="Index2294"></A><B>AbstractButton</B> (which,
since menu items are included, would probably have been better named
&#8220;AbstractChooser&#8221; or something equally general). You&#8217;ll see
the use of menu items shortly, but the following example shows the various types
of buttons available:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Buttons.java</font>
<font color=#009900>// Various Swing buttons</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> javax.swing.plaf.basic.*;
<font color=#0000ff>import</font> javax.swing.border.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Buttons <font color=#0000ff>extends</font> JPanel {
  JButton jb = <font color=#0000ff>new</font> JButton(<font color=#004488>"JButton"</font>);
  BasicArrowButton
    up = <font color=#0000ff>new</font> BasicArrowButton(
      BasicArrowButton.NORTH),
    down = <font color=#0000ff>new</font> BasicArrowButton(
      BasicArrowButton.SOUTH),
    right = <font color=#0000ff>new</font> BasicArrowButton(
      BasicArrowButton.EAST),
    left = <font color=#0000ff>new</font> BasicArrowButton(
      BasicArrowButton.WEST);
  <font color=#0000ff>public</font> Buttons() {
    add(jb);
    add(<font color=#0000ff>new</font> JToggleButton(<font color=#004488>"JToggleButton"</font>));
    add(<font color=#0000ff>new</font> JCheckBox(<font color=#004488>"JCheckBox"</font>));
    add(<font color=#0000ff>new</font> JRadioButton(<font color=#004488>"JRadioButton"</font>));
    JPanel jp = <font color=#0000ff>new</font> JPanel();
    jp.setBorder(<font color=#0000ff>new</font> TitledBorder(<font color=#004488>"Directions"</font>));
    jp.add(up);
    jp.add(down);
    jp.add(left);
    jp.add(right);
    add(jp);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> Buttons(), 300, 200);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index2295"></A><A NAME="Index2296"></A><B>JButton</B> looks like the
AWT button, but there&#8217;s more you can do to it (like add images, as
you&#8217;ll see later). In <B>javax.swing.plaf.basic</B>, there is also a
<A NAME="Index2297"></A><A NAME="Index2298"></A><B>BasicArrowButton</B> that is
convenient.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run the example,
you&#8217;ll see that the toggle button holds its last position, in or out. But
the check boxes and radio buttons behave identically to each other, just
clicking on or off (they are inherited from
<A NAME="Index2299"></A><A NAME="Index2300"></A><B>JToggleButton</B>).
</FONT><A NAME="_Toc408018731"></A><BR></P></DIV>
<A NAME="Heading467"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Button groups</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want radio buttons to behave
in an &#8220;exclusive or&#8221; fashion, you must add them to a button group,
in a similar but less awkward way as the old AWT. But as the example below
demonstrates, any <B>AbstractButton</B> can be added to a
<A NAME="Index2301"></A><A NAME="Index2302"></A><B>ButtonGroup</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To avoid repeating a lot of code,
this example uses reflection to generate the groups of different types of
buttons. This is seen in <B>makeBPanel</B>, which creates a button group and a
<B>JPanel</B>, and for each <B>String</B> in the array that&#8217;s the second
argument to <B>makeBPanel(&#160;)</B>, it adds an object of the class
represented by the first argument:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ButtonGroups.java</font>
<font color=#009900>// Uses reflection to create groups of different</font>
<font color=#009900>// types of AbstractButton.</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> javax.swing.border.*;
<font color=#0000ff>import</font> java.lang.reflect.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ButtonGroups <font color=#0000ff>extends</font> JPanel {
  <font color=#0000ff>static</font> String[] ids = { 
    <font color=#004488>"June"</font>, <font color=#004488>"Ward"</font>, <font color=#004488>"Beaver"</font>, 
    <font color=#004488>"Wally"</font>, <font color=#004488>"Eddie"</font>, <font color=#004488>"Lumpy"</font>,
  };
  <font color=#0000ff>static</font> JPanel 
  makeBPanel(Class bClass, String[] ids) {
    ButtonGroup bg = <font color=#0000ff>new</font> ButtonGroup();
    JPanel jp = <font color=#0000ff>new</font> JPanel();
    String title = bClass.getName();
    title = title.substring(
      title.lastIndexOf('.') + 1);
    jp.setBorder(<font color=#0000ff>new</font> TitledBorder(title));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; ids.length; i++) {
      AbstractButton ab = <font color=#0000ff>new</font> JButton(<font color=#004488>"failed"</font>);
      <font color=#0000ff>try</font> {
        <font color=#009900>// Get the dynamic constructor method</font>
        <font color=#009900>// that takes a String argument:</font>
        Constructor ctor = bClass.getConstructor(
          <font color=#0000ff>new</font> Class[] { String.<font color=#0000ff>class</font> });
        <font color=#009900>// Create a new object:</font>
        ab = (AbstractButton)ctor.newInstance(
          <font color=#0000ff>new</font> Object[]{ids[i]});
      } <font color=#0000ff>catch</font>(Exception ex) {
        System.out.println(<font color=#004488>"can't create "</font> + 
          bClass);
      }
      bg.add(ab);
      jp.add(ab);
    }
    <font color=#0000ff>return</font> jp;
  }
  <font color=#0000ff>public</font> ButtonGroups() {
    add(makeBPanel(JButton.<font color=#0000ff>class</font>, ids));
    add(makeBPanel(JToggleButton.<font color=#0000ff>class</font>, ids));
    add(makeBPanel(JCheckBox.<font color=#0000ff>class</font>, ids));
    add(makeBPanel(JRadioButton.<font color=#0000ff>class</font>, ids));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> ButtonGroups(), 500, 300);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The title for the border is taken
from the name of the class, stripping off all the path information. The
<B>AbstractButton</B> is initialized to a <B>JButton</B> that has the label
&#8220;Failed&#8221; so if you ignore the exception message, you&#8217;ll still
see the problem on screen. The
<A NAME="Index2303"></A><A NAME="Index2304"></A><B>getConstructor(&#160;)</B>
method produces a
<A NAME="Index2305"></A><A NAME="Index2306"></A><B>Constructor</B> object that
takes the array of arguments of the types in the
<A NAME="Index2307"></A><A NAME="Index2308"></A><B>Class </B>array passed to
<B>getConstructor(&#160;)</B>. Then all you do is call
<A NAME="Index2309"></A><A NAME="Index2310"></A><B>newInstance(&#160;)</B>,
passing it an array of <B>Object</B> containing your actual arguments &#8211; in
this case, just the <B>String</B> from the <B>ids</B> array.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This adds a little complexity to
what is a simple process. To get &#8220;exclusive or&#8221; behavior with
buttons, you create a button group and add each button for which you want that
behavior to the group. When you run the program, you&#8217;ll see that all the
buttons except <B>JButton</B> exhibit this &#8220;exclusive or&#8221;
behavior.</FONT><A NAME="_Toc408018732"></A><BR></P></DIV>
<A NAME="Heading468"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Icons</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can use an
<A NAME="Index2311"></A><A NAME="Index2312"></A><B>Icon</B> inside a
<B>JLabel</B> or anything that inherits from <B>AbstractButton</B> (including
<B>JButton</B>,
<A NAME="Index2313"></A><A NAME="Index2314"></A><B>JCheckbox</B>,
<A NAME="Index2315"></A><A NAME="Index2316"></A><B>JradioButton,</B> and the
different kinds of
<A NAME="Index2317"></A><A NAME="Index2318"></A><B>JMenuItem</B>). Using
<B>Icon</B>s with <B>JLabel</B>s is quite straightforward (you&#8217;ll see an
example later). The following example explores all the additional ways you can
use <B>Icon</B>s with buttons and their descendants.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can use any <B>gif</B> files
you want, but the ones used in this example are part of the book&#8217;s code
distribution, available at <I>www.BruceEckel.com</I>. To open a file and bring
in the image, simply create an
<A NAME="Index2319"></A><A NAME="Index2320"></A><B>ImageIcon</B> and hand it the
file name. From then on, you can use the resulting <B>Icon</B> in your
program.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Faces.java</font>
<font color=#009900>// Icon behavior in JButtons</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Faces <font color=#0000ff>extends</font> JPanel {
  <font color=#0000ff>static</font> Icon[] faces = {
    <font color=#0000ff>new</font> ImageIcon(<font color=#004488>"face0.gif"</font>),
    <font color=#0000ff>new</font> ImageIcon(<font color=#004488>"face1.gif"</font>),
    <font color=#0000ff>new</font> ImageIcon(<font color=#004488>"face2.gif"</font>),
    <font color=#0000ff>new</font> ImageIcon(<font color=#004488>"face3.gif"</font>),
    <font color=#0000ff>new</font> ImageIcon(<font color=#004488>"face4.gif"</font>),
  };
  JButton 
    jb = <font color=#0000ff>new</font> JButton(<font color=#004488>"JButton"</font>, faces[3]),
    jb2 = <font color=#0000ff>new</font> JButton(<font color=#004488>"Disable"</font>);
  <font color=#0000ff>boolean</font> mad = <font color=#0000ff>false</font>;
  <font color=#0000ff>public</font> Faces() {
    jb.addActionListener(<font color=#0000ff>new</font> ActionListener() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e){
        <font color=#0000ff>if</font>(mad) {
          jb.setIcon(faces[3]);
          mad = <font color=#0000ff>false</font>;
        } <font color=#0000ff>else</font> {
          jb.setIcon(faces[0]);
          mad = <font color=#0000ff>true</font>;
        }
        jb.setVerticalAlignment(JButton.TOP);
        jb.setHorizontalAlignment(JButton.LEFT);
      }
    });
    jb.setRolloverEnabled(<font color=#0000ff>true</font>);
    jb.setRolloverIcon(faces[1]);
    jb.setPressedIcon(faces[2]);
    jb.setDisabledIcon(faces[4]);
    jb.setToolTipText(<font color=#004488>"Yow!"</font>);
    add(jb);
    jb2.addActionListener(<font color=#0000ff>new</font> ActionListener() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e){
        <font color=#0000ff>if</font>(jb.isEnabled()) {
          jb.setEnabled(<font color=#0000ff>false</font>);
          jb2.setText(<font color=#004488>"Enable"</font>);
        } <font color=#0000ff>else</font> {
          jb.setEnabled(<font color=#0000ff>true</font>);
          jb2.setText(<font color=#004488>"Disable"</font>);
        }
      }
    });
    add(jb2);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> Faces(), 300, 200);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An <B>Icon</B> can be used in many
constructors, but you can also use
<A NAME="Index2321"></A><A NAME="Index2322"></A><B>setIcon(&#160;)</B> to add or
change an <B>Icon</B>. This example also shows how a <B>JButton</B> (or any
<B>AbstractButton</B>) can set the various different sorts of icons that appear
when things happen to that button: when it&#8217;s pressed, disabled, or
&#8220;rolled <A NAME="Index2323"></A><A NAME="Index2324"></A>over&#8221; (the
mouse moves over it without clicking). You&#8217;ll see that this gives the
button a rather animated feel.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that a
<A NAME="Index2325"></A><A NAME="Index2326"></A>tool tip is also added to the
button.</FONT><A NAME="_Toc408018733"></A><BR></P></DIV>
<A NAME="Heading469"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Menus<BR><A NAME="Index2327"></A><A NAME="Index2328"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Menus are much improved and more
flexible in Swing &#8211; for example, you can use them just about anywhere,
including panels and applets. The syntax for using them is much the same as it
was in the old AWT, and this preserves the same problem present in the old AWT:
you must hard-code your menus and there isn&#8217;t any support for menus as
resources (which, among other things, would make them easier to change for other
languages). In addition, menu code gets long-winded and sometimes messy. The
following approach takes a step in the direction of solving this problem by
putting all the information about each menu into a two-dimensional
<A NAME="Index2329"></A><A NAME="Index2330"></A>array of <B>Object</B> (that way
you can put anything you want into the array). This array is organized so that
the first row represents the menu name, and the remaining rows represent the
menu items and their characteristics. You&#8217;ll notice the rows of the array
do not have to be uniform from one to the next &#8211; as long as your code
knows where everything should be, each row can be completely
different.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Menus.java</font>
<font color=#009900>// A menu-building system; also demonstrates</font>
<font color=#009900>// icons in labels and menu items.</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Menus <font color=#0000ff>extends</font> JPanel {
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> Boolean
    bT = <font color=#0000ff>new</font> Boolean(<font color=#0000ff>true</font>), 
    bF = <font color=#0000ff>new</font> Boolean(<font color=#0000ff>false</font>);
  <font color=#009900>// Dummy class to create type identifiers:</font>
  <font color=#0000ff>static</font> <font color=#0000ff>class</font> MType { MType(<font color=#0000ff>int</font> i) {} };
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> MType
    mi = <font color=#0000ff>new</font> MType(1), <font color=#009900>// Normal menu item</font>
    cb = <font color=#0000ff>new</font> MType(2), <font color=#009900>// Checkbox menu item</font>
    rb = <font color=#0000ff>new</font> MType(3); <font color=#009900>// Radio button menu item</font>
  JTextField t = <font color=#0000ff>new</font> JTextField(10);
  JLabel l = <font color=#0000ff>new</font> JLabel(<font color=#004488>"Icon Selected"</font>, 
    Faces.faces[0], JLabel.CENTER);
  ActionListener a1 = <font color=#0000ff>new</font> ActionListener() {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      t.setText(
        ((JMenuItem)e.getSource()).getText());
    }
  };
  ActionListener a2 = <font color=#0000ff>new</font> ActionListener() {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      JMenuItem mi = (JMenuItem)e.getSource();
      l.setText(mi.getText());
      l.setIcon(mi.getIcon());
    }
  };
  <font color=#009900>// Store menu data as "resources":</font>
  <font color=#0000ff>public</font> Object[][] fileMenu = {
    <font color=#009900>// Menu name and accelerator:</font>
    { <font color=#004488>"File"</font>, <font color=#0000ff>new</font> Character('F') },
    <font color=#009900>// Name type accel listener enabled</font>
    { <font color=#004488>"New"</font>, mi, <font color=#0000ff>new</font> Character('N'), a1, bT },
    { <font color=#004488>"Open"</font>, mi, <font color=#0000ff>new</font> Character('O'), a1, bT },
    { <font color=#004488>"Save"</font>, mi, <font color=#0000ff>new</font> Character('S'), a1, bF },
    { <font color=#004488>"Save As"</font>, mi, <font color=#0000ff>new</font> Character('A'), a1, bF},
    { <font color=#0000ff>null</font> }, <font color=#009900>// Separator</font>
    { <font color=#004488>"Exit"</font>, mi, <font color=#0000ff>new</font> Character('x'), a1, bT },
  };
  <font color=#0000ff>public</font> Object[][] editMenu = {
    <font color=#009900>// Menu name:</font>
    { <font color=#004488>"Edit"</font>, <font color=#0000ff>new</font> Character('E') },
    <font color=#009900>// Name type accel listener enabled</font>
    { <font color=#004488>"Cut"</font>, mi, <font color=#0000ff>new</font> Character('t'), a1, bT },
    { <font color=#004488>"Copy"</font>, mi, <font color=#0000ff>new</font> Character('C'), a1, bT },
    { <font color=#004488>"Paste"</font>, mi, <font color=#0000ff>new</font> Character('P'), a1, bT },
    { <font color=#0000ff>null</font> }, <font color=#009900>// Separator</font>
    { <font color=#004488>"Select All"</font>, mi,<font color=#0000ff>new</font> Character('l'),a1,bT},
  };
  <font color=#0000ff>public</font> Object[][] helpMenu = {
    <font color=#009900>// Menu name:</font>
    { <font color=#004488>"Help"</font>, <font color=#0000ff>new</font> Character('H') },
    <font color=#009900>// Name type accel listener enabled</font>
    { <font color=#004488>"Index"</font>, mi, <font color=#0000ff>new</font> Character('I'), a1, bT },
    { <font color=#004488>"Using help"</font>, mi,<font color=#0000ff>new</font> Character('U'),a1,bT},
    { <font color=#0000ff>null</font> }, <font color=#009900>// Separator</font>
    { <font color=#004488>"About"</font>, mi, <font color=#0000ff>new</font> Character('t'), a1, bT },
  };
  <font color=#0000ff>public</font> Object[][] optionMenu = {
    <font color=#009900>// Menu name:</font>
    { <font color=#004488>"Options"</font>, <font color=#0000ff>new</font> Character('O') },
    <font color=#009900>// Name type accel listener enabled</font>
    { <font color=#004488>"Option 1"</font>, cb, <font color=#0000ff>new</font> Character('1'), a1,bT},
    { <font color=#004488>"Option 2"</font>, cb, <font color=#0000ff>new</font> Character('2'), a1,bT},
  };
  <font color=#0000ff>public</font> Object[][] faceMenu = {
    <font color=#009900>// Menu name:</font>
    { <font color=#004488>"Faces"</font>, <font color=#0000ff>new</font> Character('a') },
    <font color=#009900>// Optinal last element is icon</font>
    { <font color=#004488>"Face 0"</font>, rb, <font color=#0000ff>new</font> Character('0'), a2, bT, 
      Faces.faces[0] },
    { <font color=#004488>"Face 1"</font>, rb, <font color=#0000ff>new</font> Character('1'), a2, bT, 
      Faces.faces[1] },
    { <font color=#004488>"Face 2"</font>, rb, <font color=#0000ff>new</font> Character('2'), a2, bT, 
      Faces.faces[2] },
    { <font color=#004488>"Face 3"</font>, rb, <font color=#0000ff>new</font> Character('3'), a2, bT, 
      Faces.faces[3] },
    { <font color=#004488>"Face 4"</font>, rb, <font color=#0000ff>new</font> Character('4'), a2, bT, 
      Faces.faces[4] },
  };
  <font color=#0000ff>public</font> Object[] menuBar = {
    fileMenu, editMenu, faceMenu, 
    optionMenu, helpMenu,
  };
  <font color=#0000ff>static</font> <font color=#0000ff>public</font> JMenuBar
  createMenuBar(Object[] menuBarData) {
    JMenuBar menuBar = <font color=#0000ff>new</font> JMenuBar();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; menuBarData.length; i++)
      menuBar.add(
        createMenu((Object[][])menuBarData[i]));
    <font color=#0000ff>return</font> menuBar;
  }
  <font color=#0000ff>static</font> ButtonGroup bgroup;
  <font color=#0000ff>static</font> <font color=#0000ff>public</font> JMenu 
  createMenu(Object[][] menuData) {
    JMenu menu = <font color=#0000ff>new</font> JMenu();
    menu.setText((String)menuData[0][0]);
    menu.setMnemonic(
      ((Character)menuData[0][1]).charValue());
    <font color=#009900>// Create redundantly, in case there are</font>
    <font color=#009900>// any radio buttons:</font>
    bgroup = <font color=#0000ff>new</font> ButtonGroup();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 1; i &lt; menuData.length; i++) {
      <font color=#0000ff>if</font>(menuData[i][0] == <font color=#0000ff>null</font>)
        menu.add(<font color=#0000ff>new</font> JSeparator());
      <font color=#0000ff>else</font>
        menu.add(createMenuItem(menuData[i]));
    }
    <font color=#0000ff>return</font> menu;
  }
  <font color=#0000ff>static</font> <font color=#0000ff>public</font> JMenuItem 
  createMenuItem(Object[] data) {
    JMenuItem m = <font color=#0000ff>null</font>;
    MType type = (MType)data[1];
    <font color=#0000ff>if</font>(type == mi)
      m = <font color=#0000ff>new</font> JMenuItem();
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(type == cb)
      m = <font color=#0000ff>new</font> JCheckBoxMenuItem();
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(type == rb) {
      m = <font color=#0000ff>new</font> JRadioButtonMenuItem();
      bgroup.add(m);
    }
    m.setText((String)data[0]);
    m.setMnemonic(
      ((Character)data[2]).charValue());
    m.addActionListener(
      (ActionListener)data[3]);
    m.setEnabled(
      ((Boolean)data[4]).booleanValue());
    <font color=#0000ff>if</font>(data.length == 6)
      m.setIcon((Icon)data[5]);
    <font color=#0000ff>return</font> m;
  }
  Menus() {
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    add(createMenuBar(menuBar), 
      BorderLayout.NORTH);
    JPanel p = <font color=#0000ff>new</font> JPanel();
    p.setLayout(<font color=#0000ff>new</font> BorderLayout());
    p.add(t, BorderLayout.NORTH);
    p.add(l, BorderLayout.CENTER);
    add(p, BorderLayout.CENTER);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> Menus(), 300, 200);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The goal is to allow the programmer
to simply create tables to represent each menu, rather than typing lines of code
to build the menus. Each table produces one menu, and the first row in the table
contains the menu name and its keyboard accelerator. The remaining rows contain
the data for each menu item: the string to be placed on the menu item, what type
of menu item it is, its keyboard accelerator, the actionlistener that is fired
when this menu item is selected, and whether this menu item is enabled. If a row
starts with <B>null</B> it is treated as a separator.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To prevent wasteful and tedious
multiple creations of <B>Boolean</B> objects and type flags, these are created
as <B>static final</B> values at the beginning of the class: <B>bT</B> and
<B>bF</B> to represent <B>Boolean</B>s and different objects of the dummy class
<B>MType</B> to describe normal menu items (<B>mi</B>), checkbox menu items
(<B>cb</B>), and radio button menu items (<B>rb</B>). Remember that an array of
<B>Object</B> may hold only<B> Object</B> handles and not primitive
values.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example also shows how
<A NAME="Index2331"></A><A NAME="Index2332"></A><B>JLabel</B>s and
<A NAME="Index2333"></A><A NAME="Index2334"></A><B>JMenuItems</B> (and their
descendants) may hold <B>Icon</B>s. An <B>Icon </B>is placed into the
<B>JLabel</B> via its constructor and changed when the corresponding menu item
is selected.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>menuBar</B> array contains
the handles to all the file menus in the order that you want them to appear on
the menu bar. You pass this array to <B>createMenuBar(&#160;)</B>, which breaks
it up into individual arrays of menu data, passing each to
<B>createMenu(&#160;)</B>. This method, in turn, takes the first line of the
menu data and creates a
<A NAME="Index2335"></A><A NAME="Index2336"></A><B>JMenu</B> from it, then calls
<B>createMenuItem(&#160;)</B> for each of the remaining lines of menu data.
Finally, <B>createMenuItem(&#160;)</B> parses each line of menu data and
determines the type of menu and its attributes, and creates that menu item
appropriately. In the end, as you can see in the <B>Menus(&#160;)</B>
constructor, to create a menu from these tables say
<B>createMenuBar(menuBar)</B> and everything is handled
recursively.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example does not take care of
building cascading menus, but you should have enough of the concept that you can
add that capability if you need it.</FONT><A NAME="_Toc408018734"></A><BR></P></DIV>
<A NAME="Heading470"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Popup menus</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most straightforward way
<A NAME="Index2337"></A><A NAME="Index2338"></A><A NAME="Index2339"></A>to
implement a <A NAME="Index2340"></A><A NAME="Index2341"></A><B>JPopupMenu</B> is
to create an inner class that extends <B>MouseAdapter</B>, then add an object of
that inner class to each component which should produce popup
behavior:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Popup.java</font>
<font color=#009900>// Creating popup menus with Swing</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Popup <font color=#0000ff>extends</font> JPanel {
  JPopupMenu popup = <font color=#0000ff>new</font> JPopupMenu();
  JTextField t = <font color=#0000ff>new</font> JTextField(10);
  <font color=#0000ff>public</font> Popup() {
    add(t);
    ActionListener al = <font color=#0000ff>new</font> ActionListener() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e){
        t.setText(
          ((JMenuItem)e.getSource()).getText());
      }
    };
    JMenuItem m = <font color=#0000ff>new</font> JMenuItem(<font color=#004488>"Hither"</font>);
    m.addActionListener(al);
    popup.add(m);
    m = <font color=#0000ff>new</font> JMenuItem(<font color=#004488>"Yon"</font>);
    m.addActionListener(al);
    popup.add(m);
    m = <font color=#0000ff>new</font> JMenuItem(<font color=#004488>"Afar"</font>);
    m.addActionListener(al);
    popup.add(m);
    popup.addSeparator();
    m = <font color=#0000ff>new</font> JMenuItem(<font color=#004488>"Stay Here"</font>);
    m.addActionListener(al);
    popup.add(m);
    PopupListener pl = <font color=#0000ff>new</font> PopupListener();
    addMouseListener(pl);
    t.addMouseListener(pl);
  }
  <font color=#0000ff>class</font> PopupListener <font color=#0000ff>extends</font> MouseAdapter {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mousePressed(MouseEvent e) {
      maybeShowPopup(e);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mouseReleased(MouseEvent e) {
      maybeShowPopup(e);
    }
    <font color=#0000ff>private</font> <font color=#0000ff>void</font> maybeShowPopup(MouseEvent e) {
      <font color=#0000ff>if</font>(e.isPopupTrigger()) {
        popup.show(
          e.getComponent(), e.getX(), e.getY());
      }
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> Popup(),200,150);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The same <B>ActionListener</B> is
added to each <A NAME="Index2342"></A><A NAME="Index2343"></A><B>JMenuItem</B>,
so that it fetches the text from the menu label and inserts it into the
<A NAME="Index2344"></A><A NAME="Index2345"></A><B>JTextField</B>.</FONT><A NAME="_Toc408018735"></A><BR></P></DIV>
<A NAME="Heading471"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
List boxes and combo
boxes<BR><A NAME="Index2346"></A><A NAME="Index2347"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">List boxes and
<A NAME="Index2348"></A><A NAME="Index2349"></A>combo boxes in Swing work much
as they do in the old AWT, but they also have increased functionality if you
need it. In addition, some conveniences have been added. For example, the
<A NAME="Index2350"></A><A NAME="Index2351"></A><B>JList</B> has a constructor
that takes an array of <B>String</B>s to display (oddly enough this same feature
is not available in
<A NAME="Index2352"></A><A NAME="Index2353"></A><B>JComboBox</B>). Here&#8217;s
a simple example that shows the basic use of each:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ListCombo.java</font>
<font color=#009900>// List boxes &amp; Combo boxes</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListCombo <font color=#0000ff>extends</font> JPanel {
  <font color=#0000ff>public</font> ListCombo() {
    setLayout(<font color=#0000ff>new</font> GridLayout(2,1));
    JList list = <font color=#0000ff>new</font> JList(ButtonGroups.ids);
    add(<font color=#0000ff>new</font> JScrollPane(list));
    JComboBox combo = <font color=#0000ff>new</font> JComboBox();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
      combo.addItem(Integer.toString(i));
    add(combo);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> ListCombo(),200,200);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Something else that seems a bit odd
at first is that <B>JList</B>s do not automatically provide scrolling, even
though that&#8217;s something you always expect. Adding support for scrolling
turns out to be quite easy, as shown above &#8211; you simply wrap the
<B>JList</B> in a
<A NAME="Index2354"></A><A NAME="Index2355"></A><B>JScrollPane</B> and all the
details are automatically managed for
you.</FONT><A NAME="_Toc408018736"></A><BR></P></DIV>
<A NAME="Heading472"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Sliders and progress bars</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index2356"></A><A NAME="Index2357"></A>slider allows the user to input
data by moving a point back and forth, which is intuitive in some situations
(volume controls, for example). A
<A NAME="Index2358"></A><A NAME="Index2359"></A>progress bar displays data in a
relative fashion from &#8220;full&#8221; to &#8220;empty&#8221; so the user gets
a perspective. My favorite example for these is to simply hook the slider to the
progress bar so when you move the slider the progress bar changes
accordingly:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Progress.java</font>
<font color=#009900>// Using progress bars and sliders</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> javax.swing.event.*;
<font color=#0000ff>import</font> javax.swing.border.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Progress <font color=#0000ff>extends</font> JPanel {
  JProgressBar pb = <font color=#0000ff>new</font> JProgressBar();
  JSlider sb = 
    <font color=#0000ff>new</font> JSlider(JSlider.HORIZONTAL, 0, 100, 60);
  <font color=#0000ff>public</font> Progress() {
    setLayout(<font color=#0000ff>new</font> GridLayout(2,1));
    add(pb);
    sb.setValue(0);
    sb.setPaintTicks(<font color=#0000ff>true</font>);
    sb.setMajorTickSpacing(20);
    sb.setMinorTickSpacing(5);
    sb.setBorder(<font color=#0000ff>new</font> TitledBorder(<font color=#004488>"Slide Me"</font>));
    pb.setModel(sb.getModel()); <font color=#009900>// Share model</font>
    add(sb);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> Progress(),200,150);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index2360"></A><A NAME="Index2361"></A><B>JProgressBar </B>is fairly
straightforward, but the
<A NAME="Index2362"></A><A NAME="Index2363"></A><B>JSlider</B> has a lot of
options, such as the orientation and major and minor tick marks. Notice how
straightforward it is to add a titled
border.</FONT><A NAME="_Toc408018737"></A><BR></P></DIV>
<A NAME="Heading473"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Trees</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Using a
<A NAME="Index2364"></A><A NAME="Index2365"></A><B>JTree </B>can be as simple as
saying:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>add(<font color=#0000ff>new</font> JTree(
  <font color=#0000ff>new</font> Object[] {<font color=#004488>"this"</font>, <font color=#004488>"that"</font>, <font color=#004488>"other"</font>}));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This displays a primitive
<A NAME="Index2366"></A><A NAME="Index2367"></A>tree. The API for trees is vast,
however &#8211; certainly one of the largest in Swing. It appears that you can
do just about anything with trees, but more sophisticated tasks might require
quite a bit of research and experimentation. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Fortunately, there is a middle
ground provided in the library: the &#8220;default&#8221; tree components, which
generally do what you need. So most of the time you can use these components,
and only in special cases will you need to delve in and understand trees more
deeply.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example uses the
&#8220;default&#8221; tree components to display a tree in an applet. When you
press the button, a new subtree is added under the currently-selected node (if
no node is selected, the root node is used):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Trees.java</font>
<font color=#009900>// Simple Swing tree example. Trees can be made</font>
<font color=#009900>// vastly more complex than this.</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> javax.swing.tree.*;

<font color=#009900>// Takes an array of Strings and makes the first</font>
<font color=#009900>// element a node and the rest leaves:</font>
<font color=#0000ff>class</font> Branch {
  DefaultMutableTreeNode r;
  <font color=#0000ff>public</font> Branch(String[] data) {
    r = <font color=#0000ff>new</font> DefaultMutableTreeNode(data[0]);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 1; i &lt; data.length; i++)
      r.add(<font color=#0000ff>new</font> DefaultMutableTreeNode(data[i]));
  }
  <font color=#0000ff>public</font> DefaultMutableTreeNode node() { 
    <font color=#0000ff>return</font> r; 
  }
}  

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Trees <font color=#0000ff>extends</font> JPanel {
  String[][] data = {
    { <font color=#004488>"Colors"</font>, <font color=#004488>"Red"</font>, <font color=#004488>"Blue"</font>, <font color=#004488>"Green"</font> },
    { <font color=#004488>"Flavors"</font>, <font color=#004488>"Tart"</font>, <font color=#004488>"Sweet"</font>, <font color=#004488>"Bland"</font> },
    { <font color=#004488>"Length"</font>, <font color=#004488>"Short"</font>, <font color=#004488>"Medium"</font>, <font color=#004488>"Long"</font> },
    { <font color=#004488>"Volume"</font>, <font color=#004488>"High"</font>, <font color=#004488>"Medium"</font>, <font color=#004488>"Low"</font> },
    { <font color=#004488>"Temperature"</font>, <font color=#004488>"High"</font>, <font color=#004488>"Medium"</font>, <font color=#004488>"Low"</font> },
    { <font color=#004488>"Intensity"</font>, <font color=#004488>"High"</font>, <font color=#004488>"Medium"</font>, <font color=#004488>"Low"</font> },
  };
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> i = 0;
  DefaultMutableTreeNode root, child, chosen;
  JTree tree;
  DefaultTreeModel model;
  <font color=#0000ff>public</font> Trees() {
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    root = <font color=#0000ff>new</font> DefaultMutableTreeNode(<font color=#004488>"root"</font>);
    tree = <font color=#0000ff>new</font> JTree(root);
    <font color=#009900>// Add it and make it take care of scrolling:</font>
    add(<font color=#0000ff>new</font> JScrollPane(tree), 
      BorderLayout.CENTER);
    <font color=#009900>// Capture the tree's model:</font>
    model =(DefaultTreeModel)tree.getModel();
    JButton test = <font color=#0000ff>new</font> JButton(<font color=#004488>"Press me"</font>);
    test.addActionListener(<font color=#0000ff>new</font> ActionListener() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e){
        <font color=#0000ff>if</font>(i &lt; data.length) {
          child = <font color=#0000ff>new</font> Branch(data[i++]).node();
          <font color=#009900>// What's the last one you clicked?</font>
          chosen = (DefaultMutableTreeNode)
            tree.getLastSelectedPathComponent();
          <font color=#0000ff>if</font>(chosen == <font color=#0000ff>null</font>) chosen = root;
          <font color=#009900>// The model will create the </font>
          <font color=#009900>// appropriate event. In response, the</font>
          <font color=#009900>// tree will update itself:</font>
          model.insertNodeInto(child, chosen, 0);
          <font color=#009900>// This puts the new node on the </font>
          <font color=#009900>// currently chosen node.</font>
        }
      }
    });
    <font color=#009900>// Change the button's colors:</font>
    test.setBackground(Color.blue);
    test.setForeground(Color.white);
    JPanel p = <font color=#0000ff>new</font> JPanel();
    p.add(test);
    add(p, BorderLayout.SOUTH);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> Trees(),200,500);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first class, <B>Branch</B>, is
a tool to take an array of <B>String</B> and build a
<A NAME="Index2368"></A><A NAME="Index2369"></A><B>DefaultMutableTreeNode</B>
with the first <B>String</B> as the root and the rest of the <B>String</B>s in
the array as leaves. Then <B>node(&#160;)</B> can be called to produce the root
of this &#8220;branch.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Trees</B> class contains a
two-dimensional array of <B>String</B>s from which <B>Branch</B>es can be made
and a <B>static int i</B> to count through this array. The
<B>DefaultMutableTreeNode</B> objects hold the nodes, but the physical
representation on screen is controlled by the <B>JTree</B> and its associated
model, the
<A NAME="Index2370"></A><A NAME="Index2371"></A><B>DefaultTreeModel</B>. Note
that when the <B>JTree</B> is added to the applet, it is wrapped in a
<A NAME="Index2372"></A><A NAME="Index2373"></A><B>JScrollPane</B> &#8211; this
is all it takes to provide automatic scrolling.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>JTree</B> is controlled
through its <I>model</I>. When you make a change to the model, the model
generates an event that causes the
<A NAME="Index2374"></A><A NAME="Index2375"></A><B>JTree</B> to perform any
necessary updates to the visible representation of the tree. In
<B>init(&#160;)</B>, the model is captured by calling
<A NAME="Index2376"></A><A NAME="Index2377"></A><B>getModel(&#160;)</B>. When
the button is pressed, a new &#8220;branch&#8221; is created. Then the currently
selected component is found (or the root if nothing is selected) and the
model&#8217;s
<A NAME="Index2378"></A><A NAME="Index2379"></A><B>insertNodeInto(&#160;)</B>
method does all the work of changing the tree and causing it to be
updated.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most of the time an example like
the one above will give you what you need in a tree. However, trees have the
power to do just about anything you can imagine &#8211; everywhere you see the
word &#8220;default&#8221; in the example above, you can substitute your own
class to get different behavior. But beware: almost all of these classes have a
large interface, so you could spend a lot of time struggling to understand the
intricacies of trees.</FONT><A NAME="_Toc408018738"></A><BR></P></DIV>
<A NAME="Heading474"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Tables</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like trees,
<A NAME="Index2380"></A><A NAME="Index2381"></A>tables in Swing are vast and
powerful. They are primarily intended to be the popular &#8220;grid&#8221;
interface to databases via Java Database Connectivity (JDBC, discussed in
Chapter 15) and thus they have a tremendous amount of flexibility, which you pay
for in complexity. There&#8217;s easily enough here to be the basis of a
full-blown spreadsheet and could probably justify an entire book. However, it is
also possible to create a relatively simple <B>JTable</B> if you understand the
basics.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>JTable</B> controls how the
data is displayed, but the <B>TableModel</B> controls the data itself. So to
create a <B>JTable</B> you&#8217;ll typically create a <B>TableModel</B> first.
You can fully implement the <B>TableModel</B> interface, but it&#8217;s usually
simpler to inherit from the helper class
<B>AbstractTableModel</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Table.java</font>
<font color=#009900>// Simple demonstration of JTable</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> javax.swing.table.*;
<font color=#0000ff>import</font> javax.swing.event.*;

<font color=#009900>// The TableModel controls all the data:</font>
<font color=#0000ff>class</font> DataModel <font color=#0000ff>extends</font> AbstractTableModel {
  Object[][] data = {
    {<font color=#004488>"one"</font>, <font color=#004488>"two"</font>, <font color=#004488>"three"</font>, <font color=#004488>"four"</font>},
    {<font color=#004488>"five"</font>, <font color=#004488>"six"</font>, <font color=#004488>"seven"</font>, <font color=#004488>"eight"</font>},
    {<font color=#004488>"nine"</font>, <font color=#004488>"ten"</font>, <font color=#004488>"eleven"</font>, <font color=#004488>"twelve"</font>},
  };
  <font color=#009900>// Prints data when table changes:</font>
  <font color=#0000ff>class</font> TML <font color=#0000ff>implements</font> TableModelListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> tableChanged(TableModelEvent e) {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; data.length; i++) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; data[0].length; j++)
          System.out.print(data[i][j] + <font color=#004488>" "</font>);
        System.out.println();
      }
    }
  }
  DataModel() {
    addTableModelListener(<font color=#0000ff>new</font> TML());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColumnCount() { 
    <font color=#0000ff>return</font> data[0].length; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getRowCount() { 
    <font color=#0000ff>return</font> data.length;
  }
  <font color=#0000ff>public</font> Object getValueAt(<font color=#0000ff>int</font> row, <font color=#0000ff>int</font> col) { 
    <font color=#0000ff>return</font> data[row][col]; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> 
  setValueAt(Object val, <font color=#0000ff>int</font> row, <font color=#0000ff>int</font> col) {
    data[row][col] = val;
    <font color=#009900>// Indicate the change has happened:</font>
    fireTableDataChanged();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
  isCellEditable(<font color=#0000ff>int</font> row, <font color=#0000ff>int</font> col) { 
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>; 
  }
};       

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Table <font color=#0000ff>extends</font> JPanel {
  <font color=#0000ff>public</font> Table() {
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    JTable table = <font color=#0000ff>new</font> JTable(<font color=#0000ff>new</font> DataModel());
    JScrollPane scrollpane = 
      JTable.createScrollPaneForTable(table);
    add(scrollpane, BorderLayout.CENTER);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> Table(),200,200);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DataModel</B> contains an array
of data, but you could also get the data from some other source such as a
database. The constructor adds a <B>TableModelListener</B> which prints the
array every time the table is changed. The rest of the methods follow the Beans
naming convention, and are used by <B>JTable</B> when it wants to present the
information in <B>DataModel</B>. <B>AbstractTableModel</B> provides default
methods for <B>setValueAt(&#160;)</B> and <B>isCellEditable(&#160;)</B> that
prevent changes to the data, so if you want to be able to edit the data, you
must override these methods.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you have a <B>TableModel</B>,
you only need to hand it to the <B>JTable</B> constructor. All the details of
displaying, editing and updating will be taken care of for you. Notice that this
example also puts the <B>JTable</B> in a <B>JScrollPane</B>, which requires a
special <B>JTable</B> method.</FONT><A NAME="_Toc408018739"></A><BR></P></DIV>
<A NAME="Heading475"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Tabbed Panes</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Earlier in this chapter you were
introduced to the positively medieval
<A NAME="Index2382"></A><A NAME="Index2383"></A><B>CardLayout</B>, and saw how
you had to manage all the switching of the ugly cards yourself. Someone actually
thought this was a good design. Fortunately, Swing remedies this by providing<B>
<A NAME="Index2384"></A><A NAME="Index2385"></A>JTabbedPane</B>, which handles
all the tabs, the switching, and everything. The contrast between
<B>CardLayout</B> and <B>JTabbedPane</B> is breathtaking.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example is quite fun
because it takes advantage of the design of the previous examples. They are all
built as descendants of <B>JPanel</B>, so this example will place each one of
the previous examples in its own pane on a <B>JTabbedPane</B>. You&#8217;ll
notice that the use of RTTI makes the example quite small and
elegant:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Tabbed.java</font>
<font color=#009900>// Using tabbed panes</font>
<font color=#0000ff>package</font> c13.swing;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> javax.swing.border.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Tabbed <font color=#0000ff>extends</font> JPanel {
  <font color=#0000ff>static</font> Object[][] q = {
    { <font color=#004488>"Felix"</font>, Borders.<font color=#0000ff>class</font> },
    { <font color=#004488>"The Professor"</font>, Buttons.<font color=#0000ff>class</font> },
    { <font color=#004488>"Rock Bottom"</font>, ButtonGroups.<font color=#0000ff>class</font> },
    { <font color=#004488>"Theodore"</font>, Faces.<font color=#0000ff>class</font> },
    { <font color=#004488>"Simon"</font>, Menus.<font color=#0000ff>class</font> },
    { <font color=#004488>"Alvin"</font>, Popup.<font color=#0000ff>class</font> },
    { <font color=#004488>"Tom"</font>, ListCombo.<font color=#0000ff>class</font> },
    { <font color=#004488>"Jerry"</font>, Progress.<font color=#0000ff>class</font> },
    { <font color=#004488>"Bugs"</font>, Trees.<font color=#0000ff>class</font> },
    { <font color=#004488>"Daffy"</font>, Table.<font color=#0000ff>class</font> },
  };
  <font color=#0000ff>static</font> JPanel makePanel(Class c) {
    String title = c.getName();
    title = title.substring(
      title.lastIndexOf('.') + 1);
    JPanel sp = <font color=#0000ff>null</font>;
    <font color=#0000ff>try</font> {
      sp = (JPanel)c.newInstance();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.out.println(e);
    }
    sp.setBorder(<font color=#0000ff>new</font> TitledBorder(title));
    <font color=#0000ff>return</font> sp;
  }
  <font color=#0000ff>public</font> Tabbed() {
    setLayout(<font color=#0000ff>new</font> BorderLayout());
    JTabbedPane tabbed = <font color=#0000ff>new</font> JTabbedPane();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; q.length; i++)
      tabbed.addTab((String)q[i][0], 
        makePanel((Class)q[i][1]));
    add(tabbed, BorderLayout.CENTER);
    tabbed.setSelectedIndex(q.length/2);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    Show.inFrame(<font color=#0000ff>new</font> Tabbed(),460,350);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Again, you can see the theme of an
array used for configuration: the first element is the <B>String</B> to be
placed on the tab and the second is the <B>JPanel</B> class that will be
displayed inside of the corresponding pane. In the <B>Tabbed(&#160;)</B>
constructor, you can see the two important <B>JTabbedPane</B> methods that are
used: <A NAME="Index2386"></A><A NAME="Index2387"></A><B>addTab(&#160;)</B> to
put a new pane in, and
<A NAME="Index2388"></A><A NAME="Index2389"></A><B>setSelectedIndex(&#160;)</B>
to choose the pane to start with. (One in the middle is chosen just to show that
you don&#8217;t have to start with the first pane.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you call <B>addTab(&#160;)</B>
you supply it with the <B>String</B> for the tab and any
<A NAME="Index2390"></A><A NAME="Index2391"></A><B>Component</B> (that is, an
AWT <B>Component</B>, not just a <B>JComponent</B>, which is derived from the
AWT <B>Component</B>). The <B>Component</B> will be displayed in the pane. Once
you do this, no further management is necessary &#8211; the <B>JTabbedPane</B>
takes care of everything else for you (as it should).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>makePanel(&#160;)</B> method
takes the <B>Class</B> object of the class you want to create and uses
<A NAME="Index2392"></A><A NAME="Index2393"></A><B>newInstance(&#160;)</B> to
create one, casting it to a <B>JPanel</B> (of course, this assumes that any
class you want to add must inherit from <B>JPanel</B>, but that&#8217;s been the
structure used for the examples in this section). It adds a
<A NAME="Index2394"></A><A NAME="Index2395"></A><B>TitledBorder</B> that
contains the name of the class and returns the result as a <B>JPanel</B> to be
used in <B>addTab(&#160;)</B>. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run the program
you&#8217;ll see that the <B>JTabbedPane</B> automatically stacks the tabs if
there are too many of them to fit on one
row.</FONT><A NAME="_Toc408018740"></A><BR></P></DIV>
<A NAME="Heading476"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The Swing message box</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Windowing environments commonly
contain a standard set of
<A NAME="Index2396"></A><A NAME="Index2397"></A>message boxes that allow you to
quickly post information to the user or to capture information from the user. In
Swing, these message boxes are contained in
<A NAME="Index2398"></A><A NAME="Index2399"></A><B>JOptionPane</B>. You have
many different possibilities (some quite sophisticated), but the ones
you&#8217;ll most commonly use are probably the message dialog and confirmation
dialog, invoked using the <B>static</B>
<B>JOptionPane.showMessageDialog(&#160;)</B> and <B>JOptionPane.
showConfirmDialog(&#160;)</B>.<B>
<A NAME="Index2400"></A><A NAME="Index2401"></A><A NAME="Index2402"></A><A NAME="Index2403"></A></B></FONT><A NAME="_Toc408018741"></A><BR></P></DIV>
<A NAME="Heading477"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
More to Swing</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This section was meant only to give
you an introduction to the power of Swing and to get you started so you could
see how relatively simple it is to feel your way through the libraries. What
you&#8217;ve seen so far will probably suffice for a good portion of your UI
design needs. However, there&#8217;s a lot more to Swing &#8211; it&#8217;s
intended to be a fully-powered UI design tool kit. If you don&#8217;t see what
you need here, delve into the online documentation from Sun and search the Web.
There&#8217;s probably a way to accomplish just about everything you can
imagine.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some of the topics that were not
covered in this section include:
<A NAME="Index2404"></A><A NAME="Index2405"></A><A NAME="Index2406"></A><A NAME="Index2407"></A><A NAME="Index2408"></A><A NAME="Index2409"></A><A NAME="Index2410"></A><A NAME="Index2411"></A><A NAME="Index2412"></A><A NAME="Index2413"></A><A NAME="Index2414"></A><A NAME="Index2415"></A><A NAME="Index2416"></A><A NAME="Index2417"></A><A NAME="Index2418"></A><A NAME="Index2419"></A><A NAME="Index2420"></A><A NAME="Index2421"></A><A NAME="Index2422"></A><A NAME="Index2423"></A><A NAME="Index2424"></A><A NAME="Index2425"></A><A NAME="Index2426"></A><A NAME="Index2427"></A><A NAME="Index2428"></A><A NAME="Index2429"></A><A NAME="Index2430"></A><A NAME="Index2431"></A></FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">More specific
components such as <B>JColorChooser</B>, <B>JFileChooser</B>,
<B>JPasswordField</B>, <B>JHTMLPane</B> (which performs simple HTML formatting
and display), and <B>JTextPane</B> (a text editor that supports formatting, word
wrap, and images). These are fairly straightforward to
use.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">The new
event types for Swing. In many ways, these are like exceptions: the type is
what&#8217;s important, and the name can be used to infer just about everything
else about
them.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">A new
layout manager called
<B>BoxLayout</B>.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Splitter
control: a divider style splitter bar that allows you to dynamically manipulate
the position of other
components.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia"><B>JLayeredPane</B>
and <B>JInternalFrame</B>, used together to create child frame windows inside
parent frame windows, to produce <I>multiple-document interface</I> (MDI)
applications.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Pluggable
look and feel, so you can write a single program that can dynamically adapt to
behave as expected under different platforms and operating
systems.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Custom
cursors.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Dockable
floating toolbars with the <B>JToolbar</B>
API.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Double-buffering
and Automatic repaint batching for smoother screen
redraws.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Built-in
&#8220;undo&#8221;
support.</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Drag
and drop
support.</FONT><A NAME="_Toc408018742"></A></UL><A NAME="Heading478"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of all the libraries in Java, the
AWT has seen the most dramatic changes from Java 1.0<A NAME="Index2432"></A> to
Java 1.2<A NAME="Index2433"></A>. The Java 1.0 AWT was roundly criticized as
being one of the worst designs seen, and while it would allow you to create
portable programs, the resulting GUI was &#8220;equally mediocre on all
platforms.&#8221; It was also limiting, awkward, and unpleasant to use compared
with native application development tools on a particular
platform.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When Java
1.1<A NAME="Index2434"></A> introduced the new event model and Java Beans, the
stage was set &#8211; now it was possible to create GUI components that could be
easily dragged and dropped inside visual application builder tools. In addition,
the design of the event model and Beans clearly shows strong consideration for
ease of programming and maintainable code (something that was not evident in the
1.0 AWT). But it wasn&#8217;t until the GUI components &#8211; the JFC/Swing
classes &#8211; appeared that the job was finished. With the Swing components,
cross-platform GUI programming can be a civilized experience.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Actually, the only thing
that&#8217;s missing is the application builder tool, and this is where the real
revolution lies. <A NAME="Index2435"></A>Microsoft&#8217;s Visual Basic and
Visual C++ require their application builder tools, as does
<A NAME="Index2436"></A>Borland&#8217;s Delphi and C++ Builder. If you want the
application builder tool to get better, you have to cross your fingers and hope
the vendor will give you what you want. But Java is an open environment, and so
not only does it allow for competing application builder environments, it
encourages them. And for these tools to be taken seriously, they must support
Java Beans. This means a leveled playing field: if a better application builder
tool comes along, you&#8217;re not tied to the one you&#8217;ve been using
&#8211; you can pick up and move to the new one and increase your productivity.
This kind of competitive environment for GUI application builder tools has not
been seen before, and the resulting competition can generate only positive
results for the productivity of the
programmer.</FONT><A NAME="_Toc375545470"></A><A NAME="_Toc408018743"></A><BR></P></DIV>
<A NAME="Heading479"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
an applet with a text field and three buttons. When you press each button, make
some different text appear in the text
field.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Add
a check box to the applet created in Exercise 1, capture the event, and insert
different text into the text
field.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
an applet and add all the components that cause <B>action(&#160;)</B> to be
called, then capture their events and display an appropriate message for each
inside a text
field.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Add
to Exercise 3 the components that can be used only with events detected by
<B>handleEvent(&#160;)</B>. Override <B>handleEvent(&#160;)</B> and display
appropriate messages for each inside a text
field.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
an applet with a <B>Button</B> and a <B>TextField</B>. Write a
<B>handleEvent(&#160;)</B> so that if the button has the focus, characters typed
into it will appear in the
<B>TextField</B>.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
an application and add to the main frame all the components described in this
chapter, including menus and a dialog
box.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Modify
<B>TextNew.java</B> so that the characters in <B>t2</B> retain the original case
that they were typed in, instead of automatically being forced to upper
case.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Modify
<B>CardLayout1.java</B> so that it uses the Java 1.1 event
model.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Add
<B>Frog.class</B> to the manifest file shown in this chapter and run <B>jar</B>
to create a JAR file containing both <B>Frog</B> and <B>BangBean</B>. Now either
download and install the BDK from Sun or use your own Beans-enabled program
builder tool and add the JAR file to your environment so you can test the two
Beans.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
your own Java Bean called <B>Valve </B>that contains two properties: a Boolean
called &#8220;on&#8221; and an integer called &#8220;level.&#8221; Create a
manifest file, use <B>jar</B> to package your Bean, then load it into the
beanbox or into your own Beans-enabled program builder tool so that you can test
it.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">(Somewhat
challenging) Change <B>Menus.java</B> so that it handles cascading
menus.</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn51" HREF="#fnB51">[51]</A><FONT FACE="Georgia" SIZE=2>
It is assumed that the reader is familiar with the basics of HTML. It&#8217;s
not too hard to figure out, and there are lots of books and
resources.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn52" HREF="#fnB52">[52]</A><FONT FACE="Georgia" SIZE=2>
Because the appletviewer ignores everything but APPLET tags, you can put those
tags in the Java source file as
comments:</FONT><BR><TT><FONT FACE="Courier" SIZE=2>// &lt;applet
code=MyApplet.class width=200
height=100&gt;&lt;/applet&gt;</FONT></TT><BR><FONT FACE="Georgia" SIZE=2>This
way, you can run "<B>appletviewer MyApplet.java</B>" and you don&#8217;t need to
create tiny HTML files to run tests.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn53" HREF="#fnB53">[53]</A><FONT FACE="Georgia" SIZE=2>
<B>ShowStatus(&#160;)</B> is also a method of Applet, so you can call it
directly, without calling <B>getAppletContext(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn54" HREF="#fnB54">[54]</A><FONT FACE="Georgia" SIZE=2>
This behavior is apparently a bug and will be fixed in a later version of
Java.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn55" HREF="#fnB55">[55]</A><FONT FACE="Georgia" SIZE=2>
There is no <B>MouseMotionEvent</B> even though it seems like there ought to be.
Clicking and motion is combined into <B>MouseEvent</B>, so this second
appearance of <B>MouseEvent</B> in the table is not an error.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn56" HREF="#fnB56">[56]</A><FONT FACE="Georgia" SIZE=2>
It also solves the problem of &#8220;callbacks&#8221; without adding any awkward
&#8220;method pointer&#8221; feature to Java.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn57" HREF="#fnB57">[57]</A><FONT FACE="Georgia" SIZE=2>
At the time this section was written, the Swing library had been pronounced
&#8220;frozen&#8221; by Sun, so this code should compile and run without
problems as long as you&#8217;ve downloaded and installed the Swing library.
(You should be able to compile one of Sun&#8217;s included demonstration
programs to test your installation.) If you do encounter difficulties, check
<I>www.BruceEckel.com</I> for updated code.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter12.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter14.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/04/2000</P></DIV>

</BODY>

</HTML>
