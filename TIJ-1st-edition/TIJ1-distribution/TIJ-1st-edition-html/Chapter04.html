<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:Tjava14.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/04/2000
Translation Time:23:24:45
Translation Platform:Win32
Number of Output files:27
This File:Chapter04.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>4: Initialization  and cleanup</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/TIJ2/index.html">2nd Edition</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/javaCD2.html">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 1st edition</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;1998 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter03.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter05.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_4"></A><A NAME="_Toc375545274"></A><A NAME="_Toc407441448"></A><A NAME="_Toc408018475"></A><A NAME="Heading136"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
4: Initialization <BR>and cleanup</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>As the computer
revolution progresses, &#8220;unsafe&#8221; programming has become one of the
major culprits that makes programming expensive.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Two of these safety issues are
<I>initialization</I> and <I>cleanup</I>. Many C bugs occur when the programmer
forgets to initialize a variable. This is especially true with libraries when
users don&#8217;t know how to initialize a library component, or even that they
must. Cleanup is a special problem because it&#8217;s easy to forget about an
element when you&#8217;re done with it, since it no longer concerns you. Thus,
the resources used by that element are retained and you can easily end up
running out of resources (most notably memory). </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C++ introduced the concept of a
<I>constructor</I>, a special method automatically called when an object is
created. Java also adopted the constructor, and in addition has a garbage
collector that automatically releases memory resources when they&#8217;re no
longer being used. This chapter examines the issues of initialization and
cleanup and their support in
Java.</FONT><A NAME="_Toc312373853"></A><A NAME="_Toc375545275"></A><A NAME="_Toc408018476"></A><BR></P></DIV>
<A NAME="Heading137"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Guaranteed initialization <BR>with the constructor</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can imagine creating a method
called <B>initialize(&#160;)</B> for every class you write. The name is a hint
that it should be called before using the object. Unfortunately, this means the
user must remember to call the method. In Java, the class designer can guarantee
initialization of every object by providing a special method called a
<I>constructor<A NAME="Index262"></A><A NAME="Index263"></A></I>. If a class has
a constructor, Java automatically calls that constructor when an object is
created, before users can even get their hands on it. So initialization is
guaranteed.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next challenge is what to name
this method. There are two issues. The first is that any name you use could
clash with a name you might like to use as a member in the class. The second is
that because the compiler is responsible for calling the constructor, it must
always know which method to call. The C++ solution seems the easiest and most
logical, so it&#8217;s also used in Java: The name of the constructor
<A NAME="Index264"></A>is the same as the name of the class. It makes sense that
such a method will be called automatically on initialization.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a simple class with a
constructor: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SimpleConstructor.java</font>
<font color=#009900>// Demonstration of a simple constructor</font>
<font color=#0000ff>package</font> c04;

<font color=#0000ff>class</font> Rock {
  Rock() { <font color=#009900>// This is the constructor</font>
    System.out.println(<font color=#004488>"Creating Rock"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleConstructor {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      <font color=#0000ff>new</font> Rock();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now, when an
<A NAME="Index265"></A>object is created:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>new</font> Rock();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">storage is allocated and the
constructor is called. It is guaranteed that the object will be properly
initialized before you can get your hands on it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the coding style of
making the first letter of all methods lower case does not apply to
constructors, since the name of the constructor must match the name of the class
<I>exactly</I>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like any method, the constructor
can have arguments<A NAME="Index266"></A><A NAME="Index267"></A> to allow you to
specify <I>how</I> an object is created. The above example can easily be changed
so the constructor takes an argument:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Rock {
  Rock(<font color=#0000ff>int</font> i) {
    System.out.println(
      <font color=#004488>"Creating Rock number "</font> + i);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleConstructor {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      <font color=#0000ff>new</font> Rock(i);
  }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructor arguments provide you
with a way to provide parameters for the initialization of an object. For
example, if the class <B>Tree</B> has a constructor that takes a single integer
argument denoting the height of the tree, you would create a <B>Tree</B> object
like this:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Tree t = new Tree(12);  //
12-foot tree</FONT></TT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If <B>Tree(int)</B> is your only
constructor, then the compiler won&#8217;t let you create a <B>Tree</B> object
any other way. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructors eliminate a large
class of problems and make the code easier to read. In the preceding code
fragment, for example, you don&#8217;t see an explicit call to some
<B>initialize(&#160;)</B> method that is conceptually separate from definition.
In Java, definition and initialization are unified concepts &#8211; you
can&#8217;t have one without the other.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor is an unusual type
of method because it has no return
value<A NAME="Index268"></A><A NAME="Index269"></A>. This is distinctly
different from a <B>void</B> return value, in which the method returns nothing
but you still have the option to make it return something else. Constructors
return nothing and you don&#8217;t have an option. If there were a return value,
and if you could select your own, the compiler would somehow need to know what
to do with that return
value.</FONT><A NAME="_Toc375545276"></A><A NAME="_Toc408018477"></A><BR></P></DIV>
<A NAME="Heading138"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Method overloading<BR><A NAME="Index270"></A><A NAME="Index271"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the important features in
any programming language is the use of names. When you create an object, you
give a name to a region of storage. A method is a name for an action. By using
names to describe your system, you create a program that is easier for people to
understand and change. It&#8217;s a lot like writing prose &#8211; the goal is
to communicate with your readers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You refer to all objects and
methods by using names. Well-chosen names make it easier for you and others to
understand your code. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A problem arises when mapping the
concept of nuance in human language onto a programming language. Often, the same
word expresses a number of different meanings &#8211; it&#8217;s
<I>overloaded</I>. This is useful, especially when it comes to trivial
differences. You say &#8220;wash the shirt,&#8221; &#8220;wash the car,&#8221;
and &#8220;wash the dog.&#8221; It would be silly to be forced to say,
&#8220;shirtWash the shirt,&#8221; &#8220;carWash the car,&#8221; and
&#8220;dogWash the dog&#8221; just so the listener doesn&#8217;t need to make
any distinction about the action performed. Most human languages are redundant,
so even if you miss a few words, you can still determine the meaning. We
don&#8217;t need unique identifiers &#8211; we can deduce meaning from
context.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most programming languages (C in
particular) require you to have a unique identifier for each function. So you
could not have one function called <B>print(&#160;)</B> for printing integers
and another called <B>print(&#160;)</B> for printing floats &#8211; each
function requires a unique name.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Java, another factor forces the
overloading of method names: the
constructor<A NAME="Index272"></A><A NAME="Index273"></A>. Because the
constructor&#8217;s name is predetermined by the name of the class, there can be
only one constructor name. But what if you want to create an object in more than
one way? For example, suppose you build a class that can initialize itself in a
standard way and by reading information from a file. You need two constructors,
one that takes no arguments (the <I>default</I> constructor), and one that takes
a <B>String</B> as an argument, which is the name of the file from which to
initialize the object. Both are constructors, so they must have the same name
&#8211; the name of the class. Thus <I>method overloading</I> is essential to
allow the same method name to be used with different argument types. And
although method overloading is a must for constructors, it&#8217;s a general
convenience and can be used with any method. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that shows
both overloaded constructors and overloaded ordinary methods:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Overloading.java</font>
<font color=#009900>// Demonstration of both constructor</font>
<font color=#009900>// and ordinary method overloading.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Tree {
  <font color=#0000ff>int</font> height;
  Tree() {
    prt(<font color=#004488>"Planting a seedling"</font>);
    height = 0;
  }
  Tree(<font color=#0000ff>int</font> i) {
    prt(<font color=#004488>"Creating new Tree that is "</font>
        + i + <font color=#004488>" feet tall"</font>);
    height = i;
  }
  <font color=#0000ff>void</font> info() {
    prt(<font color=#004488>"Tree is "</font> + height
        + <font color=#004488>" feet tall"</font>);
  }
  <font color=#0000ff>void</font> info(String s) {
    prt(s + <font color=#004488>": Tree is "</font>
        + height + <font color=#004488>" feet tall"</font>);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) {
    System.out.println(s);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Overloading {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++) {
      Tree t = <font color=#0000ff>new</font> Tree(i);
      t.info();
      t.info(<font color=#004488>"overloaded method"</font>);
    }
    <font color=#009900>// Overloaded constructor:</font>
    <font color=#0000ff>new</font> Tree();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>Tree</B> object can be created
either as a seedling, with no argument, or as a plant grown in a nursery, with
an existing height. To support this, there are two constructors, one that takes
no arguments (we call constructors that take no arguments
<A NAME="Index274"></A><A NAME="Index275"></A><I>default
constructors</I></FONT><A NAME="fnB17" HREF="#fn17">[17]</A><A NAME="Index276"></A><A NAME="Index277"></A><FONT FACE="Georgia">)
and one that takes the existing height.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might also want to call the
<B>info(&#160;)</B> method in more than one way. For example, with a
<B>String</B> argument if you have an extra message you want printed, and
without if you have nothing more to say. It would seem strange to give two
separate names to what is obviously the same concept. Fortunately, method
overloading allows you to use the same name for
both.</FONT><A NAME="_Toc375545277"></A><A NAME="_Toc408018478"></A><BR></P></DIV>
<A NAME="Heading139"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Distinguishing overloaded
methods<BR><A NAME="Index278"></A><A NAME="Index279"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the methods have the same name,
how can Java know which method you mean? There&#8217;s a simple rule: Each
overloaded method must take a unique list of argument types.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you think about this for a
second, it makes sense: how else could a programmer tell the difference between
two methods that have the same name, other than by the types of their
arguments?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Even differences in the ordering of
arguments is sufficient to distinguish two methods: (Although you don&#8217;t
normally want to take this approach, as it produces difficult-to-maintain
code.)</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: OverloadingOrder.java</font>
<font color=#009900>// Overloading based on the order of</font>
<font color=#009900>// the arguments.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> OverloadingOrder {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(String s, <font color=#0000ff>int</font> i) {
    System.out.println(
      <font color=#004488>"String: "</font> + s +
      <font color=#004488>", int: "</font> + i);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>int</font> i, String s) {
    System.out.println(
      <font color=#004488>"int: "</font> + i +
      <font color=#004488>", String: "</font> + s);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    print(<font color=#004488>"String first"</font>, 11);
    print(99, <font color=#004488>"Int first"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The two <B>print(&#160;)</B>
methods have identical arguments, but the order is different, and that&#8217;s
what makes them
distinct.</FONT><A NAME="_Toc312373866"></A><A NAME="_Toc375545278"></A><A NAME="_Toc408018479"></A><BR></P></DIV>
<A NAME="Heading140"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Overloading with primitives</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Primitives can be automatically
promoted from a smaller type to a larger one and this can be slightly confusing
in combination with overloading. The following example demonstrates what happens
when a primitive is handed to an overloaded method:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PrimitiveOverloading.java</font>
<font color=#009900>// Promotion of primitives and overloading</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrimitiveOverloading {
  <font color=#009900>// boolean can't be automatically converted</font>
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) { 
    System.out.println(s); 
  }

  <font color=#0000ff>void</font> f1(<font color=#0000ff>char</font> x) { prt(<font color=#004488>"f1(char)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>byte</font> x) { prt(<font color=#004488>"f1(byte)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>short</font> x) { prt(<font color=#004488>"f1(short)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>int</font> x) { prt(<font color=#004488>"f1(int)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>long</font> x) { prt(<font color=#004488>"f1(long)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>float</font> x) { prt(<font color=#004488>"f1(float)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>double</font> x) { prt(<font color=#004488>"f1(double)"</font>); }

  <font color=#0000ff>void</font> f2(<font color=#0000ff>byte</font> x) { prt(<font color=#004488>"f2(byte)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>short</font> x) { prt(<font color=#004488>"f2(short)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>int</font> x) { prt(<font color=#004488>"f2(int)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>long</font> x) { prt(<font color=#004488>"f2(long)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>float</font> x) { prt(<font color=#004488>"f2(float)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>double</font> x) { prt(<font color=#004488>"f2(double)"</font>); }

  <font color=#0000ff>void</font> f3(<font color=#0000ff>short</font> x) { prt(<font color=#004488>"f3(short)"</font>); }
  <font color=#0000ff>void</font> f3(<font color=#0000ff>int</font> x) { prt(<font color=#004488>"f3(int)"</font>); }
  <font color=#0000ff>void</font> f3(<font color=#0000ff>long</font> x) { prt(<font color=#004488>"f3(long)"</font>); }
  <font color=#0000ff>void</font> f3(<font color=#0000ff>float</font> x) { prt(<font color=#004488>"f3(float)"</font>); }
  <font color=#0000ff>void</font> f3(<font color=#0000ff>double</font> x) { prt(<font color=#004488>"f3(double)"</font>); }

  <font color=#0000ff>void</font> f4(<font color=#0000ff>int</font> x) { prt(<font color=#004488>"f4(int)"</font>); }
  <font color=#0000ff>void</font> f4(<font color=#0000ff>long</font> x) { prt(<font color=#004488>"f4(long)"</font>); }
  <font color=#0000ff>void</font> f4(<font color=#0000ff>float</font> x) { prt(<font color=#004488>"f4(float)"</font>); }
  <font color=#0000ff>void</font> f4(<font color=#0000ff>double</font> x) { prt(<font color=#004488>"f4(double)"</font>); }

  <font color=#0000ff>void</font> f5(<font color=#0000ff>long</font> x) { prt(<font color=#004488>"f5(long)"</font>); }
  <font color=#0000ff>void</font> f5(<font color=#0000ff>float</font> x) { prt(<font color=#004488>"f5(float)"</font>); }
  <font color=#0000ff>void</font> f5(<font color=#0000ff>double</font> x) { prt(<font color=#004488>"f5(double)"</font>); }

  <font color=#0000ff>void</font> f6(<font color=#0000ff>float</font> x) { prt(<font color=#004488>"f6(float)"</font>); }
  <font color=#0000ff>void</font> f6(<font color=#0000ff>double</font> x) { prt(<font color=#004488>"f6(double)"</font>); }

  <font color=#0000ff>void</font> f7(<font color=#0000ff>double</font> x) { prt(<font color=#004488>"f7(double)"</font>); }

  <font color=#0000ff>void</font> testConstVal() {
    prt(<font color=#004488>"Testing with 5"</font>);
    f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5);
  }
  <font color=#0000ff>void</font> testChar() {
    <font color=#0000ff>char</font> x = 'x';
    prt(<font color=#004488>"char argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color=#0000ff>void</font> testByte() {
    <font color=#0000ff>byte</font> x = 0;
    prt(<font color=#004488>"byte argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color=#0000ff>void</font> testShort() {
    <font color=#0000ff>short</font> x = 0;
    prt(<font color=#004488>"short argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color=#0000ff>void</font> testInt() {
    <font color=#0000ff>int</font> x = 0;
    prt(<font color=#004488>"int argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color=#0000ff>void</font> testLong() {
    <font color=#0000ff>long</font> x = 0;
    prt(<font color=#004488>"long argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color=#0000ff>void</font> testFloat() {
    <font color=#0000ff>float</font> x = 0;
    prt(<font color=#004488>"float argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color=#0000ff>void</font> testDouble() {
    <font color=#0000ff>double</font> x = 0;
    prt(<font color=#004488>"double argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    PrimitiveOverloading p = 
      <font color=#0000ff>new</font> PrimitiveOverloading();
    p.testConstVal();
    p.testChar();
    p.testByte();
    p.testShort();
    p.testInt();
    p.testLong();
    p.testFloat();
    p.testDouble();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you view the output of this
program, you&#8217;ll see that the constant value 5 is treated as an <B>int</B>,
so if an overloaded method is available that takes an <B>int</B> it is used. In
all other cases, if you have a data type that is smaller than the argument in
the method, that data type is promoted. <B>char</B> produces a slightly
different effect, since if it doesn&#8217;t find an exact <B>char</B> match, it
is promoted to <B>int</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What happens if your argument is
<I>bigger</I> than the argument expected by the overloaded method? A
modification of the above program gives the answer:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Demotion.java</font>
<font color=#009900>// Demotion of primitives and overloading</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Demotion {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) { 
    System.out.println(s); 
  }

  <font color=#0000ff>void</font> f1(<font color=#0000ff>char</font> x) { prt(<font color=#004488>"f1(char)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>byte</font> x) { prt(<font color=#004488>"f1(byte)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>short</font> x) { prt(<font color=#004488>"f1(short)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>int</font> x) { prt(<font color=#004488>"f1(int)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>long</font> x) { prt(<font color=#004488>"f1(long)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>float</font> x) { prt(<font color=#004488>"f1(float)"</font>); }
  <font color=#0000ff>void</font> f1(<font color=#0000ff>double</font> x) { prt(<font color=#004488>"f1(double)"</font>); }

  <font color=#0000ff>void</font> f2(<font color=#0000ff>char</font> x) { prt(<font color=#004488>"f2(char)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>byte</font> x) { prt(<font color=#004488>"f2(byte)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>short</font> x) { prt(<font color=#004488>"f2(short)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>int</font> x) { prt(<font color=#004488>"f2(int)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>long</font> x) { prt(<font color=#004488>"f2(long)"</font>); }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>float</font> x) { prt(<font color=#004488>"f2(float)"</font>); }

  <font color=#0000ff>void</font> f3(<font color=#0000ff>char</font> x) { prt(<font color=#004488>"f3(char)"</font>); }
  <font color=#0000ff>void</font> f3(<font color=#0000ff>byte</font> x) { prt(<font color=#004488>"f3(byte)"</font>); }
  <font color=#0000ff>void</font> f3(<font color=#0000ff>short</font> x) { prt(<font color=#004488>"f3(short)"</font>); }
  <font color=#0000ff>void</font> f3(<font color=#0000ff>int</font> x) { prt(<font color=#004488>"f3(int)"</font>); }
  <font color=#0000ff>void</font> f3(<font color=#0000ff>long</font> x) { prt(<font color=#004488>"f3(long)"</font>); }

  <font color=#0000ff>void</font> f4(<font color=#0000ff>char</font> x) { prt(<font color=#004488>"f4(char)"</font>); }
  <font color=#0000ff>void</font> f4(<font color=#0000ff>byte</font> x) { prt(<font color=#004488>"f4(byte)"</font>); }
  <font color=#0000ff>void</font> f4(<font color=#0000ff>short</font> x) { prt(<font color=#004488>"f4(short)"</font>); }
  <font color=#0000ff>void</font> f4(<font color=#0000ff>int</font> x) { prt(<font color=#004488>"f4(int)"</font>); }

  <font color=#0000ff>void</font> f5(<font color=#0000ff>char</font> x) { prt(<font color=#004488>"f5(char)"</font>); }
  <font color=#0000ff>void</font> f5(<font color=#0000ff>byte</font> x) { prt(<font color=#004488>"f5(byte)"</font>); }
  <font color=#0000ff>void</font> f5(<font color=#0000ff>short</font> x) { prt(<font color=#004488>"f5(short)"</font>); }

  <font color=#0000ff>void</font> f6(<font color=#0000ff>char</font> x) { prt(<font color=#004488>"f6(char)"</font>); }
  <font color=#0000ff>void</font> f6(<font color=#0000ff>byte</font> x) { prt(<font color=#004488>"f6(byte)"</font>); }

  <font color=#0000ff>void</font> f7(<font color=#0000ff>char</font> x) { prt(<font color=#004488>"f7(char)"</font>); }

  <font color=#0000ff>void</font> testDouble() {
    <font color=#0000ff>double</font> x = 0;
    prt(<font color=#004488>"double argument:"</font>);
    f1(x);f2((<font color=#0000ff>float</font>)x);f3((<font color=#0000ff>long</font>)x);f4((<font color=#0000ff>int</font>)x);
    f5((<font color=#0000ff>short</font>)x);f6((<font color=#0000ff>byte</font>)x);f7((<font color=#0000ff>char</font>)x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Demotion p = <font color=#0000ff>new</font> Demotion();
    p.testDouble();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, the methods take narrower
primitive values. If your argument is wider then you must
<A NAME="Index280"></A><I>cast</I> to the necessary type using the type name in
parentheses. If you don&#8217;t do this, the compiler will issue an error
message.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You should be aware that this is a
<A NAME="Index281"></A><A NAME="Index282"></A><I>narrowing conversion,</I> which
means you might lose information during the cast. This is why the compiler
forces you to do it &#8211; to flag the narrowing conversion.
</FONT><A NAME="_Toc408018480"></A><BR></P></DIV>
<A NAME="Heading141"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Overloading on return
values<BR><A NAME="Index283"></A><A NAME="Index284"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is common to wonder &#8220;Why
only class names and method argument lists? Why not distinguish between methods
based on their return values?&#8221; For example, these two methods, which have
the same name and arguments, are easily distinguished from each
other:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> f() {}</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">int f()
{}</FONT></TT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This works fine when the compiler
can unequivocally determine the meaning from the context, as in <B>int x =
f(&#160;)</B>. However, you can call a method and ignore the return value; this
is often referred to as <I>calling a method for its <A NAME="Index285"></A>side
effect</I> since you don&#8217;t care about the return value but instead want
the other effects of the method call. So if you call the method this
way:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>f();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">how can Java determine which
<B>f(&#160;)</B> should be called? And how could someone reading the code see
it? Because of this sort of problem, you cannot use return value types to
distinguish overloaded
methods.</FONT><A NAME="_Toc375545279"></A><A NAME="_Toc408018481"></A><BR></P></DIV>
<A NAME="Heading142"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Default constructors</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As mentioned previously, a default
constructor <A NAME="Index286"></A><A NAME="Index287"></A>is one without
arguments, used to create a &#8220;vanilla object.&#8221; If you create a class
that has no constructors, the compiler will automatically create a default
constructor for you. For example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: DefaultConstructor.java</font>

<font color=#0000ff>class</font> Bird {
  <font color=#0000ff>int</font> i;
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DefaultConstructor {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Bird nc = <font color=#0000ff>new</font> Bird(); <font color=#009900>// default!</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The line</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>new</font> Bird();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">creates a new object and calls the
default constructor, even though one was not explicitly defined. Without it we
would have no method to call to build our object. However, if you define any
constructors (with or without arguments), the compiler will <I>not</I>
synthesize one for you:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Bush {
  Bush(<font color=#0000ff>int</font> i) {}
  Bush(<font color=#0000ff>double</font> d) {}
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now if you say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>new</font> Bush();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">the compiler will complain that it
cannot find a constructor that matches. It&#8217;s as if when you don&#8217;t
put in any constructors, the compiler says &#8220;You are bound to need
<I>some</I> constructor, so let me make one for you.&#8221; But if you write a
constructor, the compiler says &#8220;You&#8217;ve written a constructor so you
know what you&#8217;re doing; if you didn&#8217;t put in a default it&#8217;s
because you meant to leave it
out.&#8221;</FONT><A NAME="_Toc375545280"></A><A NAME="_Toc408018482"></A><BR></P></DIV>
<A NAME="Heading143"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The <A NAME="Index288"></A>this keyword</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you have two objects of the same
type called <B>a</B> and <B>b</B>, you might wonder how it is that you can call
a method <B>f(&#160;)</B> for both those objects:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Banana { <font color=#0000ff>void</font> f(<font color=#0000ff>int</font> i) { <font color=#009900>/* ... */</font> } }
Banana a = <font color=#0000ff>new</font> Banana(), b = <font color=#0000ff>new</font> Banana();
a.f(1);
b.f(2);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If there&#8217;s only one method
called <B>f(&#160;)</B>, how can that method know whether it&#8217;s being
called for the object <B>a</B> or <B>b</B>? </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To allow you to write the code in a
convenient object-oriented syntax in which you &#8220;send a message to an
object,&#8221; the compiler does some undercover work for you. There&#8217;s a
secret first argument passed to the method <B>f(&#160;)</B>, and that argument
is the handle to the object that&#8217;s being manipulated. So the two method
calls above become something like:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Banana.f(a,1);
Banana.f(b,2);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is internal and you
can&#8217;t write these expressions and get the compiler to accept them, but it
gives you an idea of what&#8217;s happening.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Suppose you&#8217;re inside a
method and you&#8217;d like to get the handle to the current object. Since that
handle is passed <I>secretly</I> by the compiler, there&#8217;s no identifier
for it. However, for this purpose there&#8217;s a keyword: <B>this</B>. The
<B>this</B> keyword &#8211; which can be used only inside a method &#8211;
produces the handle to the object the method has been called for. You can treat
this handle just like any other object handle. Keep in mind that if you&#8217;re
calling a method of your class from within another method of your class, you
don&#8217;t need to use <B>this;</B> you simply call the method. The current
<B>this</B> handle is automatically used for the other method. Thus you can
say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Apricot {
  <font color=#0000ff>void</font> pick() { <font color=#009900>/* ... */</font> }
  <font color=#0000ff>void</font> pit() { pick(); <font color=#009900>/* ... */</font> }
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Inside <B>pit(&#160;)</B>, you
<I>could</I> say <B>this.pick(&#160;)</B> but there&#8217;s no need to. The
compiler does it for you automatically. The <B>this</B> keyword is used only for
those special cases in which you need to explicitly use the handle to the
current object. For example, it&#8217;s often used in <B>return</B> statements
when you want to return the handle to the current object:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Leaf.java</font>
<font color=#009900>// Simple use of the "this" keyword</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Leaf {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 0;
  Leaf increment() {
    i++;
    <font color=#0000ff>return</font> <font color=#0000ff>this</font>;
  }
  <font color=#0000ff>void</font> print() {
    System.out.println(<font color=#004488>"i = "</font> + i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Leaf x = <font color=#0000ff>new</font> Leaf();
    x.increment().increment().increment().print();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because <B>increment(&#160;)</B>
returns the handle to the current object via the <B>this</B> keyword, multiple
operations can easily be performed on the same object.</FONT><BR></P></DIV>
<A NAME="Heading144"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Calling constructors from constructors<BR><A NAME="Index289"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you write several constructors
for a class, there are times when you&#8217;d like to call one constructor from
another to avoid duplicating code. You can do this using the <B>this</B>
keyword. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Normally, when you say <B>this</B>,
it is in the sense of &#8220;this object&#8221; or &#8220;the current
object,&#8221; and by itself it produces the handle to the current object. In a
constructor, the <B>this</B> keyword takes on a different meaning when you give
it an argument list: it makes an explicit call to the constructor that matches
that argument list. Thus you have a straightforward way to call other
constructors:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Flower.java</font>
<font color=#009900>// Calling constructors with "this"</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Flower {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> petalCount = 0;
  <font color=#0000ff>private</font> String s = <font color=#0000ff>new</font> String(<font color=#004488>"null"</font>);
  Flower(<font color=#0000ff>int</font> petals) {
    petalCount = petals;
    System.out.println(
      <font color=#004488>"Constructor w</font><font color=#004488>/ int arg only, petalCount= "</font>
      + petalCount);
  }
  Flower(String ss) {
    System.out.println(
      <font color=#004488>"Constructor w</font><font color=#004488>/ String arg only, s="</font> + ss);
    s = ss;
  }
  Flower(String s, <font color=#0000ff>int</font> petals) {
    <font color=#0000ff>this</font>(petals);
<font color=#009900>//!    this(s); // Can't call two!</font>
    <font color=#0000ff>this</font>.s = s; <font color=#009900>// Another use of "this"</font>
    System.out.println(<font color=#004488>"String &amp; int args"</font>);
  }
  Flower() {
    <font color=#0000ff>this</font>(<font color=#004488>"hi"</font>, 47);
    System.out.println(
      <font color=#004488>"default constructor (no args)"</font>);
  }
  <font color=#0000ff>void</font> print() {
<font color=#009900>//!    this(11); // Not inside non-constructor!</font>
    System.out.println(
      <font color=#004488>"petalCount = "</font> + petalCount + <font color=#004488>" s = "</font>+ s);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Flower x = <font color=#0000ff>new</font> Flower();
    x.print();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor <B>Flower(String s,
int petals)</B> shows that, while you can call one constructor using
<B>this</B>, you cannot call two. In addition, the constructor call must be the
first thing you do or you&#8217;ll get a compiler error
message.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example also shows another way
you&#8217;ll see <B>this</B> used. Since the name of the argument <B>s </B>and
the name of the member data <B>s</B> are the same, there&#8217;s an ambiguity.
You can resolve it by saying <B>this.s</B> to refer to the member data.
You&#8217;ll often see this form used in Java code, and it&#8217;s used in
numerous places in this book.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>print(&#160;)</B> you can see
that the compiler won&#8217;t let you call a constructor from inside any method
other than a constructor.</FONT><BR></P></DIV>
<A NAME="Heading145"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The meaning of static<BR><A NAME="Index290"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With the <B>this </B>keyword in
mind, you can more fully understand what it means to make a
<A NAME="Index291"></A><A NAME="Index292"></A>method <B>static</B>. It means
that there is no <B>this</B> for that particular method. You cannot call
non-<B>static</B> methods from inside <B>static</B>
methods</FONT><A NAME="fnB18" HREF="#fn18">[18]</A><FONT FACE="Georgia">
(although the reverse is possible), and you can call a <B>static</B> method for
the class itself, without any object. In fact, that&#8217;s primarily what a
<B>static</B> method is for. It&#8217;s as if you&#8217;re creating the
equivalent of a global function (from C). Except global functions are not
permitted in Java, and putting the <B>static</B> method inside a class allows it
access to other <B>static </B>methods and to <B>static</B>
fields.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some people argue that
<B>static</B> methods are not object-oriented since they do have the semantics
of a global function; with a <B>static</B> method you don&#8217;t send a message
to an object, since there&#8217;s no <B>this</B>. This is probably a fair
argument, and if you find yourself using a <I>lot</I> of static methods you
should probably rethink your strategy. However, <B>static</B>s are pragmatic and
there are times when you genuinely need them, so whether or not they are
&#8220;proper OOP&#8221; should be left to the theoreticians. Indeed, even
<A NAME="Index293"></A>Smalltalk has the equivalent in its &#8220;class
methods.&#8221;</FONT><A NAME="_Toc375545281"></A><A NAME="_Toc408018483"></A><BR></P></DIV>
<A NAME="Heading146"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Cleanup: finalization and <BR>garbage collection</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Programmers know about the
importance of initialization, but often forget the importance of cleanup. After
all, who needs to clean up an <B>int</B>? But with libraries, simply
&#8220;letting go&#8221; of an object once you&#8217;re done with it is not
always safe. Of course, Java has the <A NAME="Index294"></A>garbage collector to
reclaim the memory of objects that are no longer used. Now consider a very
special and unusual case. Suppose your object allocates &#8220;special&#8221;
memory without using <A NAME="Index295"></A><B>new</B>. The garbage collector
knows only how to release memory allocated <I>with</I> <B>new</B>, so it
won&#8217;t know how to release the object&#8217;s &#8220;special&#8221; memory.
To handle this case, Java provides a method called
<A NAME="Index296"></A><B>finalize(&#160;)</B> that you can define for your
class. Here&#8217;s how it&#8217;s <I>supposed</I> to work. When the garbage
collector is ready to release the storage used for your object, it will first
call <B>finalize(&#160;)</B>, and only on the next garbage-collection pass will
it reclaim the object&#8217;s memory. So if you choose to use
<B>finalize(&#160;)</B>, it gives you the ability to perform some important
cleanup <I>at the time of garbage collection</I>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is a potential programming
pitfall because some programmers, especially C++ programmers, might initially
mistake <B>finalize(&#160;)</B> for the <A NAME="Index297"></A><I>destructor</I>
in C++, which is a function that is always called when an object is destroyed.
But it is important to distinguish between C++ and Java here, because in C++
<I>objects always get destroyed</I> (in a bug-free program), whereas in Java
objects do not always get garbage-collected. Or, put another
way:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>Garbage collection is not
destruction.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you remember this, you will stay
out of trouble. What it means is that if there is some activity that must be
performed before you no longer need an object, you must perform that activity
yourself. Java has no destructor or similar concept, so you must create an
ordinary method to perform this cleanup. For example, suppose in the process of
creating your object it draws itself on the screen. If you don&#8217;t
explicitly erase its image from the screen, it might never get cleaned up. If
you put some kind of erasing functionality inside <B>finalize(&#160;)</B>, then
if an object is garbage-collected, the image will first be removed from the
screen, but if it isn&#8217;t, the image will remain. So a second point to
remember is:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>Your objects might not
get garbage collected.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might find that the storage for
an object never gets released because your program never nears the point of
running out of storage. If your program completes and the garbage collector
never gets around to releasing the storage for any of your objects, that storage
will be returned to the operating system <I>en masse</I> as the program exits.
This is a good thing, because garbage collection has some overhead, and if you
never do it you never incur that
expense.</FONT><A NAME="_Toc375545282"></A><A NAME="_Toc408018484"></A><BR></P></DIV>
<A NAME="Heading147"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
What is finalize(&#160;) for?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might believe at this point
that you should not use <B>finalize(&#160;)</B> as a general-purpose cleanup
method. What good is it?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A third point to remember
is:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>Garbage collection is
only about memory.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That is, the sole reason for the
existence of the garbage collector is to recover memory that your program is no
longer using. So any activity that is associated with garbage collection, most
notably your <B>finalize(&#160;)</B> method, must also be only about memory and
its deallocation. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Does this mean that if your object
contains other objects <B>finalize(&#160;)</B> should explicitly release those
objects? Well, no &#8211; the garbage collector takes care of the release of all
object memory regardless of how the object is created. It turns out that the
need for <B>finalize(&#160;)</B> is limited to special cases, in which your
object can allocate some storage in some way other than creating an object. But,
you might observe, everything in Java is an object so how can this
be?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It would seem that
<B>finalize(&#160;)</B> is in place because of the possibility that you&#8217;ll
do something C-like by allocating memory using a mechanism other than the normal
one in Java. This can happen primarily through <I>native methods</I>, which are
a way to call non-Java code from Java. (Native methods are discussed in Appendix
A.) C and C++ are the only languages currently supported by native methods, but
since they can call subprograms in other languages, you can effectively call
anything. Inside the non-Java code, C&#8217;s <B>malloc(&#160;)</B> family of
functions might be called to allocate storage, and unless you call
<B>free(&#160;)</B> that storage will not be released, causing a memory leak. Of
course, <B>free(&#160;)</B> is a C and C++ function, so you&#8217;d need call it
in a native method inside your <B>finalize(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After reading this, you probably
get the idea that you won&#8217;t use <B>finalize(&#160;)</B> much. You&#8217;re
correct; it is not the appropriate place for normal cleanup to occur. So where
should normal cleanup be
performed?</FONT><A NAME="_Toc312373857"></A><A NAME="_Toc375545283"></A><A NAME="_Toc408018485"></A><BR></P></DIV>
<A NAME="Heading148"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
You must perform cleanup</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To clean up an object, the user of
that object must call a <A NAME="Index298"></A>cleanup method at the point the
cleanup is desired. This sounds pretty straightforward, but it collides a bit
with the C++ concept of the <A NAME="Index299"></A>destructor. In C++, all
objects are destroyed. Or rather, all objects <I>should be</I> destroyed. If the
C++ object is created as a local, i.e. on the stack (not possible in Java), then
the destruction happens at the closing curly brace of the scope in which the
object was created. If the object was created using <B>new</B> (like in Java)
the destructor is called when the programmer calls the C++ operator
<B>delete</B> (which doesn&#8217;t exist in Java). If the programmer forgets,
the destructor is never called and you have a memory leak, plus the other parts
of the object never get cleaned up.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In contrast, Java doesn&#8217;t
allow you to create local objects &#8211; you must always use <B>new</B>. But in
Java, there&#8217;s no &#8220;delete&#8221; to call for releasing the object
since the garbage collector releases the storage for you. So from a simplistic
standpoint you could say that because of garbage collection, Java has no
destructor. You&#8217;ll see as this book progresses, however, that the presence
of a <A NAME="Index300"></A>garbage collector does not remove the need or
utility of destructors. (And you should never call
<A NAME="Index301"></A><B>finalize(&#160;)</B> directly, so that&#8217;s not an
appropriate avenue for a solution.) If you want some kind of cleanup performed
other than storage release you must <I>still</I> call a method in Java, which is
the equivalent of a C++ destructor without the convenience.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the things
<B>finalize(&#160;)</B> can be useful for is observing the process of garbage
collection. The following example shows you what&#8217;s going on and summarizes
the previous descriptions of garbage collection:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Garbage.java</font>
<font color=#009900>// Demonstration of the garbage</font>
<font color=#009900>// collector and finalization</font>

<font color=#0000ff>class</font> Chair {
  <font color=#0000ff>static</font> <font color=#0000ff>boolean</font> gcrun = <font color=#0000ff>false</font>;
  <font color=#0000ff>static</font> <font color=#0000ff>boolean</font> f = <font color=#0000ff>false</font>;
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> created = 0;
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> finalized = 0;
  <font color=#0000ff>int</font> i;
  Chair() {
    i = ++created;
    <font color=#0000ff>if</font>(created == 47) 
      System.out.println(<font color=#004488>"Created 47"</font>);
  }
  <font color=#0000ff>protected</font> <font color=#0000ff>void</font> finalize() {
    <font color=#0000ff>if</font>(!gcrun) {
      gcrun = <font color=#0000ff>true</font>;
      System.out.println(
        <font color=#004488>"Beginning to finalize after "</font> +
        created + <font color=#004488>" Chairs have been created"</font>);
    }
    <font color=#0000ff>if</font>(i == 47) {
      System.out.println(
        <font color=#004488>"Finalizing Chair #47, "</font> +
        <font color=#004488>"Setting flag to stop Chair creation"</font>);
      f = <font color=#0000ff>true</font>;
    }
    finalized++;
    <font color=#0000ff>if</font>(finalized &gt;= created)
      System.out.println(
        <font color=#004488>"All "</font> + finalized + <font color=#004488>" finalized"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Garbage {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length == 0) {
      System.err.println(<font color=#004488>"Usage: \n"</font> +
        <font color=#004488>"java Garbage before\n  or:\n"</font> +
        <font color=#004488>"java Garbage after"</font>);
      <font color=#0000ff>return</font>;
    }
    <font color=#0000ff>while</font>(!Chair.f) {
      <font color=#0000ff>new</font> Chair();
      <font color=#0000ff>new</font> String(<font color=#004488>"To take up space"</font>);
    }
    System.out.println(
      <font color=#004488>"After all Chairs have been created:\n"</font> +
      <font color=#004488>"total created = "</font> + Chair.created +
      <font color=#004488>", total finalized = "</font> + Chair.finalized);
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"before"</font>)) {
      System.out.println(<font color=#004488>"gc():"</font>);
      System.gc();
      System.out.println(<font color=#004488>"runFinalization():"</font>);
      System.runFinalization();
    }
    System.out.println(<font color=#004488>"bye!"</font>);
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"after"</font>))
      System.runFinalizersOnExit(<font color=#0000ff>true</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The above program creates many
<B>Chair</B> objects, and at some point after the garbage collector begins
running, the program stops creating <B>Chair</B>s. Since the garbage collector
can run at any time, you don&#8217;t know exactly when it will start up, so
there&#8217;s a flag called <B>gcrun</B> to indicate whether the garbage
collector has started running yet. A second flag <B>f</B> is a way for
<B>Chair</B> to tell the <B>main(&#160;)</B> loop that it should stop making
objects. Both of these flags are set within <B>finalize(&#160;)</B>, which is
called during garbage collection.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Two other <B>static</B> variables,
<B>created</B> and <B>finalized</B>, keep track of the number of <B>obj</B>s
created versus the number that get finalized by the garbage collector. Finally,
each <B>Chair</B> has its own (non-<B>static</B>) <B>int</B> <B>i</B> so it can
keep track of what number it is. When <B>Chair</B> number 47 is finalized, the
flag is set to <B>true</B> to bring the process of <B>Chair </B>creation to a
stop.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All this happens in
<B>main(&#160;)</B>, in the loop</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>while</font>(!Chair.f) {
      <font color=#0000ff>new</font> Chair();
      <font color=#0000ff>new</font> String(<font color=#004488>"To take up space"</font>);
    }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might wonder how this loop
could ever finish, since there&#8217;s nothing inside that changes the value of
<B>Chair.f</B>. However, the <B>finalize(&#160;)</B> process will, eventually,
when it finalizes number 47.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"> The creation of a <B>String</B>
object during each iteration is simply extra garbage being created to encourage
the garbage collector to kick in, which it will do when it starts to get nervous
about the amount of memory available.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run the program, you
provide a command-line argument of &#8220;before&#8221; or &#8220;after.&#8221;
The &#8220;before&#8221; argument will call the <B>System.gc(&#160;)</B> method
(to force execution of the garbage collector) along with the
<B>System.runFinalization(&#160;)</B> method to run the finalizers. These
methods were available in <A NAME="Index302"></A>Java 1.0, but the
<A NAME="Index303"></A><B>runFinalizersOnExit(&#160;)</B> method that is invoked
by using the &#8220;after&#8221; argument is available only in Java
1.1<A NAME="Index304"></A></FONT><A NAME="fnB19" HREF="#fn19">[19]</A><FONT FACE="Georgia">
and beyond. (Note you can call this method any time during program execution,
and the execution of the finalizers is independent of whether the garbage
collector runs).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The preceding program shows that,
in Java 1.1, the promise that finalizers will always be run holds true, but only
if you explicitly force it to happen yourself. If you use an argument that
isn&#8217;t &#8220;before&#8221; or &#8220;after&#8221; (such as
&#8220;none&#8221;), then neither finalization process will occur, and
you&#8217;ll get an output like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Created 47
Beginning to finalize after 8694 Chairs have been created
Finalizing Chair #47, Setting flag to stop Chair creation
After all Chairs have been created:
total created = 9834, total finalized = 108
bye!</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, not all finalizers get called
by the time the program
completes.</FONT><A NAME="fnB20" HREF="#fn20">[20]</A><FONT FACE="Georgia">
To force finalization to happen, you can call <B>System.gc(&#160;)</B> followed
by <B>System.runFinalization(&#160;)</B>. This will destroy all the objects that
are no longer in use up to that point. The odd thing about this is that you call
<B>gc(&#160;)</B> <I>before</I> you call <B>runFinalization(&#160;)</B>, which
seems to contradict the Sun documentation, which claims that finalizers are run
first, and then the storage is released. However, if you call
<B>runFinalization(&#160;)</B> first, and then <B>gc(&#160;)</B>, the finalizers
will not be executed.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One reason that Java
1.1<A NAME="Index305"></A> might default to skipping finalization for all
objects is because it seems to be expensive. When you use either of the
approaches that force garbage collection you might notice longer delays than you
would without the extra
finalization.</FONT><A NAME="_Toc375545284"></A><A NAME="_Toc408018486"></A><BR></P></DIV>
<A NAME="Heading149"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Member initialization</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java goes out of its way to
guarantee that any variable is properly initialized before it is used. In the
case of variables that are defined locally to a method, this guarantee comes in
the form of a compile-time error. So if you say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>void</font> f() {
    <font color=#0000ff>int</font> i;
    i++;
  }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll get an error message
that says that <B>i</B> might not have been initialized. Of course, the compiler
could have given <B>i</B> a default value, but it&#8217;s more likely that this
is a programmer error and a default value would have covered that up. Forcing
the programmer to provide an initialization value is more likely to catch a
bug<A NAME="Index306"></A><A NAME="Index307"></A><A NAME="Index308"></A>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If a
<A NAME="Index309"></A><A NAME="Index310"></A><A NAME="Index311"></A>primitive
is a data member of a class, however, things are a bit different. Since any
method can initialize or use that data, it might not be practical to force the
user to initialize it to its appropriate value before the data is used. However,
it&#8217;s unsafe to leave it with a garbage value, so each primitive data
member of a class is guaranteed to get an initial value. Those values can be
seen here:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: InitialValues.java</font>
<font color=#009900>// Shows default initial values</font>

<font color=#0000ff>class</font> Measurement {
  <font color=#0000ff>boolean</font> t;
  <font color=#0000ff>char</font> c;
  <font color=#0000ff>byte</font> b;
  <font color=#0000ff>short</font> s;
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>long</font> l;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>double</font> d;
  <font color=#0000ff>void</font> print() {
    System.out.println(
      <font color=#004488>"Data type      Inital value\n"</font> +
      <font color=#004488>"boolean        "</font> + t + <font color=#004488>"\n"</font> +
      <font color=#004488>"char           "</font> + c + <font color=#004488>"\n"</font> +
      <font color=#004488>"byte           "</font> + b + <font color=#004488>"\n"</font> +
      <font color=#004488>"short          "</font> + s + <font color=#004488>"\n"</font> +
      <font color=#004488>"int            "</font> + i + <font color=#004488>"\n"</font> +
      <font color=#004488>"long           "</font> + l + <font color=#004488>"\n"</font> +
      <font color=#004488>"float          "</font> + f + <font color=#004488>"\n"</font> +
      <font color=#004488>"double         "</font> + d);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> InitialValues {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Measurement d = <font color=#0000ff>new</font> Measurement();
    d.print();
    <font color=#009900>/* In this case you could also say:
    new Measurement().print();
    */</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output of this program
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Data type      Inital value
<font color=#0000ff>boolean</font>        <font color=#0000ff>false</font>
<font color=#0000ff>char</font>
<font color=#0000ff>byte</font>           0
<font color=#0000ff>short</font>          0
<font color=#0000ff>int</font>            0
<font color=#0000ff>long</font>           0
<font color=#0000ff>float</font>          0.0
<font color=#0000ff>double</font>         0.0</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>char</B> value is a null,
which doesn&#8217;t print.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll see later that when
you define an object handle inside a class without initializing it to a new
object, that handle is given a value of null.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that even though the
values are not specified, they automatically get initialized. So at least
there&#8217;s no threat of working with uninitialized
variables.</FONT><A NAME="_Toc375545285"></A><A NAME="_Toc408018487"></A><BR></P></DIV>
<A NAME="Heading150"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Specifying initialization</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What happens if you want to give a
variable an initial value? One direct way to do this is simply to assign the
value at the point you define the variable in the class. (Notice you cannot do
this in C++, although C++ novices always try.) Here the field definitions in
class <B>Measurement</B> are changed to provide initial values:
<A NAME="Index312"></A><A NAME="Index313"></A></FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Measurement {
  <font color=#0000ff>boolean</font> b = <font color=#0000ff>true</font>;
  <font color=#0000ff>char</font> c = 'x';
  <font color=#0000ff>byte</font> B = 47;
  <font color=#0000ff>short</font> s = 0xff;
  <font color=#0000ff>int</font> i = 999;
  <font color=#0000ff>long</font> l = 1;
  <font color=#0000ff>float</font> f = 3.14f;
  <font color=#0000ff>double</font> d = 3.14159;
  <font color=#009900>//. . .</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also initialize
non-primitive objects in this same way. If <B>Depth</B> is a class, you can
insert a variable and initialize it like so:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Measurement {
  Depth o = <font color=#0000ff>new</font> Depth();
  <font color=#0000ff>boolean</font> b = <font color=#0000ff>true</font>;
  <font color=#009900>// . . .</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you haven&#8217;t given <B>o</B>
an initial value and you go ahead and try to use it anyway, you&#8217;ll get a
run-time error called an <I>exception</I> (covered in Chapter
9).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can even call a method to
provide an initialization value:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> CInit {
  <font color=#0000ff>int</font> i = f();
  <font color=#009900>//...</font>
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This method can have arguments, of
course, but those arguments cannot be other class members that haven&#8217;t
been initialized yet. Thus, you can do this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> CInit {
  <font color=#0000ff>int</font> i = f();
  <font color=#0000ff>int</font> j = g(i);
  <font color=#009900>//...</font>
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But you cannot do
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> CInit {
  <font color=#0000ff>int</font> j = g(i);
  <font color=#0000ff>int</font> i = f();
  <font color=#009900>//...</font>
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is one place in which the
compiler, appropriately, <I>does</I> complain about
<A NAME="Index314"></A><A NAME="Index315"></A>forward referencing, since this
has to do with the order of initialization and not the way the program is
compiled.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This approach to initialization is
simple and straightforward. It has the limitation that <I>every</I> object of
type <B>Measurement</B> will get these same initialization values. Sometimes
this is exactly what you need, but at other times you need more
flexibility.</FONT><A NAME="_Toc375545286"></A><A NAME="_Toc408018488"></A><BR></P></DIV>
<A NAME="Heading151"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Constructor initialization</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor can be used to
perform initialization, and this gives you greater flexibility in your
programming since you can call methods and perform actions at run time to
determine the initial values. There&#8217;s one thing to keep in mind, however:
you aren&#8217;t precluding the automatic initialization, which happens before
the constructor is entered. So, for example, if you say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Counter {
  <font color=#0000ff>int</font> i;
  Counter() { i = 7; }
  <font color=#009900>// . . .</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">then <B>i </B>will first be
initialized to zero, then to 7. This is true with all the primitive types and
with object handles, including those that are given explicit initialization at
the point of definition. For this reason, the compiler doesn&#8217;t try to
force you to initialize elements in the constructor at any particular place, or
before they are used &#8211; initialization is already
guaranteed.</FONT><A NAME="fnB21" HREF="#fn21">[21]</A><BR></P></DIV>
<A NAME="Heading152"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Order of
initialization<BR><A NAME="Index316"></A><A NAME="Index317"></A><A NAME="Index318"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Within a class, the order of
initialization is determined by the order that the variables are defined within
the class. Even if the variable definitions are scattered throughout in between
method definitions, the variables are initialized before any methods can be
called &#8211; even the constructor. For example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: OrderOfInitialization.java</font>
<font color=#009900>// Demonstrates initialization order.</font>

<font color=#009900>// When the constructor is called, to create a</font>
<font color=#009900>// Tag object, you'll see a message:</font>
<font color=#0000ff>class</font> Tag {
  Tag(<font color=#0000ff>int</font> marker) {
    System.out.println(<font color=#004488>"Tag("</font> + marker + <font color=#004488>")"</font>);
  }
}

<font color=#0000ff>class</font> Card {
  Tag t1 = <font color=#0000ff>new</font> Tag(1); <font color=#009900>// Before constructor</font>
  Card() {
    <font color=#009900>// Indicate we're in the constructor:</font>
    System.out.println(<font color=#004488>"Card()"</font>);
    t3 = <font color=#0000ff>new</font> Tag(33); <font color=#009900>// Re-initialize t3</font>
  }
  Tag t2 = <font color=#0000ff>new</font> Tag(2); <font color=#009900>// After constructor</font>
  <font color=#0000ff>void</font> f() {
    System.out.println(<font color=#004488>"f()"</font>);
  }
  Tag t3 = <font color=#0000ff>new</font> Tag(3); <font color=#009900>// At end</font>
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> OrderOfInitialization {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Card t = <font color=#0000ff>new</font> Card();
    t.f(); <font color=#009900>// Shows that construction is done</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Card</B>, the definitions of
the <B>Tag</B> objects are intentionally scattered about to prove that
they&#8217;ll all get initialized before the constructor is entered or anything
else can happen. In addition, <B>t3</B> is re-initialized inside the
constructor. The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Tag(1)
Tag(2)
Tag(3)
Card()
Tag(33)
f()</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, the <B>t3</B> handle gets
initialized twice, once before and once during the constructor call. (The first
object is dropped, so it can be garbage-collected later.) This might not seem
efficient at first, but it guarantees proper initialization &#8211; what would
happen if an overloaded constructor were defined that did <I>not</I> initialize
<B>t3</B> and there wasn&#8217;t a &#8220;default&#8221; initialization for
<B>t3</B> in its definition?</FONT><BR></P></DIV>
<A NAME="Heading153"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Static data initialization</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the
<A NAME="Index319"></A><A NAME="Index320"></A>data is <B>static</B> the same
thing happens; if it&#8217;s a primitive and you don&#8217;t initialize it, it
gets the standard primitive initial values. If it&#8217;s a handle to an object,
it&#8217;s null unless you create a new object and attach your handle to
it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to place initialization
at the point of definition, it looks the same as for non-statics. But since
there&#8217;s only a single piece of storage for a <B>static</B>, regardless of
how many objects are created the question of when that storage gets initialized
arises. An example makes this question clear:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: StaticInitialization.java</font>
<font color=#009900>// Specifying initial values in a</font>
<font color=#009900>// class definition.</font>

<font color=#0000ff>class</font> Bowl {
  Bowl(<font color=#0000ff>int</font> marker) {
    System.out.println(<font color=#004488>"Bowl("</font> + marker + <font color=#004488>")"</font>);
  }
  <font color=#0000ff>void</font> f(<font color=#0000ff>int</font> marker) {
    System.out.println(<font color=#004488>"f("</font> + marker + <font color=#004488>")"</font>);
  }
}

<font color=#0000ff>class</font> Table {
  <font color=#0000ff>static</font> Bowl b1 = <font color=#0000ff>new</font> Bowl(1);
  Table() {
    System.out.println(<font color=#004488>"Table()"</font>);
    b2.f(1);
  }
  <font color=#0000ff>void</font> f2(<font color=#0000ff>int</font> marker) {
    System.out.println(<font color=#004488>"f2("</font> + marker + <font color=#004488>")"</font>);
  }
  <font color=#0000ff>static</font> Bowl b2 = <font color=#0000ff>new</font> Bowl(2);
}

<font color=#0000ff>class</font> Cupboard {
  Bowl b3 = <font color=#0000ff>new</font> Bowl(3);
  <font color=#0000ff>static</font> Bowl b4 = <font color=#0000ff>new</font> Bowl(4);
  Cupboard() {
    System.out.println(<font color=#004488>"Cupboard()"</font>);
    b4.f(2);
  }
  <font color=#0000ff>void</font> f3(<font color=#0000ff>int</font> marker) {
    System.out.println(<font color=#004488>"f3("</font> + marker + <font color=#004488>")"</font>);
  }
  <font color=#0000ff>static</font> Bowl b5 = <font color=#0000ff>new</font> Bowl(5);
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StaticInitialization {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(
      <font color=#004488>"Creating new Cupboard() in main"</font>);
    <font color=#0000ff>new</font> Cupboard();
    System.out.println(
      <font color=#004488>"Creating new Cupboard() in main"</font>);
    <font color=#0000ff>new</font> Cupboard();
    t2.f2(1);
    t3.f3(1);
  }
  <font color=#0000ff>static</font> Table t2 = <font color=#0000ff>new</font> Table();
  <font color=#0000ff>static</font> Cupboard t3 = <font color=#0000ff>new</font> Cupboard();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Bowl</B> allows you to view the
creation of a class, and <B>Table</B> and <B>Cupboard</B> create <B>static</B>
members of <B>Bowl</B> scattered through their class definitions. Note that
<B>Cupboard</B> creates a non-<B>static</B> <B>Bowl b3</B> prior to the
<B>static</B> definitions. The output shows what happens:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Bowl(1)
Bowl(2)
Table()
f(1)
Bowl(4)
Bowl(5)
Bowl(3)
Cupboard()
f(2)
Creating <font color=#0000ff>new</font> Cupboard() in main
Bowl(3)
Cupboard()
f(2)
Creating <font color=#0000ff>new</font> Cupboard() in main
Bowl(3)
Cupboard()
f(2)
f2(1)
f3(1)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>static</B> initialization
occurs only if it&#8217;s necessary. If you don&#8217;t create a <B>Table
</B>object and you never refer to <B>Table.b1 </B>or <B>Table.b2</B>, the
<B>static Bowl b1 </B>and <B>b2 </B>will never be created. However, they are
created only when the <I>first </I><B>Table </B>object is created (or the first
<B>static</B> access occurs). After that, the <B>static</B> object is not
re-initialized.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The order of initialization is
<B>static</B>s first, if they haven&#8217;t already been initialized by a
previous object creation, and then the non-<B>static</B> objects. You can see
the evidence of this in the output.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s helpful to summarize the
<A NAME="Index321"></A>process of creating an object. Consider a class called
<B>Dog</B>:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Georgia">	The first time an object of type <B>Dog</B> is
created, <I>or</I> the first time a <B>static</B> method or <B>static </B>field
of class <B>Dog</B> is accessed, the Java interpreter must locate
<B>Dog.class</B>, which it does by searching through the
classpath.</FONT><LI><FONT FACE="Georgia">	As <B>Dog.class</B> is loaded
(which creates a <B>Class</B> object, which you&#8217;ll learn about later), all
of its <B>static</B> initializers are run. Thus, <B>static </B>initialization
takes place only once, as the <B>Class</B> object is loaded for the first
time.</FONT><LI><FONT FACE="Georgia">	When you create a <B>new
Dog(&#160;)</B>, the construction process for a <B>Dog</B> object first
allocates enough storage for a <B>Dog</B> object on the
heap.</FONT><LI><FONT FACE="Georgia">	This storage is wiped to zero,
automatically setting all the primitives in <B>Dog</B> to their default values
(zero for numbers and the equivalent for <B>boolean</B> and
<B>char</B>).</FONT><LI><FONT FACE="Georgia">	Any initializations that
occur at the point of field definition are
executed.</FONT><LI><FONT FACE="Georgia">	Constructors are executed. As
you shall see in Chapter 6, this might actually involve a fair amount of
activity, especially when inheritance is
involved.</FONT></OL><A NAME="Heading154"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Explicit static initialization</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java allows you to group other
<B>static</B> initializations inside a special
&#8220;<A NAME="Index322"></A><A NAME="Index323"></A><B>static</B> construction
clause&#8221; (sometimes called a <A NAME="Index324"></A><I>static block</I>)<I>
</I>in a class. It looks like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Spoon {
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>static</font> {
    i = 47;
  }
  <font color=#009900>// . . .</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So it looks like a method, but
it&#8217;s just the <B>static</B> keyword followed by a method body. This code,
like the other <B>static</B> initialization, is executed only once, the first
time you make an object of that class <I>or</I> you access a <B>static</B>
member of that class (even if you never make an object of that class). For
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ExplicitStatic.java</font>
<font color=#009900>// Explicit static initialization</font>
<font color=#009900>// with the "static" clause.</font>

<font color=#0000ff>class</font> Cup {
  Cup(<font color=#0000ff>int</font> marker) {
    System.out.println(<font color=#004488>"Cup("</font> + marker + <font color=#004488>")"</font>);
  }
  <font color=#0000ff>void</font> f(<font color=#0000ff>int</font> marker) {
    System.out.println(<font color=#004488>"f("</font> + marker + <font color=#004488>")"</font>);
  }
}

<font color=#0000ff>class</font> Cups {
  <font color=#0000ff>static</font> Cup c1;
  <font color=#0000ff>static</font> Cup c2;
  <font color=#0000ff>static</font> {
    c1 = <font color=#0000ff>new</font> Cup(1);
    c2 = <font color=#0000ff>new</font> Cup(2);
  }
  Cups() {
    System.out.println(<font color=#004488>"Cups()"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ExplicitStatic {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Inside main()"</font>);
    Cups.c1.f(99);  <font color=#009900>// (1)</font>
  }
  <font color=#0000ff>static</font> Cups x = <font color=#0000ff>new</font> Cups();  <font color=#009900>// (2)</font>
  <font color=#0000ff>static</font> Cups y = <font color=#0000ff>new</font> Cups();  <font color=#009900>// (2) </font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>static</B> initializers for
<B>Cups</B> will be run when either the access of the <B>static</B> object
<B>c1</B> occurs on the line marked (1), or if line (1) is commented out and the
lines marked (2) are uncommented. If both (1) and (2) are commented out, the
<B>static</B> initialization for <B>Cups</B> never occurs.</FONT><BR></P></DIV>
<A NAME="Heading155"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Non-static instance
initialization<BR><A NAME="Index325"></A><A NAME="Index326"></A><A NAME="Index327"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1<A NAME="Index328"></A>
provides a similar syntax for initializing non-static variables for each object.
Here&#8217;s an example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Mugs.java</font>
<font color=#009900>// Java 1.1 "Instance Initialization"</font>

<font color=#0000ff>class</font> Mug {
  Mug(<font color=#0000ff>int</font> marker) {
    System.out.println(<font color=#004488>"Mug("</font> + marker + <font color=#004488>")"</font>);
  }
  <font color=#0000ff>void</font> f(<font color=#0000ff>int</font> marker) {
    System.out.println(<font color=#004488>"f("</font> + marker + <font color=#004488>")"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Mugs {
  Mug c1;
  Mug c2;
  {
    c1 = <font color=#0000ff>new</font> Mug(1);
    c2 = <font color=#0000ff>new</font> Mug(2);
    System.out.println(<font color=#004488>"c1 &amp; c2 initialized"</font>);
  }
  Mugs() {
    System.out.println(<font color=#004488>"Mugs()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Inside main()"</font>);
    Mugs x = <font color=#0000ff>new</font> Mugs();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the instance
initialization clause:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  {
    c1 = <font color=#0000ff>new</font> Mug(1);
    c2 = <font color=#0000ff>new</font> Mug(2);
    System.out.println(<font color=#004488>"c1 &amp; c2 initialized"</font>);
  }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">looks exactly like the static
initialization clause except for the missing <B>static</B> keyword. This syntax
is necessary to support the initialization of <I>anonymous inner classes</I>
(see Chapter
7).</FONT><A NAME="_Toc312373861"></A><A NAME="_Toc375545287"></A><A NAME="_Toc408018489"></A><BR></P></DIV>
<A NAME="Heading156"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Array initialization</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Initializing arrays in C is
error-prone and tedious. C++ uses <I>aggregate initialization</I> to make it
much
safer.</FONT><A NAME="fnB22" HREF="#fn22">[22]</A><FONT FACE="Georgia">
Java has no &#8220;aggregates&#8221; like C++, since everything is an object in
Java. It does have arrays, and these are supported with
<A NAME="Index329"></A><A NAME="Index330"></A>array
initialization.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An array is simply a sequence of
either objects or primitives, all the same type and packaged together under one
identifier name. Arrays are defined and used with the square-brackets
<A NAME="Index331"></A><A NAME="Index332"></A><A NAME="Index333"></A><I>indexing
operator</I> <B>[&#160;]</B>. To define an array you simply follow your type
name with empty square brackets:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font>[] a1;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also put the square
brackets after the identifier to produce exactly the same
meaning:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> a1[];</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This conforms to expectations from
C and C++ programmers. The former style, however, is probably a more sensible
syntax, since it says that the type is &#8220;an <B>int</B> array.&#8221; That
style will be used in this book.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The compiler doesn&#8217;t allow
you to tell it how big the array is. This brings us back to that issue of
&#8220;handles.&#8221; All that you have at this point is a handle to an array,
and there&#8217;s been no space allocated for the array. To create storage for
the array you must write an initialization expression. For arrays,
initialization can appear anywhere in your code, but you can also use a special
kind of initialization expression that must occur at the point where the array
is created. This special initialization is a set of values surrounded by curly
braces. The storage allocation (the equivalent of using <B>new</B>) is taken
care of by the compiler in this case. For example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font>[] a1 = { 1, 2, 3, 4, 5 };</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So why would you ever define an
array handle without an array?</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font>[] a2;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Well, it&#8217;s possible to assign
one array to another in Java, so you can say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a2 = a1;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What you&#8217;re really doing is
copying a handle, as demonstrated here:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Arrays.java</font>
<font color=#009900>// Arrays of primitives.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Arrays {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] a1 = { 1, 2, 3, 4, 5 };
    <font color=#0000ff>int</font>[] a2;
    a2 = a1;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a2.length; i++)
      a2[i]++;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a1.length; i++)
      prt(<font color=#004488>"a1["</font> + i + <font color=#004488>"] = "</font> + a1[i]);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) {
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that <B>a1</B> is given
an initialization value while <B>a2</B> is not; <B>a2</B> is assigned later
&#8211; in this case, to another array. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s something new here:
all arrays have an intrinsic member (whether they&#8217;re arrays of objects or
arrays of primitives) that you can query &#8211; but not change &#8211; to tell
you how many elements there are in the array. This member is <B>length</B>.
Since arrays in Java, like C and C++, start counting from element zero, the
largest element you can index is <B>length - 1</B>. If you go out of
<A NAME="Index334"></A><A NAME="Index335"></A>bounds, C and C++ quietly accept
this and allow you to stomp all over your memory, which is the source of many
infamous bugs. However, Java protects you against such problems by causing a
run-time error (an <I>exception</I>, the subject of Chapter 9) if you step out
of bounds. Of course, checking every array access costs time and code and
there&#8217;s no way to turn it off, which means that array accesses might be a
source of inefficiency in your program if they occur at a critical juncture. For
Internet security and programmer productivity, the Java designers thought that
this was a worthwhile tradeoff.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What if you don&#8217;t know how
many elements you&#8217;re going to need in your array while you&#8217;re
writing the program? You simply use <B>new</B> to create the elements in the
array. Here, <A NAME="Index336"></A><B>new</B> works even though it&#8217;s
creating an array of primitives (<B>new</B> won&#8217;t create a non-array
primitive):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ArrayNew.java</font>
<font color=#009900>// Creating arrays with new.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArrayNew {
  <font color=#0000ff>static</font> Random rand = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> pRand(<font color=#0000ff>int</font> mod) {
    <font color=#0000ff>return</font> Math.abs(rand.nextInt()) % mod + 1;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] a;
    a = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[pRand(20)];
    prt(<font color=#004488>"length of a = "</font> + a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++)
      prt(<font color=#004488>"a["</font> + i + <font color=#004488>"] = "</font> + a[i]);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) {
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since the size of the array is
chosen at random (using the <B>pRand(&#160;)</B> method defined earlier),
it&#8217;s clear that array creation is actually happening at run-time. In
addition, you&#8217;ll see from the output of this program that array elements
of primitive types are automatically initialized to &#8221;empty&#8221; values.
(For numerics, this is zero, for <B>char</B>, it&#8217;s <B>null</B>, and for
<B>boolean</B>, it's <B>false</B>.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, the array could also
have been defined and initialized in the same statement:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font>[] a = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[pRand(20)];</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re dealing with an
array of non-primitive objects, you must always use <B>new</B>. Here, the handle
issue comes up again because what you create is an array of handles. Consider
the wrapper type <B>Integer,</B> which is a class and not a
primitive:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ArrayClassObj.java</font>
<font color=#009900>// Creating an array of non-primitive objects.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArrayClassObj {
  <font color=#0000ff>static</font> Random rand = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> pRand(<font color=#0000ff>int</font> mod) {
    <font color=#0000ff>return</font> Math.abs(rand.nextInt()) % mod + 1;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Integer[] a = <font color=#0000ff>new</font> Integer[pRand(20)];
    prt(<font color=#004488>"length of a = "</font> + a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++) {
      a[i] = <font color=#0000ff>new</font> Integer(pRand(500));
      prt(<font color=#004488>"a["</font> + i + <font color=#004488>"] = "</font> + a[i]);
    }
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) {
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, even after <B>new</B> is
called to create the array:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Integer[] a = <font color=#0000ff>new</font> Integer[pRand(20)];</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">it&#8217;s only an array of
handles, and not until the handle itself is initialized by creating a new
<B>Integer</B> object is the initialization complete:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a[i] = <font color=#0000ff>new</font> Integer(pRand(500));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you forget to create the object,
however, you&#8217;ll get an exception at run-time when you try to read the
empty array location.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Take a look at the formation of the
<B>String </B>object inside the print statements. You can see that the handle to
the <B>Integer</B> object is automatically converted to produce a <B>String
</B>representing the value inside the object.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s also possible to
initialize arrays of objects using the curly-brace-enclosed list. There are two
forms, the first of which is the only one allowed in Java
1.0<A NAME="Index337"></A>. The second (equivalent) form is allowed starting
with Java 1.1<A NAME="Index338"></A>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ArrayInit.java</font>
<font color=#009900>// Array initialization</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArrayInit {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Integer[] a = {
      <font color=#0000ff>new</font> Integer(1),
      <font color=#0000ff>new</font> Integer(2),
      <font color=#0000ff>new</font> Integer(3),
    };

    <font color=#009900>// Java 1.1 only:</font>
    Integer[] b = <font color=#0000ff>new</font> Integer[] {
      <font color=#0000ff>new</font> Integer(1),
      <font color=#0000ff>new</font> Integer(2),
      <font color=#0000ff>new</font> Integer(3),
    };
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is useful at times, but
it&#8217;s more limited since the size of the array is determined at compile
time. The final comma in the list of initializers is optional. (This feature
makes for easier maintenance of long lists.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second form of array
initialization, added in Java 1.1<A NAME="Index339"></A>, provides a convenient
syntax to create and call methods that can produce the same effect as C&#8217;s
<A NAME="Index340"></A><A NAME="Index341"></A><I>variable argument lists</I>
(known as &#8220;varargs&#8221; in C). These included, if you choose, unknown
quantity of arguments as well as unknown type. Since all classes are ultimately
inherited from the common root class <B>Object</B>, you can create a method that
takes an array of <B>Object</B> and call it like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: VarArgs.java</font>
<font color=#009900>// Using the Java 1.1 array syntax to create</font>
<font color=#009900>// variable argument lists</font>

<font color=#0000ff>class</font> A { <font color=#0000ff>int</font> i; }

<font color=#0000ff>public</font> <font color=#0000ff>class</font> VarArgs {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> f(Object[] x) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; x.length; i++)
      System.out.println(x[i]);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    f(<font color=#0000ff>new</font> Object[] { 
        <font color=#0000ff>new</font> Integer(47), <font color=#0000ff>new</font> VarArgs(), 
        <font color=#0000ff>new</font> Float(3.14), <font color=#0000ff>new</font> Double(11.11) });
    f(<font color=#0000ff>new</font> Object[] {<font color=#004488>"one"</font>, <font color=#004488>"two"</font>, <font color=#004488>"three"</font> });
    f(<font color=#0000ff>new</font> Object[] {<font color=#0000ff>new</font> A(), <font color=#0000ff>new</font> A(), <font color=#0000ff>new</font> A()});
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point, there&#8217;s not
much you can do with these unknown objects, and this program uses the automatic
<B>String</B> conversion to do something useful with each <B>Object</B>. In
Chapter 11 (run-time type identification or RTTI) you&#8217;ll learn how to
discover the exact type of such objects so that you can do something more
interesting with them.</FONT><A NAME="_Toc408018490"></A><BR></P></DIV>
<A NAME="Heading157"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Multidimensional arrays</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java allows you to easily create
<A NAME="Index342"></A><A NAME="Index343"></A>multidimensional
arrays:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MultiDimArray.java</font>
<font color=#009900>// Creating multidimensional arrays.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MultiDimArray {
  <font color=#0000ff>static</font> Random rand = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> pRand(<font color=#0000ff>int</font> mod) {
    <font color=#0000ff>return</font> Math.abs(rand.nextInt()) % mod + 1;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[][] a1 = {
      { 1, 2, 3, },
      { 4, 5, 6, },
    };
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a1.length; i++)
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a1[i].length; j++)
        prt(<font color=#004488>"a1["</font> + i + <font color=#004488>"]["</font> + j +
            <font color=#004488>"] = "</font> + a1[i][j]);
    <font color=#009900>// 3-D array with fixed length:</font>
    <font color=#0000ff>int</font>[][][] a2 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[2][2][4];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a2.length; i++)
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a2[i].length; j++)
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> k = 0; k &lt; a2[i][j].length;
            k++)
          prt(<font color=#004488>"a2["</font> + i + <font color=#004488>"]["</font> +
              j + <font color=#004488>"]["</font> + k +
              <font color=#004488>"] = "</font> + a2[i][j][k]);
    <font color=#009900>// 3-D array with varied-length vectors:</font>
    <font color=#0000ff>int</font>[][][] a3 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[pRand(7)][][];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a3.length; i++) {
      a3[i] = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[pRand(5)][];
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a3[i].length; j++)
        a3[i][j] = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[pRand(5)];
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a3.length; i++)
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a3[i].length; j++)
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> k = 0; k &lt; a3[i][j].length;
            k++)
          prt(<font color=#004488>"a3["</font> + i + <font color=#004488>"]["</font> +
              j + <font color=#004488>"]["</font> + k +
              <font color=#004488>"] = "</font> + a3[i][j][k]);
    <font color=#009900>// Array of non-primitive objects:</font>
    Integer[][] a4 = {
      { <font color=#0000ff>new</font> Integer(1), <font color=#0000ff>new</font> Integer(2)},
      { <font color=#0000ff>new</font> Integer(3), <font color=#0000ff>new</font> Integer(4)},
      { <font color=#0000ff>new</font> Integer(5), <font color=#0000ff>new</font> Integer(6)},
    };
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a4.length; i++)
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a4[i].length; j++)
        prt(<font color=#004488>"a4["</font> + i + <font color=#004488>"]["</font> + j +
            <font color=#004488>"] = "</font> + a4[i][j]);
    Integer[][] a5;
    a5 = <font color=#0000ff>new</font> Integer[3][];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a5.length; i++) {
      a5[i] = <font color=#0000ff>new</font> Integer[3];
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a5[i].length; j++)
        a5[i][j] = <font color=#0000ff>new</font> Integer(i*j);
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a5.length; i++)
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a5[i].length; j++)
        prt(<font color=#004488>"a5["</font> + i + <font color=#004488>"]["</font> + j +
            <font color=#004488>"] = "</font> + a5[i][j]);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) {
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The code used for printing uses
<B>length</B> so that it doesn&#8217;t depend on fixed array
sizes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first example shows a
multidimensional array of primitives. You delimit each vector in the array with
curly braces:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>int</font>[][] a1 = {
      { 1, 2, 3, },
      { 4, 5, 6, },
    };</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each set of square brackets moves
you into the next level of the array.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second example shows a
three-dimensional array allocated with <B>new</B>. Here, the whole array is
allocated at once:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font>[][][] a2 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[2][2][4];</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But the third example shows that
each vector in the arrays that make up the matrix can be of any
length:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>int</font>[][][] a3 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[pRand(7)][][];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a3.length; i++) {
      a3[i] = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[pRand(5)][];
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a3[i].length; j++)
        a3[i][j] = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[pRand(5)];
    }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first <B>new</B> creates an
array with a random-length first element and the rest undetermined. The second
<B>new</B> inside the for loop fills out the elements but leaves the third index
undetermined until you hit the third <B>new</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You will see from the output that
array values are automatically initialized to zero if you don&#8217;t give them
an explicit initialization value.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can deal with arrays of
non-primitive objects in a similar fashion, which is shown in the fourth
example, demonstrating the ability to collect many <B>new</B> expressions with
curly braces:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    Integer[][] a4 = {
      { <font color=#0000ff>new</font> Integer(1), <font color=#0000ff>new</font> Integer(2)},
      { <font color=#0000ff>new</font> Integer(3), <font color=#0000ff>new</font> Integer(4)},
      { <font color=#0000ff>new</font> Integer(5), <font color=#0000ff>new</font> Integer(6)},
    };</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fifth example shows how an
array of non-primitive objects can be built up piece by piece:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    Integer[][] a5;
    a5 = <font color=#0000ff>new</font> Integer[3][];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a5.length; i++) {
      a5[i] = <font color=#0000ff>new</font> Integer[3];
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a5[i].length; j++)
        a5[i][j] = <font color=#0000ff>new</font> Integer(i*j);
    }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>i*j</B> is just to put an
interesting value into the
<B>Integer</B>.</FONT><A NAME="_Toc375545288"></A><A NAME="_Toc408018491"></A><BR></P></DIV>
<A NAME="Heading158"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The seemingly elaborate mechanism
for initialization, the constructor, should give you a strong hint about the
critical importance placed on initialization in the language. As Stroustrup was
designing C++, one of the first observations he made about productivity in C was
that improper initialization of variables causes a significant portion of
programming problems. These kinds of bugs are hard to find, and similar issues
apply to improper cleanup. Because constructors allow you to <I>guarantee</I>
proper initialization and cleanup (the compiler will not allow an object to be
created without the proper constructor calls), you get complete control and
safety.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In C++, destruction is quite
important because objects created with <B>new</B> must be explicitly destroyed.
In Java, the garbage collector automatically releases the memory for all
objects, so the equivalent cleanup method in Java isn&#8217;t necessary much of
the time. In cases where you don&#8217;t need destructor-like behavior,
Java&#8217;s garbage collector greatly simplifies programming, and adds
much-needed safety in managing memory. Some garbage collectors are even cleaning
up other resources like graphics and file handles. However, the garbage
collector does add a run-time cost, the expense of which is difficult to put
into perspective because of the overall slowness of Java interpreters at this
writing. As this changes, we&#8217;ll be able to discover if the overhead of the
garbage collector will preclude the use of Java for certain types of programs.
(One of the issues is the unpredictability of the garbage
collector.)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because of the guarantee that all
objects will be constructed, there&#8217;s actually more to the constructor than
what is shown here. In particular, when you create new classes using either
<I>composition</I> or <I>inheritance</I> the guarantee of construction also
holds, and some additional syntax is necessary to support this. You&#8217;ll
learn about composition, inheritance and how they affect constructors in future
chapters.</FONT><A NAME="_Toc375545289"></A><A NAME="_Toc408018492"></A><BR></P></DIV>
<A NAME="Heading159"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
a class with a default constructor (one that takes no arguments) that prints a
message. Create an object of this
class.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Add
an overloaded constructor to Exercise 1 that takes a <B>String</B> argument and
prints it along with your
message.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Create
an array of object handles of the class you created in Exercise 2, but
don&#8217;t actually create objects to assign into the array. When you run the
program, notice whether the initialization messages from the constructor calls
are
printed.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Complete
Exercise 3 by creating objects to attach to the array of
handles.</FONT><LI><FONT FACE="Verdana" SIZE=5>	</FONT><FONT FACE="Georgia">Experiment
with <B>Garbage.java</B> by running the program using the arguments
&#8220;before,&#8221; &#8220;after&#8221; and &#8220;none.&#8221; Repeat the
process and see if you detect any patterns in the output. Change the code so
that <B>System.runFinalization(&#160;) </B>is called before
<B>System.gc(&#160;)</B> and observe the
results.</FONT></OL>

<HR><DIV ALIGN="LEFT"><P><A NAME="fn17" HREF="#fnB17">[17]</A><FONT FACE="Georgia" SIZE=2>
In some of the Java literature from Sun they instead refer to these with the
clumsy but descriptive name &#8220;no-arg constructors.&#8221; The term
&#8220;default constructor&#8221; has been in use for many years and so I will
use that.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn18" HREF="#fnB18">[18]</A><FONT FACE="Georgia" SIZE=2>
The one case in which this is possible occurs if you pass a handle to an object
into the <B>static</B> method. Then, via the handle (which is now effectively
<B>this</B>), you can call non-<B>static</B> methods and access
non-<B>static</B> fields. But typically if you want to do something like this
you&#8217;ll just make an ordinary, non-<B>static</B> method.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn19" HREF="#fnB19">[19]</A><FONT FACE="Georgia">
</FONT><FONT FACE="Georgia" SIZE=2>Unfortunately, the implementations of
the garbage collector in Java 1.0 would never call <B>finalize(&#160;)</B>
correctly. As a result, <B>finalize(&#160;)</B> methods that were essential
(such as those to close a file) often didn&#8217;t get called. The documentation
claimed that all finalizers would be called at the exit of a program, even if
the garbage collector hadn&#8217;t been run on those objects by the time the
program terminated. This wasn&#8217;t true, so as a result you couldn&#8217;t
reliably expect <B>finalize(&#160;)</B> to be called for all objects.
Effectively, <B>finalize(&#160;)</B> was useless in Java 1.0.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn20" HREF="#fnB20">[20]</A><FONT FACE="Georgia" SIZE=2>
By the time you read this, some Java Virtual Machines may show different
behavior.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn21" HREF="#fnB21">[21]</A><FONT FACE="Georgia" SIZE=2>
In contrast, C++ has the <I>constructor initializer list</I> that causes
initialization to occur before entering the constructor body, and is enforced
for objects. See <I>Thinking in C++</I>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn22" HREF="#fnB22">[22]</A><FONT FACE="Georgia" SIZE=2>
See <I>Thinking in C++</I> for a complete description of aggregate
initialization.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter03.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter05.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/04/2000</P></DIV>

</BODY>

</HTML>
